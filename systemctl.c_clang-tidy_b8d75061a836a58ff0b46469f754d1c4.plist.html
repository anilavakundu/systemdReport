<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"4": {"id": 4, "path": "/media/lavo07/lavo07/systemd-239/src/basic/macro.h", "content": "/* SPDX-License-Identifier: LGPL-2.1+ */\n#pragma once\n\n#include <inttypes.h>\n#include <stdbool.h>\n#include <sys/param.h>\n#include <sys/sysmacros.h>\n#include <sys/types.h>\n\n#define _printf_(a,b) __attribute__ ((format (printf, a, b)))\n#ifdef __clang__\n#  define _alloc_(...)\n#else\n#  define _alloc_(...) __attribute__ ((alloc_size(__VA_ARGS__)))\n#endif\n#define _sentinel_ __attribute__ ((sentinel))\n#define _unused_ __attribute__ ((unused))\n#define _destructor_ __attribute__ ((destructor))\n#define _pure_ __attribute__ ((pure))\n#define _const_ __attribute__ ((const))\n#define _deprecated_ __attribute__ ((deprecated))\n#define _packed_ __attribute__ ((packed))\n#define _malloc_ __attribute__ ((malloc))\n#define _weak_ __attribute__ ((weak))\n#define _likely_(x) (__builtin_expect(!!(x),1))\n#define _unlikely_(x) (__builtin_expect(!!(x),0))\n#define _public_ __attribute__ ((visibility(\"default\")))\n#define _hidden_ __attribute__ ((visibility(\"hidden\")))\n#define _weakref_(x) __attribute__((weakref(#x)))\n#define _alignas_(x) __attribute__((aligned(__alignof(x))))\n#define _cleanup_(x) __attribute__((cleanup(x)))\n#if __GNUC__ >= 7\n#define _fallthrough_ __attribute__((fallthrough))\n#else\n#define _fallthrough_\n#endif\n/* Define C11 noreturn without <stdnoreturn.h> and even on older gcc\n * compiler versions */\n#ifndef _noreturn_\n#if __STDC_VERSION__ >= 201112L\n#define _noreturn_ _Noreturn\n#else\n#define _noreturn_ __attribute__((noreturn))\n#endif\n#endif\n\n#if !defined(HAS_FEATURE_MEMORY_SANITIZER)\n#  if defined(__has_feature)\n#    if __has_feature(memory_sanitizer)\n#      define HAS_FEATURE_MEMORY_SANITIZER 1\n#    endif\n#  endif\n#  if !defined(HAS_FEATURE_MEMORY_SANITIZER)\n#    define HAS_FEATURE_MEMORY_SANITIZER 0\n#  endif\n#endif\n\n/* Temporarily disable some warnings */\n#define DISABLE_WARNING_DECLARATION_AFTER_STATEMENT                     \\\n        _Pragma(\"GCC diagnostic push\");                                 \\\n        _Pragma(\"GCC diagnostic ignored \\\"-Wdeclaration-after-statement\\\"\")\n\n#define DISABLE_WARNING_FORMAT_NONLITERAL                               \\\n        _Pragma(\"GCC diagnostic push\");                                 \\\n        _Pragma(\"GCC diagnostic ignored \\\"-Wformat-nonliteral\\\"\")\n\n#define DISABLE_WARNING_MISSING_PROTOTYPES                              \\\n        _Pragma(\"GCC diagnostic push\");                                 \\\n        _Pragma(\"GCC diagnostic ignored \\\"-Wmissing-prototypes\\\"\")\n\n#define DISABLE_WARNING_NONNULL                                         \\\n        _Pragma(\"GCC diagnostic push\");                                 \\\n        _Pragma(\"GCC diagnostic ignored \\\"-Wnonnull\\\"\")\n\n#define DISABLE_WARNING_SHADOW                                          \\\n        _Pragma(\"GCC diagnostic push\");                                 \\\n        _Pragma(\"GCC diagnostic ignored \\\"-Wshadow\\\"\")\n\n#define DISABLE_WARNING_INCOMPATIBLE_POINTER_TYPES                      \\\n        _Pragma(\"GCC diagnostic push\");                                 \\\n        _Pragma(\"GCC diagnostic ignored \\\"-Wincompatible-pointer-types\\\"\")\n\n#define REENABLE_WARNING                                                \\\n        _Pragma(\"GCC diagnostic pop\")\n\n/* automake test harness */\n#define EXIT_TEST_SKIP 77\n\n#define XSTRINGIFY(x) #x\n#define STRINGIFY(x) XSTRINGIFY(x)\n\n#define XCONCATENATE(x, y) x ## y\n#define CONCATENATE(x, y) XCONCATENATE(x, y)\n\n#define UNIQ_T(x, uniq) CONCATENATE(__unique_prefix_, CONCATENATE(x, uniq))\n#define UNIQ __COUNTER__\n\n/* builtins */\n#if __SIZEOF_INT__ == 4\n#define BUILTIN_FFS_U32(x) __builtin_ffs(x);\n#elif __SIZEOF_LONG__ == 4\n#define BUILTIN_FFS_U32(x) __builtin_ffsl(x);\n#else\n#error \"neither int nor long are four bytes long?!?\"\n#endif\n\n/* Rounds up */\n\n#define ALIGN4(l) (((l) + 3) & ~3)\n#define ALIGN8(l) (((l) + 7) & ~7)\n\n#if __SIZEOF_POINTER__ == 8\n#define ALIGN(l) ALIGN8(l)\n#elif __SIZEOF_POINTER__ == 4\n#define ALIGN(l) ALIGN4(l)\n#else\n#error \"Wut? Pointers are neither 4 nor 8 bytes long?\"\n#endif\n\n#define ALIGN_PTR(p) ((void*) ALIGN((unsigned long) (p)))\n#define ALIGN4_PTR(p) ((void*) ALIGN4((unsigned long) (p)))\n#define ALIGN8_PTR(p) ((void*) ALIGN8((unsigned long) (p)))\n\nstatic inline size_t ALIGN_TO(size_t l, size_t ali) {\n        return ((l + ali - 1) & ~(ali - 1));\n}\n\n#define ALIGN_TO_PTR(p, ali) ((void*) ALIGN_TO((unsigned long) (p), (ali)))\n\n/* align to next higher power-of-2 (except for: 0 => 0, overflow => 0) */\nstatic inline unsigned long ALIGN_POWER2(unsigned long u) {\n        /* clz(0) is undefined */\n        if (u == 1)\n                return 1;\n\n        /* left-shift overflow is undefined */\n        if (__builtin_clzl(u - 1UL) < 1)\n                return 0;\n\n        return 1UL << (sizeof(u) * 8 - __builtin_clzl(u - 1UL));\n}\n\n#ifndef __COVERITY__\n#  define VOID_0 ((void)0)\n#else\n#  define VOID_0 ((void*)0)\n#endif\n\n#define ELEMENTSOF(x)                                                    \\\n        __extension__ (__builtin_choose_expr(                            \\\n                !__builtin_types_compatible_p(typeof(x), typeof(&*(x))), \\\n                sizeof(x)/sizeof((x)[0]),                                \\\n                VOID_0))\n\n/*\n * STRLEN - return the length of a string literal, minus the trailing NUL byte.\n *          Contrary to strlen(), this is a constant expression.\n * @x: a string literal.\n */\n#define STRLEN(x) (sizeof(\"\"x\"\") - 1)\n\n/*\n * container_of - cast a member of a structure out to the containing structure\n * @ptr: the pointer to the member.\n * @type: the type of the container struct this is embedded in.\n * @member: the name of the member within the struct.\n */\n#define container_of(ptr, type, member) __container_of(UNIQ, (ptr), type, member)\n#define __container_of(uniq, ptr, type, member)                         \\\n        __extension__ ({                                                \\\n                const typeof( ((type*)0)->member ) *UNIQ_T(A, uniq) = (ptr); \\\n                (type*)( (char *)UNIQ_T(A, uniq) - offsetof(type,member) ); \\\n        })\n\n#undef MAX\n#define MAX(a, b) __MAX(UNIQ, (a), UNIQ, (b))\n#define __MAX(aq, a, bq, b)                             \\\n        __extension__ ({                                \\\n                const typeof(a) UNIQ_T(A, aq) = (a);    \\\n                const typeof(b) UNIQ_T(B, bq) = (b);    \\\n                UNIQ_T(A,aq) > UNIQ_T(B,bq) ? UNIQ_T(A,aq) : UNIQ_T(B,bq); \\\n        })\n\n/* evaluates to (void) if _A or _B are not constant or of different types */\n#define CONST_MAX(_A, _B) \\\n        __extension__ (__builtin_choose_expr(                           \\\n                __builtin_constant_p(_A) &&                             \\\n                __builtin_constant_p(_B) &&                             \\\n                __builtin_types_compatible_p(typeof(_A), typeof(_B)),   \\\n                ((_A) > (_B)) ? (_A) : (_B),                            \\\n                VOID_0))\n\n/* takes two types and returns the size of the larger one */\n#define MAXSIZE(A, B) (sizeof(union _packed_ { typeof(A) a; typeof(B) b; }))\n\n#define MAX3(x,y,z)                                     \\\n        __extension__ ({                                \\\n                        const typeof(x) _c = MAX(x,y);  \\\n                        MAX(_c, z);                     \\\n                })\n\n#undef MIN\n#define MIN(a, b) __MIN(UNIQ, (a), UNIQ, (b))\n#define __MIN(aq, a, bq, b)                             \\\n        __extension__ ({                                \\\n                const typeof(a) UNIQ_T(A, aq) = (a);    \\\n                const typeof(b) UNIQ_T(B, bq) = (b);    \\\n                UNIQ_T(A,aq) < UNIQ_T(B,bq) ? UNIQ_T(A,aq) : UNIQ_T(B,bq); \\\n        })\n\n#define MIN3(x,y,z)                                     \\\n        __extension__ ({                                \\\n                        const typeof(x) _c = MIN(x,y);  \\\n                        MIN(_c, z);                     \\\n                })\n\n#define LESS_BY(a, b) __LESS_BY(UNIQ, (a), UNIQ, (b))\n#define __LESS_BY(aq, a, bq, b)                         \\\n        __extension__ ({                                \\\n                const typeof(a) UNIQ_T(A, aq) = (a);    \\\n                const typeof(b) UNIQ_T(B, bq) = (b);    \\\n                UNIQ_T(A,aq) > UNIQ_T(B,bq) ? UNIQ_T(A,aq) - UNIQ_T(B,bq) : 0; \\\n        })\n\n#undef CLAMP\n#define CLAMP(x, low, high) __CLAMP(UNIQ, (x), UNIQ, (low), UNIQ, (high))\n#define __CLAMP(xq, x, lowq, low, highq, high)                          \\\n        __extension__ ({                                                \\\n                const typeof(x) UNIQ_T(X,xq) = (x);                     \\\n                const typeof(low) UNIQ_T(LOW,lowq) = (low);             \\\n                const typeof(high) UNIQ_T(HIGH,highq) = (high);         \\\n                        UNIQ_T(X,xq) > UNIQ_T(HIGH,highq) ?             \\\n                                UNIQ_T(HIGH,highq) :                    \\\n                                UNIQ_T(X,xq) < UNIQ_T(LOW,lowq) ?       \\\n                                        UNIQ_T(LOW,lowq) :              \\\n                                        UNIQ_T(X,xq);                   \\\n        })\n\n/* [(x + y - 1) / y] suffers from an integer overflow, even though the\n * computation should be possible in the given type. Therefore, we use\n * [x / y + !!(x % y)]. Note that on \"Real CPUs\" a division returns both the\n * quotient and the remainder, so both should be equally fast. */\n#define DIV_ROUND_UP(_x, _y)                                            \\\n        __extension__ ({                                                \\\n                const typeof(_x) __x = (_x);                            \\\n                const typeof(_y) __y = (_y);                            \\\n                (__x / __y + !!(__x % __y));                            \\\n        })\n\n#define assert_message_se(expr, message)                                \\\n        do {                                                            \\\n                if (_unlikely_(!(expr)))                                \\\n                        log_assert_failed(message, __FILE__, __LINE__, __PRETTY_FUNCTION__); \\\n        } while (false)\n\n#define assert_se(expr) assert_message_se(expr, #expr)\n\n/* We override the glibc assert() here. */\n#undef assert\n#ifdef NDEBUG\n#define assert(expr) do {} while (false)\n#else\n#define assert(expr) assert_message_se(expr, #expr)\n#endif\n\n#define assert_not_reached(t)                                           \\\n        do {                                                            \\\n                log_assert_failed_unreachable(t, __FILE__, __LINE__, __PRETTY_FUNCTION__); \\\n        } while (false)\n\n#if defined(static_assert)\n/* static_assert() is sometimes defined in a way that trips up\n * -Wdeclaration-after-statement, hence let's temporarily turn off\n * this warning around it. */\n#define assert_cc(expr)                                                 \\\n        DISABLE_WARNING_DECLARATION_AFTER_STATEMENT;                    \\\n        static_assert(expr, #expr);                                     \\\n        REENABLE_WARNING\n#else\n#define assert_cc(expr)                                                 \\\n        DISABLE_WARNING_DECLARATION_AFTER_STATEMENT;                    \\\n        struct CONCATENATE(_assert_struct_, __COUNTER__) {              \\\n                char x[(expr) ? 0 : -1];                                \\\n        };                                                              \\\n        REENABLE_WARNING\n#endif\n\n#define assert_log(expr, message) ((_likely_(expr))                     \\\n        ? (true)                                                        \\\n        : (log_assert_failed_return(message, __FILE__, __LINE__, __PRETTY_FUNCTION__), false))\n\n#define assert_return(expr, r)                                          \\\n        do {                                                            \\\n                if (!assert_log(expr, #expr))                           \\\n                        return (r);                                     \\\n        } while (false)\n\n#define assert_return_errno(expr, r, err)                               \\\n        do {                                                            \\\n                if (!assert_log(expr, #expr)) {                         \\\n                        errno = err;                                    \\\n                        return (r);                                     \\\n                }                                                       \\\n        } while (false)\n\n#define PTR_TO_INT(p) ((int) ((intptr_t) (p)))\n#define INT_TO_PTR(u) ((void *) ((intptr_t) (u)))\n#define PTR_TO_UINT(p) ((unsigned int) ((uintptr_t) (p)))\n#define UINT_TO_PTR(u) ((void *) ((uintptr_t) (u)))\n\n#define PTR_TO_LONG(p) ((long) ((intptr_t) (p)))\n#define LONG_TO_PTR(u) ((void *) ((intptr_t) (u)))\n#define PTR_TO_ULONG(p) ((unsigned long) ((uintptr_t) (p)))\n#define ULONG_TO_PTR(u) ((void *) ((uintptr_t) (u)))\n\n#define PTR_TO_INT32(p) ((int32_t) ((intptr_t) (p)))\n#define INT32_TO_PTR(u) ((void *) ((intptr_t) (u)))\n#define PTR_TO_UINT32(p) ((uint32_t) ((uintptr_t) (p)))\n#define UINT32_TO_PTR(u) ((void *) ((uintptr_t) (u)))\n\n#define PTR_TO_INT64(p) ((int64_t) ((intptr_t) (p)))\n#define INT64_TO_PTR(u) ((void *) ((intptr_t) (u)))\n#define PTR_TO_UINT64(p) ((uint64_t) ((uintptr_t) (p)))\n#define UINT64_TO_PTR(u) ((void *) ((uintptr_t) (u)))\n\n#define PTR_TO_SIZE(p) ((size_t) ((uintptr_t) (p)))\n#define SIZE_TO_PTR(u) ((void *) ((uintptr_t) (u)))\n\n#define CHAR_TO_STR(x) ((char[2]) { x, 0 })\n\n#define char_array_0(x) x[sizeof(x)-1] = 0;\n\n/* Returns the number of chars needed to format variables of the\n * specified type as a decimal string. Adds in extra space for a\n * negative '-' prefix (hence works correctly on signed\n * types). Includes space for the trailing NUL. */\n#define DECIMAL_STR_MAX(type)                                           \\\n        (2+(sizeof(type) <= 1 ? 3 :                                     \\\n            sizeof(type) <= 2 ? 5 :                                     \\\n            sizeof(type) <= 4 ? 10 :                                    \\\n            sizeof(type) <= 8 ? 20 : sizeof(int[-2*(sizeof(type) > 8)])))\n\n#define DECIMAL_STR_WIDTH(x)                            \\\n        ({                                              \\\n                typeof(x) _x_ = (x);                    \\\n                unsigned ans = 1;                       \\\n                while ((_x_ /= 10) != 0)                \\\n                        ans++;                          \\\n                ans;                                    \\\n        })\n\n#define SET_FLAG(v, flag, b) \\\n        (v) = (b) ? ((v) | (flag)) : ((v) & ~(flag))\n#define FLAGS_SET(v, flags) \\\n        (((v) & (flags)) == (flags))\n\n#define CASE_F(X) case X:\n#define CASE_F_1(CASE, X) CASE_F(X)\n#define CASE_F_2(CASE, X, ...)  CASE(X) CASE_F_1(CASE, __VA_ARGS__)\n#define CASE_F_3(CASE, X, ...)  CASE(X) CASE_F_2(CASE, __VA_ARGS__)\n#define CASE_F_4(CASE, X, ...)  CASE(X) CASE_F_3(CASE, __VA_ARGS__)\n#define CASE_F_5(CASE, X, ...)  CASE(X) CASE_F_4(CASE, __VA_ARGS__)\n#define CASE_F_6(CASE, X, ...)  CASE(X) CASE_F_5(CASE, __VA_ARGS__)\n#define CASE_F_7(CASE, X, ...)  CASE(X) CASE_F_6(CASE, __VA_ARGS__)\n#define CASE_F_8(CASE, X, ...)  CASE(X) CASE_F_7(CASE, __VA_ARGS__)\n#define CASE_F_9(CASE, X, ...)  CASE(X) CASE_F_8(CASE, __VA_ARGS__)\n#define CASE_F_10(CASE, X, ...) CASE(X) CASE_F_9(CASE, __VA_ARGS__)\n#define CASE_F_11(CASE, X, ...) CASE(X) CASE_F_10(CASE, __VA_ARGS__)\n#define CASE_F_12(CASE, X, ...) CASE(X) CASE_F_11(CASE, __VA_ARGS__)\n#define CASE_F_13(CASE, X, ...) CASE(X) CASE_F_12(CASE, __VA_ARGS__)\n#define CASE_F_14(CASE, X, ...) CASE(X) CASE_F_13(CASE, __VA_ARGS__)\n#define CASE_F_15(CASE, X, ...) CASE(X) CASE_F_14(CASE, __VA_ARGS__)\n#define CASE_F_16(CASE, X, ...) CASE(X) CASE_F_15(CASE, __VA_ARGS__)\n#define CASE_F_17(CASE, X, ...) CASE(X) CASE_F_16(CASE, __VA_ARGS__)\n#define CASE_F_18(CASE, X, ...) CASE(X) CASE_F_17(CASE, __VA_ARGS__)\n#define CASE_F_19(CASE, X, ...) CASE(X) CASE_F_18(CASE, __VA_ARGS__)\n#define CASE_F_20(CASE, X, ...) CASE(X) CASE_F_19(CASE, __VA_ARGS__)\n\n#define GET_CASE_F(_1,_2,_3,_4,_5,_6,_7,_8,_9,_10,_11,_12,_13,_14,_15,_16,_17,_18,_19,_20,NAME,...) NAME\n#define FOR_EACH_MAKE_CASE(...) \\\n        GET_CASE_F(__VA_ARGS__,CASE_F_20,CASE_F_19,CASE_F_18,CASE_F_17,CASE_F_16,CASE_F_15,CASE_F_14,CASE_F_13,CASE_F_12,CASE_F_11, \\\n                               CASE_F_10,CASE_F_9,CASE_F_8,CASE_F_7,CASE_F_6,CASE_F_5,CASE_F_4,CASE_F_3,CASE_F_2,CASE_F_1) \\\n                   (CASE_F,__VA_ARGS__)\n\n#define IN_SET(x, ...)                          \\\n        ({                                      \\\n                bool _found = false;            \\\n                /* If the build breaks in the line below, you need to extend the case macros */ \\\n                static _unused_ char _static_assert__macros_need_to_be_extended[20 - sizeof((int[]){__VA_ARGS__})/sizeof(int)]; \\\n                switch(x) {                     \\\n                FOR_EACH_MAKE_CASE(__VA_ARGS__) \\\n                        _found = true;          \\\n                        break;                  \\\n                default:                        \\\n                        break;                  \\\n                }                               \\\n                _found;                         \\\n        })\n\n#define SWAP_TWO(x, y) do {                        \\\n                typeof(x) _t = (x);                \\\n                (x) = (y);                         \\\n                (y) = (_t);                        \\\n        } while (false)\n\n/* Define C11 thread_local attribute even on older gcc compiler\n * version */\n#ifndef thread_local\n/*\n * Don't break on glibc < 2.16 that doesn't define __STDC_NO_THREADS__\n * see http://gcc.gnu.org/bugzilla/show_bug.cgi?id=53769\n */\n#if __STDC_VERSION__ >= 201112L && !(defined(__STDC_NO_THREADS__) || (defined(__GNU_LIBRARY__) && __GLIBC__ == 2 && __GLIBC_MINOR__ < 16))\n#define thread_local _Thread_local\n#else\n#define thread_local __thread\n#endif\n#endif\n\n#define DEFINE_TRIVIAL_CLEANUP_FUNC(type, func)                 \\\n        static inline void func##p(type *p) {                   \\\n                if (*p)                                         \\\n                        func(*p);                               \\\n        }\n\n#include \"log.h\"\n"}, "14": {"id": 14, "path": "/media/lavo07/lavo07/systemd-239/src/systemctl/systemctl.c", "content": "/* SPDX-License-Identifier: LGPL-2.1+ */\n/***\n  Copyright \u00a9 2013 Marc-Antoine Perennou\n***/\n\n#include <errno.h>\n#include <fcntl.h>\n#include <getopt.h>\n#include <locale.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/prctl.h>\n#include <sys/reboot.h>\n#include <sys/socket.h>\n#include <unistd.h>\n\n#include \"sd-bus.h\"\n#include \"sd-daemon.h\"\n#include \"sd-login.h\"\n\n#include \"alloc-util.h\"\n#include \"bootspec.h\"\n#include \"bus-common-errors.h\"\n#include \"bus-error.h\"\n#include \"bus-message.h\"\n#include \"bus-unit-util.h\"\n#include \"bus-util.h\"\n#include \"cgroup-show.h\"\n#include \"cgroup-util.h\"\n#include \"copy.h\"\n#include \"dropin.h\"\n#include \"efivars.h\"\n#include \"env-util.h\"\n#include \"escape.h\"\n#include \"exit-status.h\"\n#include \"fd-util.h\"\n#include \"fileio.h\"\n#include \"format-util.h\"\n#include \"fs-util.h\"\n#include \"glob-util.h\"\n#include \"hexdecoct.h\"\n#include \"hostname-util.h\"\n#include \"initreq.h\"\n#include \"install.h\"\n#include \"io-util.h\"\n#include \"list.h\"\n#include \"locale-util.h\"\n#include \"log.h\"\n#include \"logs-show.h\"\n#include \"macro.h\"\n#include \"mkdir.h\"\n#include \"pager.h\"\n#include \"parse-util.h\"\n#include \"path-lookup.h\"\n#include \"path-util.h\"\n#include \"process-util.h\"\n#include \"reboot-util.h\"\n#include \"rlimit-util.h\"\n#include \"set.h\"\n#include \"sigbus.h\"\n#include \"signal-util.h\"\n#include \"socket-util.h\"\n#include \"spawn-ask-password-agent.h\"\n#include \"spawn-polkit-agent.h\"\n#include \"special.h\"\n#include \"stat-util.h\"\n#include \"string-table.h\"\n#include \"strv.h\"\n#include \"terminal-util.h\"\n#include \"unit-def.h\"\n#include \"unit-name.h\"\n#include \"user-util.h\"\n#include \"util.h\"\n#include \"utmp-wtmp.h\"\n#include \"verbs.h\"\n#include \"virt.h\"\n\n/* The init script exit status codes\n   0       program is running or service is OK\n   1       program is dead and /var/run pid file exists\n   2       program is dead and /var/lock lock file exists\n   3       program is not running\n   4       program or service status is unknown\n   5-99    reserved for future LSB use\n   100-149 reserved for distribution use\n   150-199 reserved for application use\n   200-254 reserved\n*/\nenum {\n        EXIT_PROGRAM_RUNNING_OR_SERVICE_OK        = 0,\n        EXIT_PROGRAM_DEAD_AND_PID_EXISTS          = 1,\n        EXIT_PROGRAM_DEAD_AND_LOCK_FILE_EXISTS    = 2,\n        EXIT_PROGRAM_NOT_RUNNING                  = 3,\n        EXIT_PROGRAM_OR_SERVICES_STATUS_UNKNOWN   = 4,\n};\n\nstatic char **arg_types = NULL;\nstatic char **arg_states = NULL;\nstatic char **arg_properties = NULL;\nstatic bool arg_all = false;\nstatic enum dependency {\n        DEPENDENCY_FORWARD,\n        DEPENDENCY_REVERSE,\n        DEPENDENCY_AFTER,\n        DEPENDENCY_BEFORE,\n        _DEPENDENCY_MAX\n} arg_dependency = DEPENDENCY_FORWARD;\nstatic const char *arg_job_mode = \"replace\";\nstatic UnitFileScope arg_scope = UNIT_FILE_SYSTEM;\nstatic bool arg_wait = false;\nstatic bool arg_no_block = false;\nstatic bool arg_no_legend = false;\nstatic bool arg_no_pager = false;\nstatic bool arg_no_wtmp = false;\nstatic bool arg_no_sync = false;\nstatic bool arg_no_wall = false;\nstatic bool arg_no_reload = false;\nstatic bool arg_value = false;\nstatic bool arg_show_types = false;\nstatic bool arg_ignore_inhibitors = false;\nstatic bool arg_dry_run = false;\nstatic bool arg_quiet = false;\nstatic bool arg_full = false;\nstatic bool arg_recursive = false;\nstatic int arg_force = 0;\nstatic bool arg_ask_password = false;\nstatic bool arg_runtime = false;\nstatic UnitFilePresetMode arg_preset_mode = UNIT_FILE_PRESET_FULL;\nstatic char **arg_wall = NULL;\nstatic const char *arg_kill_who = NULL;\nstatic int arg_signal = SIGTERM;\nstatic char *arg_root = NULL;\nstatic usec_t arg_when = 0;\nstatic char *arg_esp_path = NULL;\nstatic char *argv_cmdline = NULL;\nstatic enum action {\n        ACTION_SYSTEMCTL,\n        ACTION_HALT,\n        ACTION_POWEROFF,\n        ACTION_REBOOT,\n        ACTION_KEXEC,\n        ACTION_EXIT,\n        ACTION_SUSPEND,\n        ACTION_HIBERNATE,\n        ACTION_HYBRID_SLEEP,\n        ACTION_SUSPEND_THEN_HIBERNATE,\n        ACTION_RUNLEVEL2,\n        ACTION_RUNLEVEL3,\n        ACTION_RUNLEVEL4,\n        ACTION_RUNLEVEL5,\n        ACTION_RESCUE,\n        ACTION_EMERGENCY,\n        ACTION_DEFAULT,\n        ACTION_RELOAD,\n        ACTION_REEXEC,\n        ACTION_RUNLEVEL,\n        ACTION_CANCEL_SHUTDOWN,\n        _ACTION_MAX,\n        _ACTION_INVALID = -1\n} arg_action = ACTION_SYSTEMCTL;\nstatic BusTransport arg_transport = BUS_TRANSPORT_LOCAL;\nstatic const char *arg_host = NULL;\nstatic unsigned arg_lines = 10;\nstatic OutputMode arg_output = OUTPUT_SHORT;\nstatic bool arg_plain = false;\nstatic bool arg_firmware_setup = false;\nstatic bool arg_now = false;\nstatic bool arg_jobs_before = false;\nstatic bool arg_jobs_after = false;\n\nstatic int daemon_reload(int argc, char *argv[], void* userdata);\nstatic int trivial_method(int argc, char *argv[], void *userdata);\nstatic int halt_now(enum action a);\nstatic int get_state_one_unit(sd_bus *bus, const char *name, UnitActiveState *active_state);\n\nstatic bool original_stdout_is_tty;\n\ntypedef enum BusFocus {\n        BUS_FULL,      /* The full bus indicated via --system or --user */\n        BUS_MANAGER,   /* The manager itself, possibly directly, possibly via the bus */\n        _BUS_FOCUS_MAX\n} BusFocus;\n\nstatic sd_bus *busses[_BUS_FOCUS_MAX] = {};\n\nstatic UnitFileFlags args_to_flags(void) {\n        return (arg_runtime ? UNIT_FILE_RUNTIME : 0) |\n               (arg_force   ? UNIT_FILE_FORCE   : 0);\n}\n\nstatic int acquire_bus(BusFocus focus, sd_bus **ret) {\n        int r;\n\n        assert(focus < _BUS_FOCUS_MAX);\n        assert(ret);\n\n        /* We only go directly to the manager, if we are using a local transport */\n        if (arg_transport != BUS_TRANSPORT_LOCAL)\n                focus = BUS_FULL;\n\n        if (getenv_bool(\"SYSTEMCTL_FORCE_BUS\") > 0)\n                focus = BUS_FULL;\n\n        if (!busses[focus]) {\n                bool user;\n\n                user = arg_scope != UNIT_FILE_SYSTEM;\n\n                if (focus == BUS_MANAGER)\n                        r = bus_connect_transport_systemd(arg_transport, arg_host, user, &busses[focus]);\n                else\n                        r = bus_connect_transport(arg_transport, arg_host, user, &busses[focus]);\n                if (r < 0)\n                        return log_error_errno(r, \"Failed to connect to bus: %m\");\n\n                (void) sd_bus_set_allow_interactive_authorization(busses[focus], arg_ask_password);\n        }\n\n        *ret = busses[focus];\n        return 0;\n}\n\nstatic void release_busses(void) {\n        BusFocus w;\n\n        for (w = 0; w < _BUS_FOCUS_MAX; w++)\n                busses[w] = sd_bus_flush_close_unref(busses[w]);\n}\n\nstatic void ask_password_agent_open_if_enabled(void) {\n        /* Open the password agent as a child process if necessary */\n\n        if (arg_dry_run)\n                return;\n\n        if (!arg_ask_password)\n                return;\n\n        if (arg_scope != UNIT_FILE_SYSTEM)\n                return;\n\n        if (arg_transport != BUS_TRANSPORT_LOCAL)\n                return;\n\n        ask_password_agent_open();\n}\n\nstatic void polkit_agent_open_maybe(void) {\n        /* Open the polkit agent as a child process if necessary */\n\n        if (arg_scope != UNIT_FILE_SYSTEM)\n                return;\n\n        polkit_agent_open_if_enabled(arg_transport, arg_ask_password);\n}\n\nstatic OutputFlags get_output_flags(void) {\n        return\n                arg_all * OUTPUT_SHOW_ALL |\n                (arg_full || !on_tty() || pager_have()) * OUTPUT_FULL_WIDTH |\n                colors_enabled() * OUTPUT_COLOR |\n                !arg_quiet * OUTPUT_WARN_CUTOFF;\n}\n\nstatic int translate_bus_error_to_exit_status(int r, const sd_bus_error *error) {\n        assert(error);\n\n        if (!sd_bus_error_is_set(error))\n                return r;\n\n        if (sd_bus_error_has_name(error, SD_BUS_ERROR_ACCESS_DENIED) ||\n            sd_bus_error_has_name(error, BUS_ERROR_ONLY_BY_DEPENDENCY) ||\n            sd_bus_error_has_name(error, BUS_ERROR_NO_ISOLATION) ||\n            sd_bus_error_has_name(error, BUS_ERROR_TRANSACTION_IS_DESTRUCTIVE))\n                return EXIT_NOPERMISSION;\n\n        if (sd_bus_error_has_name(error, BUS_ERROR_NO_SUCH_UNIT))\n                return EXIT_NOTINSTALLED;\n\n        if (sd_bus_error_has_name(error, BUS_ERROR_JOB_TYPE_NOT_APPLICABLE) ||\n            sd_bus_error_has_name(error, SD_BUS_ERROR_NOT_SUPPORTED))\n                return EXIT_NOTIMPLEMENTED;\n\n        if (sd_bus_error_has_name(error, BUS_ERROR_LOAD_FAILED))\n                return EXIT_NOTCONFIGURED;\n\n        if (r != 0)\n                return r;\n\n        return EXIT_FAILURE;\n}\n\nstatic bool install_client_side(void) {\n        /* Decides when to execute enable/disable/... operations\n         * client-side rather than server-side. */\n\n        if (running_in_chroot_or_offline())\n                return true;\n\n        if (sd_booted() <= 0)\n                return true;\n\n        if (!isempty(arg_root))\n                return true;\n\n        if (arg_scope == UNIT_FILE_GLOBAL)\n                return true;\n\n        /* Unsupported environment variable, mostly for debugging purposes */\n        if (getenv_bool(\"SYSTEMCTL_INSTALL_CLIENT_SIDE\") > 0)\n                return true;\n\n        return false;\n}\n\nstatic int compare_unit_info(const void *a, const void *b) {\n        const UnitInfo *u = a, *v = b;\n        const char *d1, *d2;\n        int r;\n\n        /* First, order by machine */\n        if (!u->machine && v->machine)\n                return -1;\n        if (u->machine && !v->machine)\n                return 1;\n        if (u->machine && v->machine) {\n                r = strcasecmp(u->machine, v->machine);\n                if (r != 0)\n                        return r;\n        }\n\n        /* Second, order by unit type */\n        d1 = strrchr(u->id, '.');\n        d2 = strrchr(v->id, '.');\n        if (d1 && d2) {\n                r = strcasecmp(d1, d2);\n                if (r != 0)\n                        return r;\n        }\n\n        /* Third, order by name */\n        return strcasecmp(u->id, v->id);\n}\n\nstatic const char* unit_type_suffix(const char *name) {\n        const char *dot;\n\n        dot = strrchr(name, '.');\n        if (!dot)\n                return \"\";\n\n        return dot + 1;\n}\n\nstatic bool output_show_unit(const UnitInfo *u, char **patterns) {\n        assert(u);\n\n        if (!strv_fnmatch_or_empty(patterns, u->id, FNM_NOESCAPE))\n                return false;\n\n        if (arg_types && !strv_find(arg_types, unit_type_suffix(u->id)))\n                return false;\n\n        if (arg_all)\n                return true;\n\n        /* Note that '--all' is not purely a state filter, but also a\n         * filter that hides units that \"follow\" other units (which is\n         * used for device units that appear under different names). */\n        if (!isempty(u->following))\n                return false;\n\n        if (!strv_isempty(arg_states))\n                return true;\n\n        /* By default show all units except the ones in inactive\n         * state and with no pending job */\n        if (u->job_id > 0)\n                return true;\n\n        if (streq(u->active_state, \"inactive\"))\n                return false;\n\n        return true;\n}\n\nstatic int output_units_list(const UnitInfo *unit_infos, unsigned c) {\n        unsigned circle_len = 0, id_len, max_id_len, load_len, active_len, sub_len, job_len, desc_len, max_desc_len;\n        const UnitInfo *u;\n        unsigned n_shown = 0;\n        int job_count = 0;\n\n        max_id_len = STRLEN(\"UNIT\");\n        load_len = STRLEN(\"LOAD\");\n        active_len = STRLEN(\"ACTIVE\");\n        sub_len = STRLEN(\"SUB\");\n        job_len = STRLEN(\"JOB\");\n        max_desc_len = STRLEN(\"DESCRIPTION\");\n\n        for (u = unit_infos; u < unit_infos + c; u++) {\n                max_id_len = MAX(max_id_len, strlen(u->id) + (u->machine ? strlen(u->machine)+1 : 0));\n                load_len = MAX(load_len, strlen(u->load_state));\n                active_len = MAX(active_len, strlen(u->active_state));\n                sub_len = MAX(sub_len, strlen(u->sub_state));\n                max_desc_len = MAX(max_desc_len, strlen(u->description));\n\n                if (u->job_id != 0) {\n                        job_len = MAX(job_len, strlen(u->job_type));\n                        job_count++;\n                }\n\n                if (!arg_no_legend &&\n                    (streq(u->active_state, \"failed\") ||\n                     STR_IN_SET(u->load_state, \"error\", \"not-found\", \"bad-setting\", \"masked\")))\n                        circle_len = 2;\n        }\n\n        if (!arg_full && original_stdout_is_tty) {\n                unsigned basic_len;\n\n                id_len = MIN(max_id_len, 25u); /* as much as it needs, but at most 25 for now */\n                basic_len = circle_len + 1 + id_len + 1 + load_len + 1 + active_len + 1 + sub_len + 1;\n\n                if (job_count)\n                        basic_len += job_len + 1;\n\n                if (basic_len < (unsigned) columns()) {\n                        unsigned extra_len, incr;\n                        extra_len = columns() - basic_len;\n\n                        /* Either UNIT already got 25, or is fully satisfied.\n                         * Grant up to 25 to DESC now. */\n                        incr = MIN(extra_len, 25u);\n                        desc_len = incr;\n                        extra_len -= incr;\n\n                        /* Of the remainder give as much as the ID needs to the ID, and give the rest to the\n                         * description but not more than it needs. */\n                        if (extra_len > 0) {\n                                incr = MIN(max_id_len - id_len, extra_len);\n                                id_len += incr;\n                                desc_len += MIN(extra_len - incr, max_desc_len - desc_len);\n                        }\n                } else\n                        desc_len = 0;\n        } else {\n                id_len = max_id_len;\n                desc_len = max_desc_len;\n        }\n\n        for (u = unit_infos; u < unit_infos + c; u++) {\n                _cleanup_free_ char *e = NULL, *j = NULL;\n                const char *on_underline = \"\", *off_underline = \"\";\n                const char *on_loaded = \"\", *off_loaded = \"\";\n                const char *on_active = \"\", *off_active = \"\";\n                const char *on_circle = \"\", *off_circle = \"\";\n                const char *id;\n                bool circle = false, underline = false;\n\n                if (!n_shown && !arg_no_legend) {\n\n                        if (circle_len > 0)\n                                fputs(\"  \", stdout);\n\n                        printf(\"%s%-*s %-*s %-*s %-*s \",\n                               ansi_underline(),\n                               id_len, \"UNIT\",\n                               load_len, \"LOAD\",\n                               active_len, \"ACTIVE\",\n                               sub_len, \"SUB\");\n\n                        if (job_count)\n                                printf(\"%-*s \", job_len, \"JOB\");\n\n                        printf(\"%-*.*s%s\\n\",\n                               desc_len,\n                               !arg_full && arg_no_pager ? (int) desc_len : -1,\n                               \"DESCRIPTION\",\n                               ansi_normal());\n                }\n\n                n_shown++;\n\n                if (u + 1 < unit_infos + c &&\n                    !streq(unit_type_suffix(u->id), unit_type_suffix((u + 1)->id))) {\n                        on_underline = ansi_underline();\n                        off_underline = ansi_normal();\n                        underline = true;\n                }\n\n                if (STR_IN_SET(u->load_state, \"error\", \"not-found\", \"bad-setting\", \"masked\") && !arg_plain) {\n                        on_circle = ansi_highlight_yellow();\n                        off_circle = ansi_normal();\n                        circle = true;\n                        on_loaded = underline ? ansi_highlight_red_underline() : ansi_highlight_red();\n                        off_loaded = underline ? on_underline : ansi_normal();\n                } else if (streq(u->active_state, \"failed\") && !arg_plain) {\n                        on_circle = ansi_highlight_red();\n                        off_circle = ansi_normal();\n                        circle = true;\n                        on_active = underline ? ansi_highlight_red_underline() : ansi_highlight_red();\n                        off_active = underline ? on_underline : ansi_normal();\n                }\n\n                if (u->machine) {\n                        j = strjoin(u->machine, \":\", u->id);\n                        if (!j)\n                                return log_oom();\n\n                        id = j;\n                } else\n                        id = u->id;\n\n                if (arg_full) {\n                        e = ellipsize(id, id_len, 33);\n                        if (!e)\n                                return log_oom();\n\n                        id = e;\n                }\n\n                if (circle_len > 0)\n                        printf(\"%s%s%s \", on_circle, circle ? special_glyph(BLACK_CIRCLE) : \" \", off_circle);\n\n                printf(\"%s%s%-*s%s %s%-*s%s %s%-*s %-*s%s %-*s\",\n                       on_underline,\n                       on_active, id_len, id, off_active,\n                       on_loaded, load_len, u->load_state, off_loaded,\n                       on_active, active_len, u->active_state,\n                       sub_len, u->sub_state, off_active,\n                       job_count ? job_len + 1 : 0, u->job_id ? u->job_type : \"\");\n\n                printf(\"%-*.*s%s\\n\",\n                       desc_len,\n                       !arg_full && arg_no_pager ? (int) desc_len : -1,\n                       u->description,\n                       off_underline);\n        }\n\n        if (!arg_no_legend) {\n                const char *on, *off;\n\n                if (n_shown) {\n                        puts(\"\\n\"\n                             \"LOAD   = Reflects whether the unit definition was properly loaded.\\n\"\n                             \"ACTIVE = The high-level unit activation state, i.e. generalization of SUB.\\n\"\n                             \"SUB    = The low-level unit activation state, values depend on unit type.\");\n                        puts(job_count ? \"JOB    = Pending job for the unit.\\n\" : \"\");\n                        on = ansi_highlight();\n                        off = ansi_normal();\n                } else {\n                        on = ansi_highlight_red();\n                        off = ansi_normal();\n                }\n\n                if (arg_all)\n                        printf(\"%s%u loaded units listed.%s\\n\"\n                               \"To show all installed unit files use 'systemctl list-unit-files'.\\n\",\n                               on, n_shown, off);\n                else\n                        printf(\"%s%u loaded units listed.%s Pass --all to see loaded but inactive units, too.\\n\"\n                               \"To show all installed unit files use 'systemctl list-unit-files'.\\n\",\n                               on, n_shown, off);\n        }\n\n        return 0;\n}\n\nstatic int get_unit_list(\n                sd_bus *bus,\n                const char *machine,\n                char **patterns,\n                UnitInfo **unit_infos,\n                int c,\n                sd_bus_message **_reply) {\n\n        _cleanup_(sd_bus_message_unrefp) sd_bus_message *m = NULL;\n        _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n        _cleanup_(sd_bus_message_unrefp) sd_bus_message *reply = NULL;\n        size_t size = c;\n        int r;\n        UnitInfo u;\n        bool fallback = false;\n\n        assert(bus);\n        assert(unit_infos);\n        assert(_reply);\n\n        r = sd_bus_message_new_method_call(\n                        bus,\n                        &m,\n                        \"org.freedesktop.systemd1\",\n                        \"/org/freedesktop/systemd1\",\n                        \"org.freedesktop.systemd1.Manager\",\n                        \"ListUnitsByPatterns\");\n        if (r < 0)\n                return bus_log_create_error(r);\n\n        r = sd_bus_message_append_strv(m, arg_states);\n        if (r < 0)\n                return bus_log_create_error(r);\n\n        r = sd_bus_message_append_strv(m, patterns);\n        if (r < 0)\n                return bus_log_create_error(r);\n\n        r = sd_bus_call(bus, m, 0, &error, &reply);\n        if (r < 0 && (sd_bus_error_has_name(&error, SD_BUS_ERROR_UNKNOWN_METHOD) ||\n                      sd_bus_error_has_name(&error, SD_BUS_ERROR_ACCESS_DENIED))) {\n                /* Fallback to legacy ListUnitsFiltered method */\n                fallback = true;\n                log_debug_errno(r, \"Failed to list units: %s Falling back to ListUnitsFiltered method.\", bus_error_message(&error, r));\n                m = sd_bus_message_unref(m);\n                sd_bus_error_free(&error);\n\n                r = sd_bus_message_new_method_call(\n                                bus,\n                                &m,\n                                \"org.freedesktop.systemd1\",\n                                \"/org/freedesktop/systemd1\",\n                                \"org.freedesktop.systemd1.Manager\",\n                                \"ListUnitsFiltered\");\n                if (r < 0)\n                        return bus_log_create_error(r);\n\n                r = sd_bus_message_append_strv(m, arg_states);\n                if (r < 0)\n                        return bus_log_create_error(r);\n\n                r = sd_bus_call(bus, m, 0, &error, &reply);\n        }\n        if (r < 0)\n                return log_error_errno(r, \"Failed to list units: %s\", bus_error_message(&error, r));\n\n        r = sd_bus_message_enter_container(reply, SD_BUS_TYPE_ARRAY, \"(ssssssouso)\");\n        if (r < 0)\n                return bus_log_parse_error(r);\n\n        while ((r = bus_parse_unit_info(reply, &u)) > 0) {\n                u.machine = machine;\n\n                if (!output_show_unit(&u, fallback ? patterns : NULL))\n                        continue;\n\n                if (!GREEDY_REALLOC(*unit_infos, size, c+1))\n                        return log_oom();\n\n                (*unit_infos)[c++] = u;\n        }\n        if (r < 0)\n                return bus_log_parse_error(r);\n\n        r = sd_bus_message_exit_container(reply);\n        if (r < 0)\n                return bus_log_parse_error(r);\n\n        *_reply = TAKE_PTR(reply);\n\n        return c;\n}\n\nstatic void message_set_freep(Set **set) {\n        set_free_with_destructor(*set, sd_bus_message_unref);\n}\n\nstatic int get_unit_list_recursive(\n                sd_bus *bus,\n                char **patterns,\n                UnitInfo **_unit_infos,\n                Set **_replies,\n                char ***_machines) {\n\n        _cleanup_free_ UnitInfo *unit_infos = NULL;\n        _cleanup_(message_set_freep) Set *replies;\n        sd_bus_message *reply;\n        int c, r;\n\n        assert(bus);\n        assert(_replies);\n        assert(_unit_infos);\n        assert(_machines);\n\n        replies = set_new(NULL);\n        if (!replies)\n                return log_oom();\n\n        c = get_unit_list(bus, NULL, patterns, &unit_infos, 0, &reply);\n        if (c < 0)\n                return c;\n\n        r = set_put(replies, reply);\n        if (r < 0) {\n                sd_bus_message_unref(reply);\n                return log_oom();\n        }\n\n        if (arg_recursive) {\n                _cleanup_strv_free_ char **machines = NULL;\n                char **i;\n\n                r = sd_get_machine_names(&machines);\n                if (r < 0)\n                        return log_error_errno(r, \"Failed to get machine names: %m\");\n\n                STRV_FOREACH(i, machines) {\n                        _cleanup_(sd_bus_flush_close_unrefp) sd_bus *container = NULL;\n                        int k;\n\n                        r = sd_bus_open_system_machine(&container, *i);\n                        if (r < 0) {\n                                log_warning_errno(r, \"Failed to connect to container %s, ignoring: %m\", *i);\n                                continue;\n                        }\n\n                        k = get_unit_list(container, *i, patterns, &unit_infos, c, &reply);\n                        if (k < 0)\n                                return k;\n\n                        c = k;\n\n                        r = set_put(replies, reply);\n                        if (r < 0) {\n                                sd_bus_message_unref(reply);\n                                return log_oom();\n                        }\n                }\n\n                *_machines = TAKE_PTR(machines);\n        } else\n                *_machines = NULL;\n\n        *_unit_infos = TAKE_PTR(unit_infos);\n\n        *_replies = TAKE_PTR(replies);\n\n        return c;\n}\n\nstatic int list_units(int argc, char *argv[], void *userdata) {\n        _cleanup_free_ UnitInfo *unit_infos = NULL;\n        _cleanup_(message_set_freep) Set *replies = NULL;\n        _cleanup_strv_free_ char **machines = NULL;\n        sd_bus *bus;\n        int r;\n\n        r = acquire_bus(BUS_MANAGER, &bus);\n        if (r < 0)\n                return r;\n\n        (void) pager_open(arg_no_pager, false);\n\n        r = get_unit_list_recursive(bus, strv_skip(argv, 1), &unit_infos, &replies, &machines);\n        if (r < 0)\n                return r;\n\n        qsort_safe(unit_infos, r, sizeof(UnitInfo), compare_unit_info);\n        return output_units_list(unit_infos, r);\n}\n\nstatic int get_triggered_units(\n                sd_bus *bus,\n                const char* path,\n                char*** ret) {\n\n        _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n        int r;\n\n        assert(bus);\n        assert(path);\n        assert(ret);\n\n        r = sd_bus_get_property_strv(\n                        bus,\n                        \"org.freedesktop.systemd1\",\n                        path,\n                        \"org.freedesktop.systemd1.Unit\",\n                        \"Triggers\",\n                        &error,\n                        ret);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to determine triggers: %s\", bus_error_message(&error, r));\n\n        return 0;\n}\n\nstatic int get_listening(\n                sd_bus *bus,\n                const char* unit_path,\n                char*** listening) {\n\n        _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n        _cleanup_(sd_bus_message_unrefp) sd_bus_message *reply = NULL;\n        const char *type, *path;\n        int r, n = 0;\n\n        r = sd_bus_get_property(\n                        bus,\n                        \"org.freedesktop.systemd1\",\n                        unit_path,\n                        \"org.freedesktop.systemd1.Socket\",\n                        \"Listen\",\n                        &error,\n                        &reply,\n                        \"a(ss)\");\n        if (r < 0)\n                return log_error_errno(r, \"Failed to get list of listening sockets: %s\", bus_error_message(&error, r));\n\n        r = sd_bus_message_enter_container(reply, SD_BUS_TYPE_ARRAY, \"(ss)\");\n        if (r < 0)\n                return bus_log_parse_error(r);\n\n        while ((r = sd_bus_message_read(reply, \"(ss)\", &type, &path)) > 0) {\n\n                r = strv_extend(listening, type);\n                if (r < 0)\n                        return log_oom();\n\n                r = strv_extend(listening, path);\n                if (r < 0)\n                        return log_oom();\n\n                n++;\n        }\n        if (r < 0)\n                return bus_log_parse_error(r);\n\n        r = sd_bus_message_exit_container(reply);\n        if (r < 0)\n                return bus_log_parse_error(r);\n\n        return n;\n}\n\nstruct socket_info {\n        const char *machine;\n        const char* id;\n\n        char* type;\n        char* path;\n\n        /* Note: triggered is a list here, although it almost certainly\n         * will always be one unit. Nevertheless, dbus API allows for multiple\n         * values, so let's follow that. */\n        char** triggered;\n\n        /* The strv above is shared. free is set only in the first one. */\n        bool own_triggered;\n};\n\nstatic int socket_info_compare(const struct socket_info *a, const struct socket_info *b) {\n        int o;\n\n        assert(a);\n        assert(b);\n\n        if (!a->machine && b->machine)\n                return -1;\n        if (a->machine && !b->machine)\n                return 1;\n        if (a->machine && b->machine) {\n                o = strcasecmp(a->machine, b->machine);\n                if (o != 0)\n                        return o;\n        }\n\n        o = strcmp(a->path, b->path);\n        if (o == 0)\n                o = strcmp(a->type, b->type);\n\n        return o;\n}\n\nstatic int output_sockets_list(struct socket_info *socket_infos, unsigned cs) {\n        struct socket_info *s;\n        unsigned pathlen = STRLEN(\"LISTEN\"),\n                typelen = STRLEN(\"TYPE\") * arg_show_types,\n                socklen = STRLEN(\"UNIT\"),\n                servlen = STRLEN(\"ACTIVATES\");\n        const char *on, *off;\n\n        for (s = socket_infos; s < socket_infos + cs; s++) {\n                unsigned tmp = 0;\n                char **a;\n\n                socklen = MAX(socklen, strlen(s->id));\n                if (arg_show_types)\n                        typelen = MAX(typelen, strlen(s->type));\n                pathlen = MAX(pathlen, strlen(s->path) + (s->machine ? strlen(s->machine)+1 : 0));\n\n                STRV_FOREACH(a, s->triggered)\n                        tmp += strlen(*a) + 2*(a != s->triggered);\n                servlen = MAX(servlen, tmp);\n        }\n\n        if (cs) {\n                if (!arg_no_legend)\n                        printf(\"%-*s %-*.*s%-*s %s\\n\",\n                               pathlen, \"LISTEN\",\n                               typelen + arg_show_types, typelen + arg_show_types, \"TYPE \",\n                               socklen, \"UNIT\",\n                               \"ACTIVATES\");\n\n                for (s = socket_infos; s < socket_infos + cs; s++) {\n                        _cleanup_free_ char *j = NULL;\n                        const char *path;\n                        char **a;\n\n                        if (s->machine) {\n                                j = strjoin(s->machine, \":\", s->path);\n                                if (!j)\n                                        return log_oom();\n                                path = j;\n                        } else\n                                path = s->path;\n\n                        if (arg_show_types)\n                                printf(\"%-*s %-*s %-*s\",\n                                       pathlen, path, typelen, s->type, socklen, s->id);\n                        else\n                                printf(\"%-*s %-*s\",\n                                       pathlen, path, socklen, s->id);\n                        STRV_FOREACH(a, s->triggered)\n                                printf(\"%s %s\",\n                                       a == s->triggered ? \"\" : \",\", *a);\n                        printf(\"\\n\");\n                }\n\n                on = ansi_highlight();\n                off = ansi_normal();\n                if (!arg_no_legend)\n                        printf(\"\\n\");\n        } else {\n                on = ansi_highlight_red();\n                off = ansi_normal();\n        }\n\n        if (!arg_no_legend) {\n                printf(\"%s%u sockets listed.%s\\n\", on, cs, off);\n                if (!arg_all)\n                        printf(\"Pass --all to see loaded but inactive sockets, too.\\n\");\n        }\n\n        return 0;\n}\n\nstatic int list_sockets(int argc, char *argv[], void *userdata) {\n        _cleanup_(message_set_freep) Set *replies = NULL;\n        _cleanup_strv_free_ char **machines = NULL;\n        _cleanup_free_ UnitInfo *unit_infos = NULL;\n        _cleanup_free_ struct socket_info *socket_infos = NULL;\n        const UnitInfo *u;\n        struct socket_info *s;\n        unsigned cs = 0;\n        size_t size = 0;\n        int r = 0, n;\n        sd_bus *bus;\n\n        r = acquire_bus(BUS_MANAGER, &bus);\n        if (r < 0)\n                return r;\n\n        (void) pager_open(arg_no_pager, false);\n\n        n = get_unit_list_recursive(bus, strv_skip(argv, 1), &unit_infos, &replies, &machines);\n        if (n < 0)\n                return n;\n\n        for (u = unit_infos; u < unit_infos + n; u++) {\n                _cleanup_strv_free_ char **listening = NULL, **triggered = NULL;\n                int i, c;\n\n                if (!endswith(u->id, \".socket\"))\n                        continue;\n\n                r = get_triggered_units(bus, u->unit_path, &triggered);\n                if (r < 0)\n                        goto cleanup;\n\n                c = get_listening(bus, u->unit_path, &listening);\n                if (c < 0) {\n                        r = c;\n                        goto cleanup;\n                }\n\n                if (!GREEDY_REALLOC(socket_infos, size, cs + c)) {\n                        r = log_oom();\n                        goto cleanup;\n                }\n\n                for (i = 0; i < c; i++)\n                        socket_infos[cs + i] = (struct socket_info) {\n                                .machine = u->machine,\n                                .id = u->id,\n                                .type = listening[i*2],\n                                .path = listening[i*2 + 1],\n                                .triggered = triggered,\n                                .own_triggered = i==0,\n                        };\n\n                /* from this point on we will cleanup those socket_infos */\n                cs += c;\n                free(listening);\n                listening = triggered = NULL; /* avoid cleanup */\n        }\n\n        qsort_safe(socket_infos, cs, sizeof(struct socket_info),\n                   (__compar_fn_t) socket_info_compare);\n\n        output_sockets_list(socket_infos, cs);\n\n cleanup:\n        assert(cs == 0 || socket_infos);\n        for (s = socket_infos; s < socket_infos + cs; s++) {\n                free(s->type);\n                free(s->path);\n                if (s->own_triggered)\n                        strv_free(s->triggered);\n        }\n\n        return r;\n}\n\nstatic int get_next_elapse(\n                sd_bus *bus,\n                const char *path,\n                dual_timestamp *next) {\n\n        _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n        dual_timestamp t;\n        int r;\n\n        assert(bus);\n        assert(path);\n        assert(next);\n\n        r = sd_bus_get_property_trivial(\n                        bus,\n                        \"org.freedesktop.systemd1\",\n                        path,\n                        \"org.freedesktop.systemd1.Timer\",\n                        \"NextElapseUSecMonotonic\",\n                        &error,\n                        't',\n                        &t.monotonic);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to get next elapse time: %s\", bus_error_message(&error, r));\n\n        r = sd_bus_get_property_trivial(\n                        bus,\n                        \"org.freedesktop.systemd1\",\n                        path,\n                        \"org.freedesktop.systemd1.Timer\",\n                        \"NextElapseUSecRealtime\",\n                        &error,\n                        't',\n                        &t.realtime);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to get next elapse time: %s\", bus_error_message(&error, r));\n\n        *next = t;\n        return 0;\n}\n\nstatic int get_last_trigger(\n                sd_bus *bus,\n                const char *path,\n                usec_t *last) {\n\n        _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n        int r;\n\n        assert(bus);\n        assert(path);\n        assert(last);\n\n        r = sd_bus_get_property_trivial(\n                        bus,\n                        \"org.freedesktop.systemd1\",\n                        path,\n                        \"org.freedesktop.systemd1.Timer\",\n                        \"LastTriggerUSec\",\n                        &error,\n                        't',\n                        last);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to get last trigger time: %s\", bus_error_message(&error, r));\n\n        return 0;\n}\n\nstruct timer_info {\n        const char* machine;\n        const char* id;\n        usec_t next_elapse;\n        usec_t last_trigger;\n        char** triggered;\n};\n\nstatic int timer_info_compare(const struct timer_info *a, const struct timer_info *b) {\n        int o;\n\n        assert(a);\n        assert(b);\n\n        if (!a->machine && b->machine)\n                return -1;\n        if (a->machine && !b->machine)\n                return 1;\n        if (a->machine && b->machine) {\n                o = strcasecmp(a->machine, b->machine);\n                if (o != 0)\n                        return o;\n        }\n\n        if (a->next_elapse < b->next_elapse)\n                return -1;\n        if (a->next_elapse > b->next_elapse)\n                return 1;\n\n        return strcmp(a->id, b->id);\n}\n\nstatic int output_timers_list(struct timer_info *timer_infos, unsigned n) {\n        struct timer_info *t;\n        unsigned\n                nextlen = STRLEN(\"NEXT\"),\n                leftlen = STRLEN(\"LEFT\"),\n                lastlen = STRLEN(\"LAST\"),\n                passedlen = STRLEN(\"PASSED\"),\n                unitlen = STRLEN(\"UNIT\"),\n                activatelen = STRLEN(\"ACTIVATES\");\n\n        const char *on, *off;\n\n        assert(timer_infos || n == 0);\n\n        for (t = timer_infos; t < timer_infos + n; t++) {\n                unsigned ul = 0;\n                char **a;\n\n                if (t->next_elapse > 0) {\n                        char tstamp[FORMAT_TIMESTAMP_MAX] = \"\", trel[FORMAT_TIMESTAMP_RELATIVE_MAX] = \"\";\n\n                        format_timestamp(tstamp, sizeof(tstamp), t->next_elapse);\n                        nextlen = MAX(nextlen, strlen(tstamp) + 1);\n\n                        format_timestamp_relative(trel, sizeof(trel), t->next_elapse);\n                        leftlen = MAX(leftlen, strlen(trel));\n                }\n\n                if (t->last_trigger > 0) {\n                        char tstamp[FORMAT_TIMESTAMP_MAX] = \"\", trel[FORMAT_TIMESTAMP_RELATIVE_MAX] = \"\";\n\n                        format_timestamp(tstamp, sizeof(tstamp), t->last_trigger);\n                        lastlen = MAX(lastlen, strlen(tstamp) + 1);\n\n                        format_timestamp_relative(trel, sizeof(trel), t->last_trigger);\n                        passedlen = MAX(passedlen, strlen(trel));\n                }\n\n                unitlen = MAX(unitlen, strlen(t->id) + (t->machine ? strlen(t->machine)+1 : 0));\n\n                STRV_FOREACH(a, t->triggered)\n                        ul += strlen(*a) + 2*(a != t->triggered);\n\n                activatelen = MAX(activatelen, ul);\n        }\n\n        if (n > 0) {\n                if (!arg_no_legend)\n                        printf(\"%-*s %-*s %-*s %-*s %-*s %s\\n\",\n                               nextlen,   \"NEXT\",\n                               leftlen,   \"LEFT\",\n                               lastlen,   \"LAST\",\n                               passedlen, \"PASSED\",\n                               unitlen,   \"UNIT\",\n                                          \"ACTIVATES\");\n\n                for (t = timer_infos; t < timer_infos + n; t++) {\n                        _cleanup_free_ char *j = NULL;\n                        const char *unit;\n                        char tstamp1[FORMAT_TIMESTAMP_MAX] = \"n/a\", trel1[FORMAT_TIMESTAMP_RELATIVE_MAX] = \"n/a\";\n                        char tstamp2[FORMAT_TIMESTAMP_MAX] = \"n/a\", trel2[FORMAT_TIMESTAMP_RELATIVE_MAX] = \"n/a\";\n                        char **a;\n\n                        format_timestamp(tstamp1, sizeof(tstamp1), t->next_elapse);\n                        format_timestamp_relative(trel1, sizeof(trel1), t->next_elapse);\n\n                        format_timestamp(tstamp2, sizeof(tstamp2), t->last_trigger);\n                        format_timestamp_relative(trel2, sizeof(trel2), t->last_trigger);\n\n                        if (t->machine) {\n                                j = strjoin(t->machine, \":\", t->id);\n                                if (!j)\n                                        return log_oom();\n                                unit = j;\n                        } else\n                                unit = t->id;\n\n                        printf(\"%-*s %-*s %-*s %-*s %-*s\",\n                               nextlen, tstamp1, leftlen, trel1, lastlen, tstamp2, passedlen, trel2, unitlen, unit);\n\n                        STRV_FOREACH(a, t->triggered)\n                                printf(\"%s %s\",\n                                       a == t->triggered ? \"\" : \",\", *a);\n                        printf(\"\\n\");\n                }\n\n                on = ansi_highlight();\n                off = ansi_normal();\n                if (!arg_no_legend)\n                        printf(\"\\n\");\n        } else {\n                on = ansi_highlight_red();\n                off = ansi_normal();\n        }\n\n        if (!arg_no_legend) {\n                printf(\"%s%u timers listed.%s\\n\", on, n, off);\n                if (!arg_all)\n                        printf(\"Pass --all to see loaded but inactive timers, too.\\n\");\n        }\n\n        return 0;\n}\n\nstatic usec_t calc_next_elapse(dual_timestamp *nw, dual_timestamp *next) {\n        usec_t next_elapse;\n\n        assert(nw);\n        assert(next);\n\n        if (next->monotonic != USEC_INFINITY && next->monotonic > 0) {\n                usec_t converted;\n\n                if (next->monotonic > nw->monotonic)\n                        converted = nw->realtime + (next->monotonic - nw->monotonic);\n                else\n                        converted = nw->realtime - (nw->monotonic - next->monotonic);\n\n                if (next->realtime != USEC_INFINITY && next->realtime > 0)\n                        next_elapse = MIN(converted, next->realtime);\n                else\n                        next_elapse = converted;\n\n        } else\n                next_elapse = next->realtime;\n\n        return next_elapse;\n}\n\nstatic int list_timers(int argc, char *argv[], void *userdata) {\n        _cleanup_(message_set_freep) Set *replies = NULL;\n        _cleanup_strv_free_ char **machines = NULL;\n        _cleanup_free_ struct timer_info *timer_infos = NULL;\n        _cleanup_free_ UnitInfo *unit_infos = NULL;\n        struct timer_info *t;\n        const UnitInfo *u;\n        size_t size = 0;\n        int n, c = 0;\n        dual_timestamp nw;\n        sd_bus *bus;\n        int r = 0;\n\n        r = acquire_bus(BUS_MANAGER, &bus);\n        if (r < 0)\n                return r;\n\n        (void) pager_open(arg_no_pager, false);\n\n        n = get_unit_list_recursive(bus, strv_skip(argv, 1), &unit_infos, &replies, &machines);\n        if (n < 0)\n                return n;\n\n        dual_timestamp_get(&nw);\n\n        for (u = unit_infos; u < unit_infos + n; u++) {\n                _cleanup_strv_free_ char **triggered = NULL;\n                dual_timestamp next = DUAL_TIMESTAMP_NULL;\n                usec_t m, last = 0;\n\n                if (!endswith(u->id, \".timer\"))\n                        continue;\n\n                r = get_triggered_units(bus, u->unit_path, &triggered);\n                if (r < 0)\n                        goto cleanup;\n\n                r = get_next_elapse(bus, u->unit_path, &next);\n                if (r < 0)\n                        goto cleanup;\n\n                get_last_trigger(bus, u->unit_path, &last);\n\n                if (!GREEDY_REALLOC(timer_infos, size, c+1)) {\n                        r = log_oom();\n                        goto cleanup;\n                }\n\n                m = calc_next_elapse(&nw, &next);\n\n                timer_infos[c++] = (struct timer_info) {\n                        .machine = u->machine,\n                        .id = u->id,\n                        .next_elapse = m,\n                        .last_trigger = last,\n                        .triggered = TAKE_PTR(triggered),\n                };\n        }\n\n        qsort_safe(timer_infos, c, sizeof(struct timer_info),\n                   (__compar_fn_t) timer_info_compare);\n\n        output_timers_list(timer_infos, c);\n\n cleanup:\n        for (t = timer_infos; t < timer_infos + c; t++)\n                strv_free(t->triggered);\n\n        return r;\n}\n\nstatic int compare_unit_file_list(const void *a, const void *b) {\n        const char *d1, *d2;\n        const UnitFileList *u = a, *v = b;\n\n        d1 = strrchr(u->path, '.');\n        d2 = strrchr(v->path, '.');\n\n        if (d1 && d2) {\n                int r;\n\n                r = strcasecmp(d1, d2);\n                if (r != 0)\n                        return r;\n        }\n\n        return strcasecmp(basename(u->path), basename(v->path));\n}\n\nstatic bool output_show_unit_file(const UnitFileList *u, char **states, char **patterns) {\n        assert(u);\n\n        if (!strv_fnmatch_or_empty(patterns, basename(u->path), FNM_NOESCAPE))\n                return false;\n\n        if (!strv_isempty(arg_types)) {\n                const char *dot;\n\n                dot = strrchr(u->path, '.');\n                if (!dot)\n                        return false;\n\n                if (!strv_find(arg_types, dot+1))\n                        return false;\n        }\n\n        if (!strv_isempty(states) &&\n            !strv_find(states, unit_file_state_to_string(u->state)))\n                return false;\n\n        return true;\n}\n\nstatic void output_unit_file_list(const UnitFileList *units, unsigned c) {\n        unsigned max_id_len, id_cols, state_cols;\n        const UnitFileList *u;\n\n        max_id_len = STRLEN(\"UNIT FILE\");\n        state_cols = STRLEN(\"STATE\");\n\n        for (u = units; u < units + c; u++) {\n                max_id_len = MAX(max_id_len, strlen(basename(u->path)));\n                state_cols = MAX(state_cols, strlen(unit_file_state_to_string(u->state)));\n        }\n\n        if (!arg_full) {\n                unsigned basic_cols;\n\n                id_cols = MIN(max_id_len, 25u);\n                basic_cols = 1 + id_cols + state_cols;\n                if (basic_cols < (unsigned) columns())\n                        id_cols += MIN(columns() - basic_cols, max_id_len - id_cols);\n        } else\n                id_cols = max_id_len;\n\n        if (!arg_no_legend && c > 0)\n                printf(\"%s%-*s %-*s%s\\n\",\n                       ansi_underline(),\n                       id_cols, \"UNIT FILE\",\n                       state_cols, \"STATE\",\n                       ansi_normal());\n\n        for (u = units; u < units + c; u++) {\n                const char *on_underline = NULL, *on_color = NULL, *off = NULL, *id;\n                _cleanup_free_ char *e = NULL;\n                bool underline;\n\n                underline = u + 1 < units + c &&\n                        !streq(unit_type_suffix(u->path), unit_type_suffix((u + 1)->path));\n\n                if (underline)\n                        on_underline = ansi_underline();\n\n                if (IN_SET(u->state,\n                           UNIT_FILE_MASKED,\n                           UNIT_FILE_MASKED_RUNTIME,\n                           UNIT_FILE_DISABLED,\n                           UNIT_FILE_BAD))\n                        on_color = underline ? ansi_highlight_red_underline() : ansi_highlight_red();\n                else if (u->state == UNIT_FILE_ENABLED)\n                        on_color = underline ? ansi_highlight_green_underline() : ansi_highlight_green();\n\n                if (on_underline || on_color)\n                        off = ansi_normal();\n\n                id = basename(u->path);\n\n                e = arg_full ? NULL : ellipsize(id, id_cols, 33);\n\n                printf(\"%s%-*s %s%-*s%s\\n\",\n                       strempty(on_underline),\n                       id_cols, e ? e : id,\n                       strempty(on_color), state_cols, unit_file_state_to_string(u->state), strempty(off));\n        }\n\n        if (!arg_no_legend)\n                printf(\"\\n%u unit files listed.\\n\", c);\n}\n\nstatic int list_unit_files(int argc, char *argv[], void *userdata) {\n        _cleanup_(sd_bus_message_unrefp) sd_bus_message *reply = NULL;\n        _cleanup_free_ UnitFileList *units = NULL;\n        UnitFileList *unit;\n        size_t size = 0;\n        unsigned c = 0;\n        const char *state;\n        char *path;\n        int r;\n        bool fallback = false;\n\n        if (install_client_side()) {\n                Hashmap *h;\n                UnitFileList *u;\n                Iterator i;\n                unsigned n_units;\n\n                h = hashmap_new(&string_hash_ops);\n                if (!h)\n                        return log_oom();\n\n                r = unit_file_get_list(arg_scope, arg_root, h, arg_states, strv_skip(argv, 1));\n                if (r < 0) {\n                        unit_file_list_free(h);\n                        return log_error_errno(r, \"Failed to get unit file list: %m\");\n                }\n\n                n_units = hashmap_size(h);\n\n                units = new(UnitFileList, n_units ?: 1); /* avoid malloc(0) */\n                if (!units) {\n                        unit_file_list_free(h);\n                        return log_oom();\n                }\n\n                HASHMAP_FOREACH(u, h, i) {\n                        if (!output_show_unit_file(u, NULL, NULL))\n                                continue;\n\n                        units[c++] = *u;\n                        free(u);\n                }\n\n                assert(c <= n_units);\n                hashmap_free(h);\n\n                r = 0;\n        } else {\n                _cleanup_(sd_bus_message_unrefp) sd_bus_message *m = NULL;\n                _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n                sd_bus *bus;\n\n                r = acquire_bus(BUS_MANAGER, &bus);\n                if (r < 0)\n                        return r;\n\n                r = sd_bus_message_new_method_call(\n                                bus,\n                                &m,\n                                \"org.freedesktop.systemd1\",\n                                \"/org/freedesktop/systemd1\",\n                                \"org.freedesktop.systemd1.Manager\",\n                                \"ListUnitFilesByPatterns\");\n                if (r < 0)\n                        return bus_log_create_error(r);\n\n                r = sd_bus_message_append_strv(m, arg_states);\n                if (r < 0)\n                        return bus_log_create_error(r);\n\n                r = sd_bus_message_append_strv(m, strv_skip(argv, 1));\n                if (r < 0)\n                        return bus_log_create_error(r);\n\n                r = sd_bus_call(bus, m, 0, &error, &reply);\n                if (r < 0 && sd_bus_error_has_name(&error, SD_BUS_ERROR_UNKNOWN_METHOD)) {\n                        /* Fallback to legacy ListUnitFiles method */\n                        fallback = true;\n                        log_debug_errno(r, \"Failed to list unit files: %s Falling back to ListUnitsFiles method.\", bus_error_message(&error, r));\n                        m = sd_bus_message_unref(m);\n                        sd_bus_error_free(&error);\n\n                        r = sd_bus_message_new_method_call(\n                                        bus,\n                                        &m,\n                                        \"org.freedesktop.systemd1\",\n                                        \"/org/freedesktop/systemd1\",\n                                        \"org.freedesktop.systemd1.Manager\",\n                                        \"ListUnitFiles\");\n                        if (r < 0)\n                                return bus_log_create_error(r);\n\n                        r = sd_bus_call(bus, m, 0, &error, &reply);\n                }\n                if (r < 0)\n                        return log_error_errno(r, \"Failed to list unit files: %s\", bus_error_message(&error, r));\n\n                r = sd_bus_message_enter_container(reply, SD_BUS_TYPE_ARRAY, \"(ss)\");\n                if (r < 0)\n                        return bus_log_parse_error(r);\n\n                while ((r = sd_bus_message_read(reply, \"(ss)\", &path, &state)) > 0) {\n\n                        if (!GREEDY_REALLOC(units, size, c + 1))\n                                return log_oom();\n\n                        units[c] = (struct UnitFileList) {\n                                path,\n                                unit_file_state_from_string(state)\n                        };\n\n                        if (output_show_unit_file(&units[c],\n                            fallback ? arg_states : NULL,\n                            fallback ? strv_skip(argv, 1) : NULL))\n                                c++;\n\n                }\n                if (r < 0)\n                        return bus_log_parse_error(r);\n\n                r = sd_bus_message_exit_container(reply);\n                if (r < 0)\n                        return bus_log_parse_error(r);\n        }\n\n        (void) pager_open(arg_no_pager, false);\n\n        qsort_safe(units, c, sizeof(UnitFileList), compare_unit_file_list);\n        output_unit_file_list(units, c);\n\n        if (install_client_side())\n                for (unit = units; unit < units + c; unit++)\n                        free(unit->path);\n\n        return 0;\n}\n\nstatic int list_dependencies_print(const char *name, int level, unsigned int branches, bool last) {\n        _cleanup_free_ char *n = NULL;\n        size_t max_len = MAX(columns(),20u);\n        size_t len = 0;\n        int i;\n\n        if (!arg_plain) {\n\n                for (i = level - 1; i >= 0; i--) {\n                        len += 2;\n                        if (len > max_len - 3 && !arg_full) {\n                                printf(\"%s...\\n\",max_len % 2 ? \"\" : \" \");\n                                return 0;\n                        }\n                        printf(\"%s\", special_glyph(branches & (1 << i) ? TREE_VERTICAL : TREE_SPACE));\n                }\n                len += 2;\n\n                if (len > max_len - 3 && !arg_full) {\n                        printf(\"%s...\\n\",max_len % 2 ? \"\" : \" \");\n                        return 0;\n                }\n\n                printf(\"%s\", special_glyph(last ? TREE_RIGHT : TREE_BRANCH));\n        }\n\n        if (arg_full) {\n                printf(\"%s\\n\", name);\n                return 0;\n        }\n\n        n = ellipsize(name, max_len-len, 100);\n        if (!n)\n                return log_oom();\n\n        printf(\"%s\\n\", n);\n        return 0;\n}\n\nstatic int list_dependencies_get_dependencies(sd_bus *bus, const char *name, char ***deps) {\n        struct DependencyStatusInfo {\n                char **dep[5];\n        } info = {};\n\n        static const struct bus_properties_map map[_DEPENDENCY_MAX][6] = {\n                [DEPENDENCY_FORWARD] = {\n                        { \"Requires\",    \"as\", NULL, offsetof(struct DependencyStatusInfo, dep[0]) },\n                        { \"Requisite\",   \"as\", NULL, offsetof(struct DependencyStatusInfo, dep[1]) },\n                        { \"Wants\",       \"as\", NULL, offsetof(struct DependencyStatusInfo, dep[2]) },\n                        { \"ConsistsOf\",  \"as\", NULL, offsetof(struct DependencyStatusInfo, dep[3]) },\n                        { \"BindsTo\",     \"as\", NULL, offsetof(struct DependencyStatusInfo, dep[4]) },\n                        {}\n                },\n                [DEPENDENCY_REVERSE] = {\n                        { \"RequiredBy\",  \"as\", NULL, offsetof(struct DependencyStatusInfo, dep[0]) },\n                        { \"RequisiteOf\", \"as\", NULL, offsetof(struct DependencyStatusInfo, dep[1]) },\n                        { \"WantedBy\",    \"as\", NULL, offsetof(struct DependencyStatusInfo, dep[2]) },\n                        { \"PartOf\",      \"as\", NULL, offsetof(struct DependencyStatusInfo, dep[3]) },\n                        { \"BoundBy\",     \"as\", NULL, offsetof(struct DependencyStatusInfo, dep[4]) },\n                        {}\n                },\n                [DEPENDENCY_AFTER] = {\n                        { \"After\",       \"as\", NULL, offsetof(struct DependencyStatusInfo, dep[0]) },\n                        {}\n                },\n                [DEPENDENCY_BEFORE] = {\n                        { \"Before\",      \"as\", NULL, offsetof(struct DependencyStatusInfo, dep[0]) },\n                        {}\n                },\n        };\n\n        _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n        _cleanup_strv_free_ char **ret = NULL;\n        _cleanup_free_ char *path = NULL;\n        int i, r;\n\n        assert(bus);\n        assert(name);\n        assert(deps);\n\n        path = unit_dbus_path_from_name(name);\n        if (!path)\n                return log_oom();\n\n        r = bus_map_all_properties(bus,\n                                   \"org.freedesktop.systemd1\",\n                                   path,\n                                   map[arg_dependency],\n                                   BUS_MAP_STRDUP,\n                                   &error,\n                                   NULL,\n                                   &info);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to get properties of %s: %s\", name, bus_error_message(&error, r));\n\n        if (IN_SET(arg_dependency, DEPENDENCY_AFTER, DEPENDENCY_BEFORE)) {\n                *deps = info.dep[0];\n                return 0;\n        }\n\n        for (i = 0; i < 5; i++) {\n                r = strv_extend_strv(&ret, info.dep[i], true);\n                if (r < 0)\n                        return log_oom();\n                info.dep[i] = strv_free(info.dep[i]);\n        }\n\n        *deps = TAKE_PTR(ret);\n\n        return 0;\n}\n\nstatic int list_dependencies_compare(const void *_a, const void *_b) {\n        const char **a = (const char**) _a, **b = (const char**) _b;\n\n        if (unit_name_to_type(*a) == UNIT_TARGET && unit_name_to_type(*b) != UNIT_TARGET)\n                return 1;\n        if (unit_name_to_type(*a) != UNIT_TARGET && unit_name_to_type(*b) == UNIT_TARGET)\n                return -1;\n\n        return strcasecmp(*a, *b);\n}\n\nstatic int list_dependencies_one(\n                sd_bus *bus,\n                const char *name,\n                int level,\n                char ***units,\n                unsigned int branches) {\n\n        _cleanup_strv_free_ char **deps = NULL;\n        char **c;\n        int r = 0;\n\n        assert(bus);\n        assert(name);\n        assert(units);\n\n        r = strv_extend(units, name);\n        if (r < 0)\n                return log_oom();\n\n        r = list_dependencies_get_dependencies(bus, name, &deps);\n        if (r < 0)\n                return r;\n\n        qsort_safe(deps, strv_length(deps), sizeof (char*), list_dependencies_compare);\n\n        STRV_FOREACH(c, deps) {\n                if (strv_contains(*units, *c)) {\n                        if (!arg_plain) {\n                                printf(\"  \");\n                                r = list_dependencies_print(\"...\", level + 1, (branches << 1) | (c[1] == NULL ? 0 : 1), 1);\n                                if (r < 0)\n                                        return r;\n                        }\n                        continue;\n                }\n\n                if (arg_plain)\n                        printf(\"  \");\n                else {\n                        UnitActiveState active_state = _UNIT_ACTIVE_STATE_INVALID;\n                        const char *on;\n\n                        (void) get_state_one_unit(bus, *c, &active_state);\n\n                        switch (active_state) {\n                        case UNIT_ACTIVE:\n                        case UNIT_RELOADING:\n                        case UNIT_ACTIVATING:\n                                on = ansi_highlight_green();\n                                break;\n\n                        case UNIT_INACTIVE:\n                        case UNIT_DEACTIVATING:\n                                on = ansi_normal();\n                                break;\n\n                        default:\n                                on = ansi_highlight_red();\n                                break;\n                        }\n\n                        printf(\"%s%s%s \", on, special_glyph(BLACK_CIRCLE), ansi_normal());\n                }\n\n                r = list_dependencies_print(*c, level, branches, c[1] == NULL);\n                if (r < 0)\n                        return r;\n\n                if (arg_all || unit_name_to_type(*c) == UNIT_TARGET) {\n                       r = list_dependencies_one(bus, *c, level + 1, units, (branches << 1) | (c[1] == NULL ? 0 : 1));\n                       if (r < 0)\n                               return r;\n                }\n        }\n\n        if (!arg_plain)\n                strv_remove(*units, name);\n\n        return 0;\n}\n\nstatic int list_dependencies(int argc, char *argv[], void *userdata) {\n        _cleanup_strv_free_ char **units = NULL;\n        _cleanup_free_ char *unit = NULL;\n        const char *u;\n        sd_bus *bus;\n        int r;\n\n        if (argv[1]) {\n                r = unit_name_mangle(argv[1], arg_quiet ? 0 : UNIT_NAME_MANGLE_WARN, &unit);\n                if (r < 0)\n                        return log_error_errno(r, \"Failed to mangle unit name: %m\");\n\n                u = unit;\n        } else\n                u = SPECIAL_DEFAULT_TARGET;\n\n        r = acquire_bus(BUS_MANAGER, &bus);\n        if (r < 0)\n                return r;\n\n        (void) pager_open(arg_no_pager, false);\n\n        puts(u);\n\n        return list_dependencies_one(bus, u, 0, &units, 0);\n}\n\nstruct machine_info {\n        bool is_host;\n        char *name;\n        char *state;\n        char *control_group;\n        uint32_t n_failed_units;\n        uint32_t n_jobs;\n        usec_t timestamp;\n};\n\nstatic const struct bus_properties_map machine_info_property_map[] = {\n        { \"SystemState\",        \"s\", NULL, offsetof(struct machine_info, state)          },\n        { \"NJobs\",              \"u\", NULL, offsetof(struct machine_info, n_jobs)         },\n        { \"NFailedUnits\",       \"u\", NULL, offsetof(struct machine_info, n_failed_units) },\n        { \"ControlGroup\",       \"s\", NULL, offsetof(struct machine_info, control_group)  },\n        { \"UserspaceTimestamp\", \"t\", NULL, offsetof(struct machine_info, timestamp)      },\n        {}\n};\n\nstatic void machine_info_clear(struct machine_info *info) {\n        assert(info);\n\n        free(info->name);\n        free(info->state);\n        free(info->control_group);\n        zero(*info);\n}\n\nstatic void free_machines_list(struct machine_info *machine_infos, int n) {\n        int i;\n\n        if (!machine_infos)\n                return;\n\n        for (i = 0; i < n; i++)\n                machine_info_clear(&machine_infos[i]);\n\n        free(machine_infos);\n}\n\nstatic int compare_machine_info(const void *a, const void *b) {\n        const struct machine_info *u = a, *v = b;\n\n        if (u->is_host != v->is_host)\n                return u->is_host > v->is_host ? -1 : 1;\n\n        return strcasecmp(u->name, v->name);\n}\n\nstatic int get_machine_properties(sd_bus *bus, struct machine_info *mi) {\n        _cleanup_(sd_bus_flush_close_unrefp) sd_bus *container = NULL;\n        int r;\n\n        assert(mi);\n\n        if (!bus) {\n                r = sd_bus_open_system_machine(&container, mi->name);\n                if (r < 0)\n                        return r;\n\n                bus = container;\n        }\n\n        r = bus_map_all_properties(\n                        bus,\n                        \"org.freedesktop.systemd1\",\n                        \"/org/freedesktop/systemd1\",\n                        machine_info_property_map,\n                        BUS_MAP_STRDUP,\n                        NULL,\n                        NULL,\n                        mi);\n        if (r < 0)\n                return r;\n\n        return 0;\n}\n\nstatic bool output_show_machine(const char *name, char **patterns) {\n        return strv_fnmatch_or_empty(patterns, name, FNM_NOESCAPE);\n}\n\nstatic int get_machine_list(\n                sd_bus *bus,\n                struct machine_info **_machine_infos,\n                char **patterns) {\n\n        struct machine_info *machine_infos = NULL;\n        _cleanup_strv_free_ char **m = NULL;\n        _cleanup_free_ char *hn = NULL;\n        size_t sz = 0;\n        char **i;\n        int c = 0, r;\n\n        hn = gethostname_malloc();\n        if (!hn)\n                return log_oom();\n\n        if (output_show_machine(hn, patterns)) {\n                if (!GREEDY_REALLOC0(machine_infos, sz, c+1))\n                        return log_oom();\n\n                machine_infos[c].is_host = true;\n                machine_infos[c].name = TAKE_PTR(hn);\n\n                (void) get_machine_properties(bus, &machine_infos[c]);\n                c++;\n        }\n\n        r = sd_get_machine_names(&m);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to get machine list: %m\");\n\n        STRV_FOREACH(i, m) {\n                _cleanup_free_ char *class = NULL;\n\n                if (!output_show_machine(*i, patterns))\n                        continue;\n\n                sd_machine_get_class(*i, &class);\n                if (!streq_ptr(class, \"container\"))\n                        continue;\n\n                if (!GREEDY_REALLOC0(machine_infos, sz, c+1)) {\n                        free_machines_list(machine_infos, c);\n                        return log_oom();\n                }\n\n                machine_infos[c].is_host = false;\n                machine_infos[c].name = strdup(*i);\n                if (!machine_infos[c].name) {\n                        free_machines_list(machine_infos, c);\n                        return log_oom();\n                }\n\n                (void) get_machine_properties(NULL, &machine_infos[c]);\n                c++;\n        }\n\n        *_machine_infos = machine_infos;\n        return c;\n}\n\nstatic void output_machines_list(struct machine_info *machine_infos, unsigned n) {\n        struct machine_info *m;\n        unsigned\n                circle_len = 0,\n                namelen = STRLEN(\"NAME\"),\n                statelen = STRLEN(\"STATE\"),\n                failedlen = STRLEN(\"FAILED\"),\n                jobslen = STRLEN(\"JOBS\");\n\n        assert(machine_infos || n == 0);\n\n        for (m = machine_infos; m < machine_infos + n; m++) {\n                namelen = MAX(namelen,\n                              strlen(m->name) + (m->is_host ? STRLEN(\" (host)\") : 0));\n                statelen = MAX(statelen, strlen_ptr(m->state));\n                failedlen = MAX(failedlen, DECIMAL_STR_WIDTH(m->n_failed_units));\n                jobslen = MAX(jobslen, DECIMAL_STR_WIDTH(m->n_jobs));\n\n                if (!arg_plain && !streq_ptr(m->state, \"running\"))\n                        circle_len = 2;\n        }\n\n        if (!arg_no_legend) {\n                if (circle_len > 0)\n                        fputs(\"  \", stdout);\n\n                printf(\"%-*s %-*s %-*s %-*s\\n\",\n                         namelen, \"NAME\",\n                        statelen, \"STATE\",\n                       failedlen, \"FAILED\",\n                         jobslen, \"JOBS\");\n        }\n\n        for (m = machine_infos; m < machine_infos + n; m++) {\n                const char *on_state = \"\", *off_state = \"\";\n                const char *on_failed = \"\", *off_failed = \"\";\n                bool circle = false;\n\n                if (streq_ptr(m->state, \"degraded\")) {\n                        on_state = ansi_highlight_red();\n                        off_state = ansi_normal();\n                        circle = true;\n                } else if (!streq_ptr(m->state, \"running\")) {\n                        on_state = ansi_highlight_yellow();\n                        off_state = ansi_normal();\n                        circle = true;\n                }\n\n                if (m->n_failed_units > 0) {\n                        on_failed = ansi_highlight_red();\n                        off_failed = ansi_normal();\n                } else\n                        on_failed = off_failed = \"\";\n\n                if (circle_len > 0)\n                        printf(\"%s%s%s \", on_state, circle ? special_glyph(BLACK_CIRCLE) : \" \", off_state);\n\n                if (m->is_host)\n                        printf(\"%-*s (host) %s%-*s%s %s%*\" PRIu32 \"%s %*\" PRIu32 \"\\n\",\n                               (int) (namelen - (STRLEN(\" (host)\"))),\n                               strna(m->name),\n                               on_state, statelen, strna(m->state), off_state,\n                               on_failed, failedlen, m->n_failed_units, off_failed,\n                               jobslen, m->n_jobs);\n                else\n                        printf(\"%-*s %s%-*s%s %s%*\" PRIu32 \"%s %*\" PRIu32 \"\\n\",\n                               namelen, strna(m->name),\n                               on_state, statelen, strna(m->state), off_state,\n                               on_failed, failedlen, m->n_failed_units, off_failed,\n                               jobslen, m->n_jobs);\n        }\n\n        if (!arg_no_legend)\n                printf(\"\\n%u machines listed.\\n\", n);\n}\n\nstatic int list_machines(int argc, char *argv[], void *userdata) {\n        struct machine_info *machine_infos = NULL;\n        sd_bus *bus;\n        int r;\n\n        r = acquire_bus(BUS_MANAGER, &bus);\n        if (r < 0)\n                return r;\n\n        r = get_machine_list(bus, &machine_infos, strv_skip(argv, 1));\n        if (r < 0)\n                return r;\n\n        (void) pager_open(arg_no_pager, false);\n\n        qsort_safe(machine_infos, r, sizeof(struct machine_info), compare_machine_info);\n        output_machines_list(machine_infos, r);\n        free_machines_list(machine_infos, r);\n\n        return 0;\n}\n\nstatic int get_default(int argc, char *argv[], void *userdata) {\n        _cleanup_(sd_bus_message_unrefp) sd_bus_message *reply = NULL;\n        _cleanup_free_ char *_path = NULL;\n        const char *path;\n        int r;\n\n        if (install_client_side()) {\n                r = unit_file_get_default(arg_scope, arg_root, &_path);\n                if (r < 0)\n                        return log_error_errno(r, \"Failed to get default target: %m\");\n                path = _path;\n\n                r = 0;\n        } else {\n                _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n                sd_bus *bus;\n\n                r = acquire_bus(BUS_MANAGER, &bus);\n                if (r < 0)\n                        return r;\n\n                r = sd_bus_call_method(\n                                bus,\n                                \"org.freedesktop.systemd1\",\n                                \"/org/freedesktop/systemd1\",\n                                \"org.freedesktop.systemd1.Manager\",\n                                \"GetDefaultTarget\",\n                                &error,\n                                &reply,\n                                NULL);\n                if (r < 0)\n                        return log_error_errno(r, \"Failed to get default target: %s\", bus_error_message(&error, r));\n\n                r = sd_bus_message_read(reply, \"s\", &path);\n                if (r < 0)\n                        return bus_log_parse_error(r);\n        }\n\n        if (path)\n                printf(\"%s\\n\", path);\n\n        return 0;\n}\n\nstatic int set_default(int argc, char *argv[], void *userdata) {\n        _cleanup_free_ char *unit = NULL;\n        UnitFileChange *changes = NULL;\n        size_t n_changes = 0;\n        int r;\n\n        assert(argc >= 2);\n        assert(argv);\n\n        r = unit_name_mangle_with_suffix(argv[1], arg_quiet ? 0 : UNIT_NAME_MANGLE_WARN, \".target\", &unit);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to mangle unit name: %m\");\n\n        if (install_client_side()) {\n                r = unit_file_set_default(arg_scope, UNIT_FILE_FORCE, arg_root, unit, &changes, &n_changes);\n                unit_file_dump_changes(r, \"set default\", changes, n_changes, arg_quiet);\n\n                if (r > 0)\n                        r = 0;\n        } else {\n                _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n                _cleanup_(sd_bus_message_unrefp) sd_bus_message *reply = NULL;\n                sd_bus *bus;\n\n                polkit_agent_open_maybe();\n\n                r = acquire_bus(BUS_MANAGER, &bus);\n                if (r < 0)\n                        return r;\n\n                r = sd_bus_call_method(\n                                bus,\n                                \"org.freedesktop.systemd1\",\n                                \"/org/freedesktop/systemd1\",\n                                \"org.freedesktop.systemd1.Manager\",\n                                \"SetDefaultTarget\",\n                                &error,\n                                &reply,\n                                \"sb\", unit, 1);\n                if (r < 0)\n                        return log_error_errno(r, \"Failed to set default target: %s\", bus_error_message(&error, r));\n\n                r = bus_deserialize_and_dump_unit_file_changes(reply, arg_quiet, &changes, &n_changes);\n                if (r < 0)\n                        goto finish;\n\n                /* Try to reload if enabled */\n                if (!arg_no_reload)\n                        r = daemon_reload(argc, argv, userdata);\n                else\n                        r = 0;\n        }\n\nfinish:\n        unit_file_changes_free(changes, n_changes);\n\n        return r;\n}\n\nstatic int output_waiting_jobs(sd_bus *bus, uint32_t id, const char *method, const char *prefix) {\n        _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n        _cleanup_(sd_bus_message_unrefp) sd_bus_message *reply = NULL;\n        const char *name, *type;\n        uint32_t other_id;\n        int r;\n\n        assert(bus);\n\n        r = sd_bus_call_method(\n                        bus,\n                        \"org.freedesktop.systemd1\",\n                        \"/org/freedesktop/systemd1\",\n                        \"org.freedesktop.systemd1.Manager\",\n                        method,\n                        &error,\n                        &reply,\n                        \"u\", id);\n        if (r < 0)\n                return log_debug_errno(r, \"Failed to get waiting jobs for job %\" PRIu32, id);\n\n        r = sd_bus_message_enter_container(reply, 'a', \"(usssoo)\");\n        if (r < 0)\n                return bus_log_parse_error(r);\n\n        while ((r = sd_bus_message_read(reply, \"(usssoo)\", &other_id, &name, &type, NULL, NULL, NULL)) > 0)\n                printf(\"%s %u (%s/%s)\\n\", prefix, other_id, name, type);\n        if (r < 0)\n                return bus_log_parse_error(r);\n\n        r = sd_bus_message_exit_container(reply);\n        if (r < 0)\n                return bus_log_parse_error(r);\n\n        return 0;\n}\n\nstruct job_info {\n        uint32_t id;\n        const char *name, *type, *state;\n};\n\nstatic void output_jobs_list(sd_bus *bus, const struct job_info* jobs, unsigned n, bool skipped) {\n        unsigned id_len, unit_len, type_len, state_len;\n        const struct job_info *j;\n        const char *on, *off;\n        bool shorten = false;\n\n        assert(n == 0 || jobs);\n\n        if (n == 0) {\n                if (!arg_no_legend) {\n                        on = ansi_highlight_green();\n                        off = ansi_normal();\n\n                        printf(\"%sNo jobs %s.%s\\n\", on, skipped ? \"listed\" : \"running\", off);\n                }\n                return;\n        }\n\n        (void) pager_open(arg_no_pager, false);\n\n        id_len = STRLEN(\"JOB\");\n        unit_len = STRLEN(\"UNIT\");\n        type_len = STRLEN(\"TYPE\");\n        state_len = STRLEN(\"STATE\");\n\n        for (j = jobs; j < jobs + n; j++) {\n                uint32_t id = j->id;\n                assert(j->name && j->type && j->state);\n\n                id_len = MAX(id_len, DECIMAL_STR_WIDTH(id));\n                unit_len = MAX(unit_len, strlen(j->name));\n                type_len = MAX(type_len, strlen(j->type));\n                state_len = MAX(state_len, strlen(j->state));\n        }\n\n        if (!arg_full && id_len + 1 + unit_len + type_len + 1 + state_len > columns()) {\n                unit_len = MAX(33u, columns() - id_len - type_len - state_len - 3);\n                shorten = true;\n        }\n\n        if (!arg_no_legend)\n                printf(\"%*s %-*s %-*s %-*s\\n\",\n                       id_len, \"JOB\",\n                       unit_len, \"UNIT\",\n                       type_len, \"TYPE\",\n                       state_len, \"STATE\");\n\n        for (j = jobs; j < jobs + n; j++) {\n                _cleanup_free_ char *e = NULL;\n\n                if (streq(j->state, \"running\")) {\n                        on = ansi_highlight();\n                        off = ansi_normal();\n                } else\n                        on = off = \"\";\n\n                e = shorten ? ellipsize(j->name, unit_len, 33) : NULL;\n                printf(\"%*u %s%-*s%s %-*s %s%-*s%s\\n\",\n                       id_len, j->id,\n                       on, unit_len, e ? e : j->name, off,\n                       type_len, j->type,\n                       on, state_len, j->state, off);\n\n                if (arg_jobs_after)\n                        output_waiting_jobs(bus, j->id, \"GetJobAfter\", \"\\twaiting for job\");\n                if (arg_jobs_before)\n                        output_waiting_jobs(bus, j->id, \"GetJobBefore\", \"\\tblocking job\");\n        }\n\n        if (!arg_no_legend) {\n                on = ansi_highlight();\n                off = ansi_normal();\n\n                printf(\"\\n%s%u jobs listed%s.\\n\", on, n, off);\n        }\n}\n\nstatic bool output_show_job(struct job_info *job, char **patterns) {\n        return strv_fnmatch_or_empty(patterns, job->name, FNM_NOESCAPE);\n}\n\nstatic int list_jobs(int argc, char *argv[], void *userdata) {\n        _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n        _cleanup_(sd_bus_message_unrefp) sd_bus_message *reply = NULL;\n        _cleanup_free_ struct job_info *jobs = NULL;\n        const char *name, *type, *state;\n        bool skipped = false;\n        size_t size = 0;\n        unsigned c = 0;\n        sd_bus *bus;\n        uint32_t id;\n        int r;\n\n        r = acquire_bus(BUS_MANAGER, &bus);\n        if (r < 0)\n                return r;\n\n        r = sd_bus_call_method(\n                        bus,\n                        \"org.freedesktop.systemd1\",\n                        \"/org/freedesktop/systemd1\",\n                        \"org.freedesktop.systemd1.Manager\",\n                        \"ListJobs\",\n                        &error,\n                        &reply,\n                        NULL);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to list jobs: %s\", bus_error_message(&error, r));\n\n        r = sd_bus_message_enter_container(reply, 'a', \"(usssoo)\");\n        if (r < 0)\n                return bus_log_parse_error(r);\n\n        while ((r = sd_bus_message_read(reply, \"(usssoo)\", &id, &name, &type, &state, NULL, NULL)) > 0) {\n                struct job_info job = { id, name, type, state };\n\n                if (!output_show_job(&job, strv_skip(argv, 1))) {\n                        skipped = true;\n                        continue;\n                }\n\n                if (!GREEDY_REALLOC(jobs, size, c + 1))\n                        return log_oom();\n\n                jobs[c++] = job;\n        }\n        if (r < 0)\n                return bus_log_parse_error(r);\n\n        r = sd_bus_message_exit_container(reply);\n        if (r < 0)\n                return bus_log_parse_error(r);\n\n        (void) pager_open(arg_no_pager, false);\n\n        output_jobs_list(bus, jobs, c, skipped);\n        return 0;\n}\n\nstatic int cancel_job(int argc, char *argv[], void *userdata) {\n        sd_bus *bus;\n        char **name;\n        int r = 0;\n\n        if (argc <= 1)\n                return trivial_method(argc, argv, userdata);\n\n        r = acquire_bus(BUS_MANAGER, &bus);\n        if (r < 0)\n                return r;\n\n        polkit_agent_open_maybe();\n\n        STRV_FOREACH(name, strv_skip(argv, 1)) {\n                _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n                uint32_t id;\n                int q;\n\n                q = safe_atou32(*name, &id);\n                if (q < 0)\n                        return log_error_errno(q, \"Failed to parse job id \\\"%s\\\": %m\", *name);\n\n                q = sd_bus_call_method(\n                                bus,\n                                \"org.freedesktop.systemd1\",\n                                \"/org/freedesktop/systemd1\",\n                                \"org.freedesktop.systemd1.Manager\",\n                                \"CancelJob\",\n                                &error,\n                                NULL,\n                                \"u\", id);\n                if (q < 0) {\n                        log_error_errno(q, \"Failed to cancel job %\"PRIu32\": %s\", id, bus_error_message(&error, q));\n                        if (r == 0)\n                                r = q;\n                }\n        }\n\n        return r;\n}\n\nstatic int need_daemon_reload(sd_bus *bus, const char *unit) {\n        _cleanup_(sd_bus_message_unrefp) sd_bus_message *reply = NULL;\n        const char *path;\n        int b, r;\n\n        /* We ignore all errors here, since this is used to show a\n         * warning only */\n\n        /* We don't use unit_dbus_path_from_name() directly since we\n         * don't want to load the unit if it isn't loaded. */\n\n        r = sd_bus_call_method(\n                        bus,\n                        \"org.freedesktop.systemd1\",\n                        \"/org/freedesktop/systemd1\",\n                        \"org.freedesktop.systemd1.Manager\",\n                        \"GetUnit\",\n                        NULL,\n                        &reply,\n                        \"s\", unit);\n        if (r < 0)\n                return r;\n\n        r = sd_bus_message_read(reply, \"o\", &path);\n        if (r < 0)\n                return r;\n\n        r = sd_bus_get_property_trivial(\n                        bus,\n                        \"org.freedesktop.systemd1\",\n                        path,\n                        \"org.freedesktop.systemd1.Unit\",\n                        \"NeedDaemonReload\",\n                        NULL,\n                        'b', &b);\n        if (r < 0)\n                return r;\n\n        return b;\n}\n\nstatic void warn_unit_file_changed(const char *name) {\n        assert(name);\n\n        log_warning(\"%sWarning:%s The unit file, source configuration file or drop-ins of %s changed on disk. Run 'systemctl%s daemon-reload' to reload units.\",\n                    ansi_highlight_red(),\n                    ansi_normal(),\n                    name,\n                    arg_scope == UNIT_FILE_SYSTEM ? \"\" : \" --user\");\n}\n\nstatic int unit_file_find_path(LookupPaths *lp, const char *unit_name, char **unit_path) {\n        char **p;\n\n        assert(lp);\n        assert(unit_name);\n\n        STRV_FOREACH(p, lp->search_path) {\n                _cleanup_free_ char *path = NULL, *lpath = NULL;\n                int r;\n\n                path = path_join(NULL, *p, unit_name);\n                if (!path)\n                        return log_oom();\n\n                r = chase_symlinks(path, arg_root, 0, &lpath);\n                if (r == -ENOENT)\n                        continue;\n                if (r == -ENOMEM)\n                        return log_oom();\n                if (r < 0)\n                        return log_error_errno(r, \"Failed to access path '%s': %m\", path);\n\n                if (unit_path)\n                        *unit_path = TAKE_PTR(lpath);\n\n                return 1;\n        }\n\n        return 0;\n}\n\nstatic int unit_find_template_path(\n                const char *unit_name,\n                LookupPaths *lp,\n                char **fragment_path,\n                char **template) {\n\n        _cleanup_free_ char *_template = NULL;\n        int r;\n\n        /* Returns 1 if a fragment was found, 0 if not found, negative on error. */\n\n        r = unit_file_find_path(lp, unit_name, fragment_path);\n        if (r != 0)\n                return r; /* error or found a real unit */\n\n        r = unit_name_template(unit_name, &_template);\n        if (r == -EINVAL)\n                return 0; /* not a template, does not exist */\n        if (r < 0)\n                return log_error_errno(r, \"Failed to determine template name: %m\");\n\n        r = unit_file_find_path(lp, _template, fragment_path);\n        if (r < 0)\n                return r;\n\n        if (template)\n                *template = TAKE_PTR(_template);\n\n        return r;\n}\n\nstatic int unit_find_paths(\n                sd_bus *bus,\n                const char *unit_name,\n                LookupPaths *lp,\n                char **fragment_path,\n                char ***dropin_paths) {\n\n        _cleanup_free_ char *path = NULL;\n        _cleanup_strv_free_ char **dropins = NULL;\n        int r;\n\n        /**\n         * Finds where the unit is defined on disk. Returns 0 if the unit\n         * is not found. Returns 1 if it is found, and sets\n         * - the path to the unit in *path, if it exists on disk,\n         * - and a strv of existing drop-ins in *dropins,\n         *   if the arg is not NULL and any dropins were found.\n         */\n\n        assert(unit_name);\n        assert(fragment_path);\n        assert(lp);\n\n        if (!install_client_side() && !unit_name_is_valid(unit_name, UNIT_NAME_TEMPLATE)) {\n                _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n                _cleanup_free_ char *unit = NULL;\n\n                unit = unit_dbus_path_from_name(unit_name);\n                if (!unit)\n                        return log_oom();\n\n                r = sd_bus_get_property_string(\n                                bus,\n                                \"org.freedesktop.systemd1\",\n                                unit,\n                                \"org.freedesktop.systemd1.Unit\",\n                                \"FragmentPath\",\n                                &error,\n                                &path);\n                if (r < 0)\n                        return log_error_errno(r, \"Failed to get FragmentPath: %s\", bus_error_message(&error, r));\n\n                if (dropin_paths) {\n                        r = sd_bus_get_property_strv(\n                                        bus,\n                                        \"org.freedesktop.systemd1\",\n                                        unit,\n                                        \"org.freedesktop.systemd1.Unit\",\n                                        \"DropInPaths\",\n                                        &error,\n                                        &dropins);\n                        if (r < 0)\n                                return log_error_errno(r, \"Failed to get DropInPaths: %s\", bus_error_message(&error, r));\n                }\n        } else {\n                _cleanup_set_free_ Set *names = NULL;\n                _cleanup_free_ char *template = NULL;\n\n                names = set_new(NULL);\n                if (!names)\n                        return log_oom();\n\n                r = unit_find_template_path(unit_name, lp, &path, &template);\n                if (r < 0)\n                        return r;\n\n                if (r > 0)\n                        /* We found the unit file. If we followed symlinks, this name might be\n                         * different then the unit_name with started with. Look for dropins matching\n                         * that \"final\" name. */\n                        r = set_put(names, basename(path));\n                else if (!template)\n                        /* No unit file, let's look for dropins matching the original name.\n                         * systemd has fairly complicated rules (based on unit type and provenience),\n                         * which units are allowed not to have the main unit file. We err on the\n                         * side of including too many files, and always try to load dropins. */\n                        r = set_put(names, unit_name);\n                else\n                        /* The cases where we allow a unit to exist without the main file are\n                         * never valid for templates. Don't try to load dropins in this case. */\n                        goto not_found;\n\n                if (r < 0)\n                        return log_error_errno(r, \"Failed to add unit name: %m\");\n\n                if (dropin_paths) {\n                        r = unit_file_find_dropin_conf_paths(arg_root, lp->search_path,\n                                                             NULL, names, &dropins);\n                        if (r < 0)\n                                return r;\n                }\n        }\n\n        r = 0;\n\n        if (!isempty(path)) {\n                *fragment_path = TAKE_PTR(path);\n                r = 1;\n        }\n\n        if (dropin_paths && !strv_isempty(dropins)) {\n                *dropin_paths = TAKE_PTR(dropins);\n                r = 1;\n        }\n not_found:\n        if (r == 0 && !arg_force)\n                log_error(\"No files found for %s.\", unit_name);\n\n        return r;\n}\n\nstatic int get_state_one_unit(sd_bus *bus, const char *name, UnitActiveState *active_state) {\n        _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n        _cleanup_free_ char *buf = NULL, *path = NULL;\n        UnitActiveState state;\n        int r;\n\n        assert(name);\n        assert(active_state);\n\n        path = unit_dbus_path_from_name(name);\n        if (!path)\n                return log_oom();\n\n        r = sd_bus_get_property_string(\n                        bus,\n                        \"org.freedesktop.systemd1\",\n                        path,\n                        \"org.freedesktop.systemd1.Unit\",\n                        \"ActiveState\",\n                        &error,\n                        &buf);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to retrieve unit state: %s\", bus_error_message(&error, r));\n\n        state = unit_active_state_from_string(buf);\n        if (state == _UNIT_ACTIVE_STATE_INVALID) {\n                log_error(\"Invalid unit state '%s' for: %s\", buf, name);\n                return -EINVAL;\n        }\n\n        *active_state = state;\n        return 0;\n}\n\nstatic int unit_is_masked(sd_bus *bus, const char *name) {\n        _cleanup_free_ char *load_state = NULL;\n        int r;\n\n        r = unit_load_state(bus, name, &load_state);\n        if (r < 0)\n                return r;\n\n        return streq(load_state, \"masked\");\n}\n\nstatic int check_triggering_units(sd_bus *bus, const char *name) {\n        _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n        _cleanup_free_ char *n = NULL, *path = NULL;\n        _cleanup_strv_free_ char **triggered_by = NULL;\n        bool print_warning_label = true;\n        UnitActiveState active_state;\n        char **i;\n        int r;\n\n        r = unit_name_mangle(name, 0, &n);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to mangle unit name: %m\");\n\n        r = unit_is_masked(bus, n);\n        if (r != 0)\n                return r < 0 ? r : 0;\n\n        path = unit_dbus_path_from_name(n);\n        if (!path)\n                return log_oom();\n\n        r = sd_bus_get_property_strv(\n                        bus,\n                        \"org.freedesktop.systemd1\",\n                        path,\n                        \"org.freedesktop.systemd1.Unit\",\n                        \"TriggeredBy\",\n                        &error,\n                        &triggered_by);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to get triggered by array of %s: %s\", n, bus_error_message(&error, r));\n\n        STRV_FOREACH(i, triggered_by) {\n                r = get_state_one_unit(bus, *i, &active_state);\n                if (r < 0)\n                        return r;\n\n                if (!IN_SET(active_state, UNIT_ACTIVE, UNIT_RELOADING))\n                        continue;\n\n                if (print_warning_label) {\n                        log_warning(\"Warning: Stopping %s, but it can still be activated by:\", n);\n                        print_warning_label = false;\n                }\n\n                log_warning(\"  %s\", *i);\n        }\n\n        return 0;\n}\n\nstatic const struct {\n        const char *verb;\n        const char *method;\n} unit_actions[] = {\n        { \"start\",                 \"StartUnit\" },\n        { \"stop\",                  \"StopUnit\" },\n        { \"condstop\",              \"StopUnit\" },\n        { \"reload\",                \"ReloadUnit\" },\n        { \"restart\",               \"RestartUnit\" },\n        { \"try-restart\",           \"TryRestartUnit\" },\n        { \"condrestart\",           \"TryRestartUnit\" },\n        { \"reload-or-restart\",     \"ReloadOrRestartUnit\" },\n        { \"try-reload-or-restart\", \"ReloadOrTryRestartUnit\" },\n        { \"reload-or-try-restart\", \"ReloadOrTryRestartUnit\" },\n        { \"condreload\",            \"ReloadOrTryRestartUnit\" },\n        { \"force-reload\",          \"ReloadOrTryRestartUnit\" }\n};\n\nstatic const char *verb_to_method(const char *verb) {\n       uint i;\n\n       for (i = 0; i < ELEMENTSOF(unit_actions); i++)\n                if (streq_ptr(unit_actions[i].verb, verb))\n                        return unit_actions[i].method;\n\n       return \"StartUnit\";\n}\n\nstatic const char *method_to_verb(const char *method) {\n       uint i;\n\n       for (i = 0; i < ELEMENTSOF(unit_actions); i++)\n                if (streq_ptr(unit_actions[i].method, method))\n                        return unit_actions[i].verb;\n\n       return \"n/a\";\n}\n\ntypedef struct {\n        sd_bus_slot *match;\n        sd_event *event;\n        Set *unit_paths;\n        bool any_failed;\n} WaitContext;\n\nstatic void wait_context_free(WaitContext *c) {\n        c->match = sd_bus_slot_unref(c->match);\n        c->event = sd_event_unref(c->event);\n        c->unit_paths = set_free_free(c->unit_paths);\n}\n\nstatic int on_properties_changed(sd_bus_message *m, void *userdata, sd_bus_error *error) {\n        WaitContext *c = userdata;\n        const char *path;\n        int r;\n\n        path = sd_bus_message_get_path(m);\n        if (!set_contains(c->unit_paths, path))\n                return 0;\n\n        /* Check if ActiveState changed to inactive/failed */\n        /* (s interface, a{sv} changed_properties, as invalidated_properties) */\n        r = sd_bus_message_skip(m, \"s\");\n        if (r < 0)\n                return bus_log_parse_error(r);\n\n        r = sd_bus_message_enter_container(m, SD_BUS_TYPE_ARRAY, \"{sv}\");\n        if (r < 0)\n                return bus_log_parse_error(r);\n\n        while ((r = sd_bus_message_enter_container(m, SD_BUS_TYPE_DICT_ENTRY, \"sv\")) > 0) {\n                const char *s;\n\n                r = sd_bus_message_read(m, \"s\", &s);\n                if (r < 0)\n                        return bus_log_parse_error(r);\n\n                if (streq(s, \"ActiveState\")) {\n                        bool is_failed;\n\n                        r = sd_bus_message_enter_container(m, SD_BUS_TYPE_VARIANT, \"s\");\n                        if (r < 0)\n                                return bus_log_parse_error(r);\n\n                        r = sd_bus_message_read(m, \"s\", &s);\n                        if (r < 0)\n                                return bus_log_parse_error(r);\n\n                        is_failed = streq(s, \"failed\");\n                        if (streq(s, \"inactive\") || is_failed) {\n                                log_debug(\"%s became %s, dropping from --wait tracking\", path, s);\n                                free(set_remove(c->unit_paths, path));\n                                c->any_failed = c->any_failed || is_failed;\n                        } else\n                                log_debug(\"ActiveState on %s changed to %s\", path, s);\n\n                        break; /* no need to dissect the rest of the message */\n                } else {\n                        /* other property */\n                        r = sd_bus_message_skip(m, \"v\");\n                        if (r < 0)\n                                return bus_log_parse_error(r);\n                }\n                r = sd_bus_message_exit_container(m);\n                if (r < 0)\n                        return bus_log_parse_error(r);\n        }\n        if (r < 0)\n                return bus_log_parse_error(r);\n\n        if (set_isempty(c->unit_paths))\n                sd_event_exit(c->event, EXIT_SUCCESS);\n\n        return 0;\n}\n\nstatic int start_unit_one(\n                sd_bus *bus,\n                const char *method,\n                const char *name,\n                const char *mode,\n                sd_bus_error *error,\n                BusWaitForJobs *w,\n                WaitContext *wait_context) {\n\n        _cleanup_(sd_bus_message_unrefp) sd_bus_message *reply = NULL;\n        const char *path;\n        int r;\n\n        assert(method);\n        assert(name);\n        assert(mode);\n        assert(error);\n\n        if (wait_context) {\n                _cleanup_free_ char *unit_path = NULL;\n\n                log_debug(\"Watching for property changes of %s\", name);\n                r = sd_bus_call_method(\n                                bus,\n                                \"org.freedesktop.systemd1\",\n                                \"/org/freedesktop/systemd1\",\n                                \"org.freedesktop.systemd1.Manager\",\n                                \"RefUnit\",\n                                error,\n                                NULL,\n                                \"s\", name);\n                if (r < 0)\n                        return log_error_errno(r, \"Failed to RefUnit %s: %s\", name, bus_error_message(error, r));\n\n                unit_path = unit_dbus_path_from_name(name);\n                if (!unit_path)\n                        return log_oom();\n\n                r = set_put_strdup(wait_context->unit_paths, unit_path);\n                if (r < 0)\n                        return log_error_errno(r, \"Failed to add unit path %s to set: %m\", unit_path);\n\n                r = sd_bus_match_signal_async(bus,\n                                              &wait_context->match,\n                                              NULL,\n                                              unit_path,\n                                              \"org.freedesktop.DBus.Properties\",\n                                              \"PropertiesChanged\",\n                                              on_properties_changed, NULL, wait_context);\n                if (r < 0)\n                        return log_error_errno(r, \"Failed to request match for PropertiesChanged signal: %m\");\n        }\n\n        log_debug(\"%s dbus call org.freedesktop.systemd1.Manager %s(%s, %s)\",\n                  arg_dry_run ? \"Would execute\" : \"Executing\",\n                  method, name, mode);\n        if (arg_dry_run)\n                return 0;\n\n        r = sd_bus_call_method(\n                        bus,\n                        \"org.freedesktop.systemd1\",\n                        \"/org/freedesktop/systemd1\",\n                        \"org.freedesktop.systemd1.Manager\",\n                        method,\n                        error,\n                        &reply,\n                        \"ss\", name, mode);\n        if (r < 0) {\n                const char *verb;\n\n                /* There's always a fallback possible for legacy actions. */\n                if (arg_action != ACTION_SYSTEMCTL)\n                        return r;\n\n                verb = method_to_verb(method);\n\n                log_error(\"Failed to %s %s: %s\", verb, name, bus_error_message(error, r));\n\n                if (!sd_bus_error_has_name(error, BUS_ERROR_NO_SUCH_UNIT) &&\n                    !sd_bus_error_has_name(error, BUS_ERROR_UNIT_MASKED) &&\n                    !sd_bus_error_has_name(error, BUS_ERROR_JOB_TYPE_NOT_APPLICABLE))\n                        log_error(\"See %s logs and 'systemctl%s status%s %s' for details.\",\n                                   arg_scope == UNIT_FILE_SYSTEM ? \"system\" : \"user\",\n                                   arg_scope == UNIT_FILE_SYSTEM ? \"\" : \" --user\",\n                                   name[0] == '-' ? \" --\" : \"\",\n                                   name);\n\n                return r;\n        }\n\n        r = sd_bus_message_read(reply, \"o\", &path);\n        if (r < 0)\n                return bus_log_parse_error(r);\n\n        if (need_daemon_reload(bus, name) > 0)\n                warn_unit_file_changed(name);\n\n        if (w) {\n                log_debug(\"Adding %s to the set\", path);\n                r = bus_wait_for_jobs_add(w, path);\n                if (r < 0)\n                        return log_oom();\n        }\n\n        return 0;\n}\n\nstatic int expand_names(sd_bus *bus, char **names, const char* suffix, char ***ret) {\n        _cleanup_strv_free_ char **mangled = NULL, **globs = NULL;\n        char **name;\n        int r, i;\n\n        assert(bus);\n        assert(ret);\n\n        STRV_FOREACH(name, names) {\n                char *t;\n                UnitNameMangle options = UNIT_NAME_MANGLE_GLOB | (arg_quiet ? 0 : UNIT_NAME_MANGLE_WARN);\n\n                if (suffix)\n                        r = unit_name_mangle_with_suffix(*name, options, suffix, &t);\n                else\n                        r = unit_name_mangle(*name, options, &t);\n                if (r < 0)\n                        return log_error_errno(r, \"Failed to mangle name: %m\");\n\n                if (string_is_glob(t))\n                        r = strv_consume(&globs, t);\n                else\n                        r = strv_consume(&mangled, t);\n                if (r < 0)\n                        return log_oom();\n        }\n\n        /* Query the manager only if any of the names are a glob, since\n         * this is fairly expensive */\n        if (!strv_isempty(globs)) {\n                _cleanup_(sd_bus_message_unrefp) sd_bus_message *reply = NULL;\n                _cleanup_free_ UnitInfo *unit_infos = NULL;\n                size_t allocated, n;\n\n                r = get_unit_list(bus, NULL, globs, &unit_infos, 0, &reply);\n                if (r < 0)\n                        return r;\n\n                n = strv_length(mangled);\n                allocated = n + 1;\n\n                for (i = 0; i < r; i++) {\n                        if (!GREEDY_REALLOC(mangled, allocated, n+2))\n                                return log_oom();\n\n                        mangled[n] = strdup(unit_infos[i].id);\n                        if (!mangled[n])\n                                return log_oom();\n\n                        mangled[++n] = NULL;\n                }\n        }\n\n        *ret = TAKE_PTR(mangled);\n\n        return 0;\n}\n\nstatic const struct {\n        const char *target;\n        const char *verb;\n        const char *mode;\n} action_table[_ACTION_MAX] = {\n        [ACTION_HALT]                 = { SPECIAL_HALT_TARGET,                     \"halt\",                   \"replace-irreversibly\" },\n        [ACTION_POWEROFF]             = { SPECIAL_POWEROFF_TARGET,                 \"poweroff\",               \"replace-irreversibly\" },\n        [ACTION_REBOOT]               = { SPECIAL_REBOOT_TARGET,                   \"reboot\",                 \"replace-irreversibly\" },\n        [ACTION_KEXEC]                = { SPECIAL_KEXEC_TARGET,                    \"kexec\",                  \"replace-irreversibly\" },\n        [ACTION_RUNLEVEL2]            = { SPECIAL_MULTI_USER_TARGET,               NULL,                     \"isolate\" },\n        [ACTION_RUNLEVEL3]            = { SPECIAL_MULTI_USER_TARGET,               NULL,                     \"isolate\" },\n        [ACTION_RUNLEVEL4]            = { SPECIAL_MULTI_USER_TARGET,               NULL,                     \"isolate\" },\n        [ACTION_RUNLEVEL5]            = { SPECIAL_GRAPHICAL_TARGET,                NULL,                     \"isolate\" },\n        [ACTION_RESCUE]               = { SPECIAL_RESCUE_TARGET,                   \"rescue\",                 \"isolate\" },\n        [ACTION_EMERGENCY]            = { SPECIAL_EMERGENCY_TARGET,                \"emergency\",              \"isolate\" },\n        [ACTION_DEFAULT]              = { SPECIAL_DEFAULT_TARGET,                  \"default\",                \"isolate\" },\n        [ACTION_EXIT]                 = { SPECIAL_EXIT_TARGET,                     \"exit\",                   \"replace-irreversibly\" },\n        [ACTION_SUSPEND]              = { SPECIAL_SUSPEND_TARGET,                  \"suspend\",                \"replace-irreversibly\" },\n        [ACTION_HIBERNATE]            = { SPECIAL_HIBERNATE_TARGET,                \"hibernate\",              \"replace-irreversibly\" },\n        [ACTION_HYBRID_SLEEP]         = { SPECIAL_HYBRID_SLEEP_TARGET,             \"hybrid-sleep\",           \"replace-irreversibly\" },\n        [ACTION_SUSPEND_THEN_HIBERNATE] = { SPECIAL_SUSPEND_THEN_HIBERNATE_TARGET, \"suspend-then-hibernate\", \"replace-irreversibly\" },\n};\n\nstatic enum action verb_to_action(const char *verb) {\n        enum action i;\n\n        for (i = 0; i < _ACTION_MAX; i++)\n                if (streq_ptr(action_table[i].verb, verb))\n                        return i;\n\n        return _ACTION_INVALID;\n}\n\nstatic int start_unit(int argc, char *argv[], void *userdata) {\n        _cleanup_(bus_wait_for_jobs_freep) BusWaitForJobs *w = NULL;\n        const char *method, *mode, *one_name, *suffix = NULL;\n        _cleanup_strv_free_ char **names = NULL;\n        sd_bus *bus;\n        _cleanup_(wait_context_free) WaitContext wait_context = {};\n        char **name;\n        int r = 0;\n\n        if (arg_wait && !STR_IN_SET(argv[0], \"start\", \"restart\")) {\n                log_error(\"--wait may only be used with the 'start' or 'restart' commands.\");\n                return -EINVAL;\n        }\n\n        /* we cannot do sender tracking on the private bus, so we need the full\n         * one for RefUnit to implement --wait */\n        r = acquire_bus(arg_wait ? BUS_FULL : BUS_MANAGER, &bus);\n        if (r < 0)\n                return r;\n\n        ask_password_agent_open_if_enabled();\n        polkit_agent_open_maybe();\n\n        if (arg_action == ACTION_SYSTEMCTL) {\n                enum action action;\n\n                action = verb_to_action(argv[0]);\n\n                if (action != _ACTION_INVALID) {\n                        method = \"StartUnit\";\n                        mode = action_table[action].mode;\n                        one_name = action_table[action].target;\n                } else {\n                        if (streq(argv[0], \"isolate\")) {\n                                method = \"StartUnit\";\n                                mode = \"isolate\";\n\n                                suffix = \".target\";\n                        } else {\n                                method = verb_to_method(argv[0]);\n                                mode = arg_job_mode;\n                        }\n                        one_name = NULL;\n                }\n        } else {\n                assert(arg_action >= 0 && arg_action < _ACTION_MAX);\n                assert(action_table[arg_action].target);\n                assert(action_table[arg_action].mode);\n\n                method = \"StartUnit\";\n                mode = action_table[arg_action].mode;\n                one_name = action_table[arg_action].target;\n        }\n\n        if (one_name)\n                names = strv_new(one_name, NULL);\n        else {\n                r = expand_names(bus, strv_skip(argv, 1), suffix, &names);\n                if (r < 0)\n                        return log_error_errno(r, \"Failed to expand names: %m\");\n        }\n\n        if (!arg_no_block) {\n                r = bus_wait_for_jobs_new(bus, &w);\n                if (r < 0)\n                        return log_error_errno(r, \"Could not watch jobs: %m\");\n        }\n\n        if (arg_wait) {\n                wait_context.unit_paths = set_new(&string_hash_ops);\n                if (!wait_context.unit_paths)\n                        return log_oom();\n\n                r = sd_bus_call_method_async(\n                                bus,\n                                NULL,\n                                \"org.freedesktop.systemd1\",\n                                \"/org/freedesktop/systemd1\",\n                                \"org.freedesktop.systemd1.Manager\",\n                                \"Subscribe\",\n                                NULL, NULL,\n                                NULL);\n                if (r < 0)\n                        return log_error_errno(r, \"Failed to enable subscription: %m\");\n                r = sd_event_default(&wait_context.event);\n                if (r < 0)\n                        return log_error_errno(r, \"Failed to allocate event loop: %m\");\n                r = sd_bus_attach_event(bus, wait_context.event, 0);\n                if (r < 0)\n                        return log_error_errno(r, \"Failed to attach bus to event loop: %m\");\n        }\n\n        STRV_FOREACH(name, names) {\n                _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n                int q;\n\n                q = start_unit_one(bus, method, *name, mode, &error, w, arg_wait ? &wait_context : NULL);\n                if (r >= 0 && q < 0)\n                        r = translate_bus_error_to_exit_status(q, &error);\n        }\n\n        if (!arg_no_block) {\n                int q, arg_count = 0;\n                const char* extra_args[4] = {};\n\n                if (arg_scope != UNIT_FILE_SYSTEM)\n                        extra_args[arg_count++] = \"--user\";\n\n                assert(IN_SET(arg_transport, BUS_TRANSPORT_LOCAL, BUS_TRANSPORT_REMOTE, BUS_TRANSPORT_MACHINE));\n                if (arg_transport == BUS_TRANSPORT_REMOTE) {\n                        extra_args[arg_count++] = \"-H\";\n                        extra_args[arg_count++] = arg_host;\n                } else if (arg_transport == BUS_TRANSPORT_MACHINE) {\n                        extra_args[arg_count++] = \"-M\";\n                        extra_args[arg_count++] = arg_host;\n                }\n\n                q = bus_wait_for_jobs(w, arg_quiet, extra_args);\n                if (q < 0)\n                        return q;\n\n                /* When stopping units, warn if they can still be triggered by\n                 * another active unit (socket, path, timer) */\n                if (!arg_quiet && streq(method, \"StopUnit\"))\n                        STRV_FOREACH(name, names)\n                                check_triggering_units(bus, *name);\n        }\n\n        if (r >= 0 && arg_wait) {\n                int q;\n                q = sd_event_loop(wait_context.event);\n                if (q < 0)\n                        return log_error_errno(q, \"Failed to run event loop: %m\");\n                if (wait_context.any_failed)\n                        r = EXIT_FAILURE;\n        }\n\n        return r;\n}\n\n#if ENABLE_LOGIND\nstatic int logind_set_wall_message(void) {\n        _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n        sd_bus *bus;\n        _cleanup_free_ char *m = NULL;\n        int r;\n\n        r = acquire_bus(BUS_FULL, &bus);\n        if (r < 0)\n                return r;\n\n        m = strv_join(arg_wall, \" \");\n        if (!m)\n                return log_oom();\n\n        log_debug(\"%s wall message \\\"%s\\\".\", arg_dry_run ? \"Would set\" : \"Setting\", m);\n        if (arg_dry_run)\n                return 0;\n\n        r = sd_bus_call_method(\n                        bus,\n                        \"org.freedesktop.login1\",\n                        \"/org/freedesktop/login1\",\n                        \"org.freedesktop.login1.Manager\",\n                        \"SetWallMessage\",\n                        &error,\n                        NULL,\n                        \"sb\",\n                        m,\n                        !arg_no_wall);\n\n        if (r < 0)\n                return log_warning_errno(r, \"Failed to set wall message, ignoring: %s\", bus_error_message(&error, r));\n        return 0;\n}\n#endif\n\n/* Ask systemd-logind, which might grant access to unprivileged users\n * through PolicyKit */\nstatic int logind_reboot(enum action a) {\n#if ENABLE_LOGIND\n        _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n        const char *method, *description;\n        sd_bus *bus;\n        int r;\n\n        r = acquire_bus(BUS_FULL, &bus);\n        if (r < 0)\n                return r;\n\n        switch (a) {\n\n        case ACTION_POWEROFF:\n                method = \"PowerOff\";\n                description = \"power off system\";\n                break;\n\n        case ACTION_REBOOT:\n                method = \"Reboot\";\n                description = \"reboot system\";\n                break;\n\n        case ACTION_HALT:\n                method = \"Halt\";\n                description = \"halt system\";\n                break;\n\n        case ACTION_SUSPEND:\n                method = \"Suspend\";\n                description = \"suspend system\";\n                break;\n\n        case ACTION_HIBERNATE:\n                method = \"Hibernate\";\n                description = \"hibernate system\";\n                break;\n\n        case ACTION_HYBRID_SLEEP:\n                method = \"HybridSleep\";\n                description = \"put system into hybrid sleep\";\n                break;\n\n        case ACTION_SUSPEND_THEN_HIBERNATE:\n                method = \"SuspendThenHibernate\";\n                description = \"put system into suspend followed by hibernate\";\n                break;\n\n        default:\n                return -EINVAL;\n        }\n\n        polkit_agent_open_maybe();\n        (void) logind_set_wall_message();\n\n        log_debug(\"%s org.freedesktop.login1.Manager %s dbus call.\", arg_dry_run ? \"Would execute\" : \"Executing\", method);\n        if (arg_dry_run)\n                return 0;\n\n        r = sd_bus_call_method(\n                        bus,\n                        \"org.freedesktop.login1\",\n                        \"/org/freedesktop/login1\",\n                        \"org.freedesktop.login1.Manager\",\n                        method,\n                        &error,\n                        NULL,\n                        \"b\", arg_ask_password);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to %s via logind: %s\", description, bus_error_message(&error, r));\n\n        return 0;\n#else\n        return -ENOSYS;\n#endif\n}\n\nstatic int logind_check_inhibitors(enum action a) {\n#if ENABLE_LOGIND\n        _cleanup_(sd_bus_message_unrefp) sd_bus_message *reply = NULL;\n        _cleanup_strv_free_ char **sessions = NULL;\n        const char *what, *who, *why, *mode;\n        uint32_t uid, pid;\n        sd_bus *bus;\n        unsigned c = 0;\n        char **s;\n        int r;\n\n        if (arg_ignore_inhibitors || arg_force > 0)\n                return 0;\n\n        if (arg_when > 0)\n                return 0;\n\n        if (geteuid() == 0)\n                return 0;\n\n        if (!on_tty())\n                return 0;\n\n        if (arg_transport != BUS_TRANSPORT_LOCAL)\n                return 0;\n\n        r = acquire_bus(BUS_FULL, &bus);\n        if (r < 0)\n                return r;\n\n        r = sd_bus_call_method(\n                        bus,\n                        \"org.freedesktop.login1\",\n                        \"/org/freedesktop/login1\",\n                        \"org.freedesktop.login1.Manager\",\n                        \"ListInhibitors\",\n                        NULL,\n                        &reply,\n                        NULL);\n        if (r < 0)\n                /* If logind is not around, then there are no inhibitors... */\n                return 0;\n\n        r = sd_bus_message_enter_container(reply, SD_BUS_TYPE_ARRAY, \"(ssssuu)\");\n        if (r < 0)\n                return bus_log_parse_error(r);\n\n        while ((r = sd_bus_message_read(reply, \"(ssssuu)\", &what, &who, &why, &mode, &uid, &pid)) > 0) {\n                _cleanup_free_ char *comm = NULL, *user = NULL;\n                _cleanup_strv_free_ char **sv = NULL;\n\n                if (!streq(mode, \"block\"))\n                        continue;\n\n                sv = strv_split(what, \":\");\n                if (!sv)\n                        return log_oom();\n\n                if (!pid_is_valid((pid_t) pid)) {\n                        log_error(\"Invalid PID \"PID_FMT\".\", (pid_t) pid);\n                        return -ERANGE;\n                }\n\n                if (!strv_contains(sv,\n                                   IN_SET(a,\n                                          ACTION_HALT,\n                                          ACTION_POWEROFF,\n                                          ACTION_REBOOT,\n                                          ACTION_KEXEC) ? \"shutdown\" : \"sleep\"))\n                        continue;\n\n                get_process_comm(pid, &comm);\n                user = uid_to_name(uid);\n\n                log_warning(\"Operation inhibited by \\\"%s\\\" (PID \"PID_FMT\" \\\"%s\\\", user %s), reason is \\\"%s\\\".\",\n                            who, (pid_t) pid, strna(comm), strna(user), why);\n\n                c++;\n        }\n        if (r < 0)\n                return bus_log_parse_error(r);\n\n        r = sd_bus_message_exit_container(reply);\n        if (r < 0)\n                return bus_log_parse_error(r);\n\n        /* Check for current sessions */\n        sd_get_sessions(&sessions);\n        STRV_FOREACH(s, sessions) {\n                _cleanup_free_ char *type = NULL, *tty = NULL, *seat = NULL, *user = NULL, *service = NULL, *class = NULL;\n\n                if (sd_session_get_uid(*s, &uid) < 0 || uid == getuid())\n                        continue;\n\n                if (sd_session_get_class(*s, &class) < 0 || !streq(class, \"user\"))\n                        continue;\n\n                if (sd_session_get_type(*s, &type) < 0 || !STR_IN_SET(type, \"x11\", \"wayland\", \"tty\", \"mir\"))\n                        continue;\n\n                sd_session_get_tty(*s, &tty);\n                sd_session_get_seat(*s, &seat);\n                sd_session_get_service(*s, &service);\n                user = uid_to_name(uid);\n\n                log_warning(\"User %s is logged in on %s.\", strna(user), isempty(tty) ? (isempty(seat) ? strna(service) : seat) : tty);\n                c++;\n        }\n\n        if (c <= 0)\n                return 0;\n\n        log_error(\"Please retry operation after closing inhibitors and logging out other users.\\nAlternatively, ignore inhibitors and users with 'systemctl %s -i'.\",\n                  action_table[a].verb);\n\n        return -EPERM;\n#else\n        return 0;\n#endif\n}\n\nstatic int logind_prepare_firmware_setup(void) {\n#if ENABLE_LOGIND\n        _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n        sd_bus *bus;\n        int r;\n\n        r = acquire_bus(BUS_FULL, &bus);\n        if (r < 0)\n                return r;\n\n        r = sd_bus_call_method(\n                        bus,\n                        \"org.freedesktop.login1\",\n                        \"/org/freedesktop/login1\",\n                        \"org.freedesktop.login1.Manager\",\n                        \"SetRebootToFirmwareSetup\",\n                        &error,\n                        NULL,\n                        \"b\", true);\n        if (r < 0)\n                return log_error_errno(r, \"Cannot indicate to EFI to boot into setup mode: %s\", bus_error_message(&error, r));\n\n        return 0;\n#else\n        log_error(\"Cannot remotely indicate to EFI to boot into setup mode.\");\n        return -ENOSYS;\n#endif\n}\n\nstatic int prepare_firmware_setup(void) {\n        int r;\n\n        if (!arg_firmware_setup)\n                return 0;\n\n        if (arg_transport == BUS_TRANSPORT_LOCAL) {\n\n                r = efi_set_reboot_to_firmware(true);\n                if (r < 0)\n                        log_debug_errno(r, \"Cannot indicate to EFI to boot into setup mode, will retry via logind: %m\");\n                else\n                        return r;\n        }\n\n        return logind_prepare_firmware_setup();\n}\n\nstatic int load_kexec_kernel(void) {\n        _cleanup_(boot_config_free) BootConfig config = {};\n        _cleanup_free_ char *where = NULL, *kernel = NULL, *initrd = NULL, *options = NULL;\n        const BootEntry *e;\n        pid_t pid;\n        int r;\n\n        if (kexec_loaded()) {\n                log_debug(\"Kexec kernel already loaded.\");\n                return 0;\n        }\n\n        if (access(KEXEC, X_OK) < 0)\n                return log_error_errno(errno, KEXEC\" is not available: %m\");\n\n        r = find_esp_and_warn(arg_esp_path, false, &where, NULL, NULL, NULL, NULL);\n        if (r == -ENOKEY) /* find_esp_and_warn() doesn't warn about this case */\n                return log_error_errno(r, \"Cannot find the ESP partition mount point.\");\n        if (r < 0) /* But it logs about all these cases, hence don't log here again */\n                return r;\n\n        r = boot_entries_load_config(where, &config);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to load bootspec config from \\\"%s/loader\\\": %m\", where);\n\n        if (config.default_entry < 0) {\n                log_error(\"No entry suitable as default, refusing to guess.\");\n                return -ENOENT;\n        }\n        e = &config.entries[config.default_entry];\n\n        if (strv_length(e->initrd) > 1) {\n                log_error(\"Boot entry specifies multiple initrds, which is not supported currently.\");\n                return -EINVAL;\n        }\n\n        kernel = path_join(NULL, where, e->kernel);\n        if (!strv_isempty(e->initrd))\n                initrd = path_join(NULL, where, *e->initrd);\n        options = strv_join(e->options, \" \");\n        if (!options)\n                return log_oom();\n\n        log_full(arg_quiet ? LOG_DEBUG : LOG_INFO,\n                 \"%s \"KEXEC\" --load \\\"%s\\\" --append \\\"%s\\\"%s%s%s\",\n                 arg_dry_run ? \"Would run\" : \"Running\",\n                 kernel,\n                 options,\n                 initrd ? \" --initrd \\\"\" : NULL, strempty(initrd), initrd ? \"\\\"\" : \"\");\n        if (arg_dry_run)\n                return 0;\n\n        r = safe_fork(\"(kexec)\", FORK_RESET_SIGNALS|FORK_DEATHSIG|FORK_LOG, &pid);\n        if (r < 0)\n                return r;\n        if (r == 0) {\n                const char* const args[] = {\n                        KEXEC,\n                        \"--load\", kernel,\n                        \"--append\", options,\n                        initrd ? \"--initrd\" : NULL, initrd,\n                        NULL };\n\n                /* Child */\n                execv(args[0], (char * const *) args);\n                _exit(EXIT_FAILURE);\n        }\n\n        r = wait_for_terminate_and_check(\"kexec\", pid, WAIT_LOG);\n        if (r < 0)\n                return r;\n        if (r > 0)\n                /* Command failed */\n                return -EPROTO;\n        return 0;\n}\n\nstatic int set_exit_code(uint8_t code) {\n        _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n        sd_bus *bus;\n        int r;\n\n        r = acquire_bus(BUS_MANAGER, &bus);\n        if (r < 0)\n                return r;\n\n        r = sd_bus_call_method(\n                        bus,\n                        \"org.freedesktop.systemd1\",\n                        \"/org/freedesktop/systemd1\",\n                        \"org.freedesktop.systemd1.Manager\",\n                        \"SetExitCode\",\n                        &error,\n                        NULL,\n                        \"y\", code);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to set exit code: %s\", bus_error_message(&error, r));\n\n        return 0;\n}\n\nstatic int start_special(int argc, char *argv[], void *userdata) {\n        enum action a;\n        int r;\n        bool termination_action; /* an action that terminates the manager,\n                                  * can be performed also by signal. */\n\n        assert(argv);\n\n        a = verb_to_action(argv[0]);\n\n        r = logind_check_inhibitors(a);\n        if (r < 0)\n                return r;\n\n        if (arg_force >= 2) {\n                r = must_be_root();\n                if (r < 0)\n                        return r;\n        }\n\n        r = prepare_firmware_setup();\n        if (r < 0)\n                return r;\n\n        if (a == ACTION_REBOOT && argc > 1) {\n                r = update_reboot_parameter_and_warn(argv[1]);\n                if (r < 0)\n                        return r;\n\n        } else if (a == ACTION_KEXEC) {\n                r = load_kexec_kernel();\n                if (r < 0 && arg_force >= 1)\n                        log_notice(\"Failed to load kexec kernel, continuing without.\");\n                else if (r < 0)\n                        return r;\n\n        } else if (a == ACTION_EXIT && argc > 1) {\n                uint8_t code;\n\n                /* If the exit code is not given on the command line,\n                 * don't reset it to zero: just keep it as it might\n                 * have been set previously. */\n\n                r = safe_atou8(argv[1], &code);\n                if (r < 0)\n                        return log_error_errno(r, \"Invalid exit code.\");\n\n                r = set_exit_code(code);\n                if (r < 0)\n                        return r;\n        }\n\n        termination_action = IN_SET(a,\n                                    ACTION_HALT,\n                                    ACTION_POWEROFF,\n                                    ACTION_REBOOT);\n        if (termination_action && arg_force >= 2)\n                return halt_now(a);\n\n        if (arg_force >= 1 &&\n            (termination_action || IN_SET(a, ACTION_KEXEC, ACTION_EXIT)))\n                r = trivial_method(argc, argv, userdata);\n        else {\n                /* First try logind, to allow authentication with polkit */\n                if (IN_SET(a,\n                           ACTION_POWEROFF,\n                           ACTION_REBOOT,\n                           ACTION_HALT,\n                           ACTION_SUSPEND,\n                           ACTION_HIBERNATE,\n                           ACTION_HYBRID_SLEEP,\n                           ACTION_SUSPEND_THEN_HIBERNATE)) {\n\n                        r = logind_reboot(a);\n                        if (r >= 0)\n                                return r;\n                        if (IN_SET(r, -EOPNOTSUPP, -EINPROGRESS))\n                                /* requested operation is not supported or already in progress */\n                                return r;\n\n                        /* On all other errors, try low-level operation. In order to minimize the difference between\n                         * operation with and without logind, we explicitly enable non-blocking mode for this, as\n                         * logind's shutdown operations are always non-blocking. */\n\n                        arg_no_block = true;\n\n                } else if (IN_SET(a, ACTION_EXIT, ACTION_KEXEC))\n                        /* Since exit/kexec are so close in behaviour to power-off/reboot, let's also make them\n                         * asynchronous, in order to not confuse the user needlessly with unexpected behaviour. */\n                        arg_no_block = true;\n\n                r = start_unit(argc, argv, userdata);\n        }\n\n        if (termination_action && arg_force < 2 &&\n            IN_SET(r, -ENOENT, -ETIMEDOUT))\n                log_notice(\"It is possible to perform action directly, see discussion of --force --force in man:systemctl(1).\");\n\n        return r;\n}\n\nstatic int start_system_special(int argc, char *argv[], void *userdata) {\n        /* Like start_special above, but raises an error when running in user mode */\n\n        if (arg_scope != UNIT_FILE_SYSTEM) {\n                log_error(\"Bad action for %s mode.\",\n                          arg_scope == UNIT_FILE_GLOBAL ? \"--global\" : \"--user\");\n                return -EINVAL;\n        }\n\n        return start_special(argc, argv, userdata);\n}\n\nstatic int check_unit_generic(int code, const UnitActiveState good_states[], int nb_states, char **args) {\n        _cleanup_strv_free_ char **names = NULL;\n        UnitActiveState active_state;\n        sd_bus *bus;\n        char **name;\n        int r, i;\n        bool found = false;\n\n        r = acquire_bus(BUS_MANAGER, &bus);\n        if (r < 0)\n                return r;\n\n        r = expand_names(bus, args, NULL, &names);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to expand names: %m\");\n\n        STRV_FOREACH(name, names) {\n                r = get_state_one_unit(bus, *name, &active_state);\n                if (r < 0)\n                        return r;\n\n                if (!arg_quiet)\n                        puts(unit_active_state_to_string(active_state));\n\n                for (i = 0; i < nb_states; ++i)\n                        if (good_states[i] == active_state)\n                                found = true;\n        }\n\n        /* use the given return code for the case that we won't find\n         * any unit which matches the list */\n        return found ? 0 : code;\n}\n\nstatic int check_unit_active(int argc, char *argv[], void *userdata) {\n        const UnitActiveState states[] = { UNIT_ACTIVE, UNIT_RELOADING };\n        /* According to LSB: 3, \"program is not running\" */\n        return check_unit_generic(EXIT_PROGRAM_NOT_RUNNING, states, ELEMENTSOF(states), strv_skip(argv, 1));\n}\n\nstatic int check_unit_failed(int argc, char *argv[], void *userdata) {\n        const UnitActiveState states[] = { UNIT_FAILED };\n        return check_unit_generic(EXIT_PROGRAM_DEAD_AND_PID_EXISTS, states, ELEMENTSOF(states), strv_skip(argv, 1));\n}\n\nstatic int kill_unit(int argc, char *argv[], void *userdata) {\n        _cleanup_strv_free_ char **names = NULL;\n        char *kill_who = NULL, **name;\n        sd_bus *bus;\n        int r, q;\n\n        r = acquire_bus(BUS_MANAGER, &bus);\n        if (r < 0)\n                return r;\n\n        polkit_agent_open_maybe();\n\n        if (!arg_kill_who)\n                arg_kill_who = \"all\";\n\n        /* --fail was specified */\n        if (streq(arg_job_mode, \"fail\"))\n                kill_who = strjoina(arg_kill_who, \"-fail\");\n\n        r = expand_names(bus, strv_skip(argv, 1), NULL, &names);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to expand names: %m\");\n\n        STRV_FOREACH(name, names) {\n                _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n\n                q = sd_bus_call_method(\n                                bus,\n                                \"org.freedesktop.systemd1\",\n                                \"/org/freedesktop/systemd1\",\n                                \"org.freedesktop.systemd1.Manager\",\n                                \"KillUnit\",\n                                &error,\n                                NULL,\n                                \"ssi\", *name, kill_who ? kill_who : arg_kill_who, arg_signal);\n                if (q < 0) {\n                        log_error_errno(q, \"Failed to kill unit %s: %s\", *name, bus_error_message(&error, q));\n                        if (r == 0)\n                                r = q;\n                }\n        }\n\n        return r;\n}\n\ntypedef struct ExecStatusInfo {\n        char *name;\n\n        char *path;\n        char **argv;\n\n        bool ignore;\n\n        usec_t start_timestamp;\n        usec_t exit_timestamp;\n        pid_t pid;\n        int code;\n        int status;\n\n        LIST_FIELDS(struct ExecStatusInfo, exec);\n} ExecStatusInfo;\n\nstatic void exec_status_info_free(ExecStatusInfo *i) {\n        assert(i);\n\n        free(i->name);\n        free(i->path);\n        strv_free(i->argv);\n        free(i);\n}\n\nstatic int exec_status_info_deserialize(sd_bus_message *m, ExecStatusInfo *i) {\n        uint64_t start_timestamp, exit_timestamp, start_timestamp_monotonic, exit_timestamp_monotonic;\n        const char *path;\n        uint32_t pid;\n        int32_t code, status;\n        int ignore, r;\n\n        assert(m);\n        assert(i);\n\n        r = sd_bus_message_enter_container(m, SD_BUS_TYPE_STRUCT, \"sasbttttuii\");\n        if (r < 0)\n                return bus_log_parse_error(r);\n        else if (r == 0)\n                return 0;\n\n        r = sd_bus_message_read(m, \"s\", &path);\n        if (r < 0)\n                return bus_log_parse_error(r);\n\n        i->path = strdup(path);\n        if (!i->path)\n                return log_oom();\n\n        r = sd_bus_message_read_strv(m, &i->argv);\n        if (r < 0)\n                return bus_log_parse_error(r);\n\n        r = sd_bus_message_read(m,\n                                \"bttttuii\",\n                                &ignore,\n                                &start_timestamp, &start_timestamp_monotonic,\n                                &exit_timestamp, &exit_timestamp_monotonic,\n                                &pid,\n                                &code, &status);\n        if (r < 0)\n                return bus_log_parse_error(r);\n\n        i->ignore = ignore;\n        i->start_timestamp = (usec_t) start_timestamp;\n        i->exit_timestamp = (usec_t) exit_timestamp;\n        i->pid = (pid_t) pid;\n        i->code = code;\n        i->status = status;\n\n        r = sd_bus_message_exit_container(m);\n        if (r < 0)\n                return bus_log_parse_error(r);\n\n        return 1;\n}\n\ntypedef struct UnitCondition {\n        char *name;\n        char *param;\n        bool trigger;\n        bool negate;\n        int tristate;\n\n        LIST_FIELDS(struct UnitCondition, conditions);\n} UnitCondition;\n\nstatic void unit_condition_free(UnitCondition *c) {\n        if (!c)\n                return;\n\n        free(c->name);\n        free(c->param);\n        free(c);\n}\n\nDEFINE_TRIVIAL_CLEANUP_FUNC(UnitCondition*, unit_condition_free);\n\ntypedef struct UnitStatusInfo {\n        const char *id;\n        const char *load_state;\n        const char *active_state;\n        const char *sub_state;\n        const char *unit_file_state;\n        const char *unit_file_preset;\n\n        const char *description;\n        const char *following;\n\n        char **documentation;\n\n        const char *fragment_path;\n        const char *source_path;\n        const char *control_group;\n\n        char **dropin_paths;\n\n        const char *load_error;\n        const char *result;\n\n        usec_t inactive_exit_timestamp;\n        usec_t inactive_exit_timestamp_monotonic;\n        usec_t active_enter_timestamp;\n        usec_t active_exit_timestamp;\n        usec_t inactive_enter_timestamp;\n\n        bool need_daemon_reload;\n        bool transient;\n\n        /* Service */\n        pid_t main_pid;\n        pid_t control_pid;\n        const char *status_text;\n        const char *pid_file;\n        bool running:1;\n        int status_errno;\n\n        usec_t start_timestamp;\n        usec_t exit_timestamp;\n\n        int exit_code, exit_status;\n\n        usec_t condition_timestamp;\n        bool condition_result;\n        LIST_HEAD(UnitCondition, conditions);\n\n        usec_t assert_timestamp;\n        bool assert_result;\n        bool failed_assert_trigger;\n        bool failed_assert_negate;\n        const char *failed_assert;\n        const char *failed_assert_parameter;\n        usec_t next_elapse_real;\n        usec_t next_elapse_monotonic;\n\n        /* Socket */\n        unsigned n_accepted;\n        unsigned n_connections;\n        unsigned n_refused;\n        bool accept;\n\n        /* Pairs of type, path */\n        char **listen;\n\n        /* Device */\n        const char *sysfs_path;\n\n        /* Mount, Automount */\n        const char *where;\n\n        /* Swap */\n        const char *what;\n\n        /* CGroup */\n        uint64_t memory_current;\n        uint64_t memory_low;\n        uint64_t memory_high;\n        uint64_t memory_max;\n        uint64_t memory_swap_max;\n        uint64_t memory_limit;\n        uint64_t cpu_usage_nsec;\n        uint64_t tasks_current;\n        uint64_t tasks_max;\n\n        uint64_t ip_ingress_bytes;\n        uint64_t ip_egress_bytes;\n\n        LIST_HEAD(ExecStatusInfo, exec);\n} UnitStatusInfo;\n\nstatic void unit_status_info_free(UnitStatusInfo *info) {\n        ExecStatusInfo *p;\n        UnitCondition *c;\n\n        strv_free(info->documentation);\n        strv_free(info->dropin_paths);\n        strv_free(info->listen);\n\n        while ((c = info->conditions)) {\n                LIST_REMOVE(conditions, info->conditions, c);\n                unit_condition_free(c);\n        }\n\n        while ((p = info->exec)) {\n                LIST_REMOVE(exec, info->exec, p);\n                exec_status_info_free(p);\n        }\n}\n\nstatic void print_status_info(\n                sd_bus *bus,\n                UnitStatusInfo *i,\n                bool *ellipsized) {\n\n        char since1[FORMAT_TIMESTAMP_RELATIVE_MAX], since2[FORMAT_TIMESTAMP_MAX];\n        const char *s1, *s2, *active_on, *active_off, *on, *off, *ss;\n        _cleanup_free_ char *formatted_path = NULL;\n        ExecStatusInfo *p;\n        usec_t timestamp;\n        const char *path;\n        char **t, **t2;\n        int r;\n\n        assert(i);\n\n        /* This shows pretty information about a unit. See\n         * print_property() for a low-level property printer */\n\n        if (streq_ptr(i->active_state, \"failed\")) {\n                active_on = ansi_highlight_red();\n                active_off = ansi_normal();\n        } else if (STRPTR_IN_SET(i->active_state, \"active\", \"reloading\")) {\n                active_on = ansi_highlight_green();\n                active_off = ansi_normal();\n        } else\n                active_on = active_off = \"\";\n\n        printf(\"%s%s%s %s\", active_on, special_glyph(BLACK_CIRCLE), active_off, strna(i->id));\n\n        if (i->description && !streq_ptr(i->id, i->description))\n                printf(\" - %s\", i->description);\n\n        printf(\"\\n\");\n\n        if (i->following)\n                printf(\"   Follow: unit currently follows state of %s\\n\", i->following);\n\n        if (STRPTR_IN_SET(i->load_state, \"error\", \"not-found\", \"bad-setting\")) {\n                on = ansi_highlight_red();\n                off = ansi_normal();\n        } else\n                on = off = \"\";\n\n        path = i->source_path ?: i->fragment_path;\n        if (path && terminal_urlify_path(path, NULL, &formatted_path) >= 0)\n                path = formatted_path;\n\n        if (!isempty(i->load_error))\n                printf(\"   Loaded: %s%s%s (Reason: %s)\\n\",\n                       on, strna(i->load_state), off, i->load_error);\n        else if (path && !isempty(i->unit_file_state) && !isempty(i->unit_file_preset) &&\n                 !STR_IN_SET(i->unit_file_state, \"generated\", \"transient\"))\n                printf(\"   Loaded: %s%s%s (%s; %s; vendor preset: %s)\\n\",\n                       on, strna(i->load_state), off, path, i->unit_file_state, i->unit_file_preset);\n        else if (path && !isempty(i->unit_file_state))\n                printf(\"   Loaded: %s%s%s (%s; %s)\\n\",\n                       on, strna(i->load_state), off, path, i->unit_file_state);\n        else if (path)\n                printf(\"   Loaded: %s%s%s (%s)\\n\",\n                       on, strna(i->load_state), off, path);\n        else\n                printf(\"   Loaded: %s%s%s\\n\",\n                       on, strna(i->load_state), off);\n\n        if (i->transient)\n                printf(\"Transient: yes\\n\");\n\n        if (!strv_isempty(i->dropin_paths)) {\n                _cleanup_free_ char *dir = NULL;\n                bool last = false;\n                char ** dropin;\n\n                STRV_FOREACH(dropin, i->dropin_paths) {\n                        _cleanup_free_ char *dropin_formatted = NULL;\n                        const char *df;\n\n                        if (!dir || last) {\n                                printf(dir ? \"           \" :\n                                             \"  Drop-In: \");\n\n                                dir = mfree(dir);\n\n                                dir = dirname_malloc(*dropin);\n                                if (!dir) {\n                                        log_oom();\n                                        return;\n                                }\n\n                                printf(\"%s\\n\"\n                                       \"           %s\", dir,\n                                       special_glyph(TREE_RIGHT));\n                        }\n\n                        last = ! (*(dropin + 1) && startswith(*(dropin + 1), dir));\n\n                        if (terminal_urlify_path(*dropin, basename(*dropin), &dropin_formatted) >= 0)\n                                df = dropin_formatted;\n                        else\n                                df = *dropin;\n\n                        printf(\"%s%s\", df, last ? \"\\n\" : \", \");\n                }\n        }\n\n        ss = streq_ptr(i->active_state, i->sub_state) ? NULL : i->sub_state;\n        if (ss)\n                printf(\"   Active: %s%s (%s)%s\",\n                       active_on, strna(i->active_state), ss, active_off);\n        else\n                printf(\"   Active: %s%s%s\",\n                       active_on, strna(i->active_state), active_off);\n\n        if (!isempty(i->result) && !streq(i->result, \"success\"))\n                printf(\" (Result: %s)\", i->result);\n\n        timestamp = STRPTR_IN_SET(i->active_state, \"active\", \"reloading\") ? i->active_enter_timestamp :\n                    STRPTR_IN_SET(i->active_state, \"inactive\", \"failed\")  ? i->inactive_enter_timestamp :\n                    STRPTR_IN_SET(i->active_state, \"activating\")          ? i->inactive_exit_timestamp :\n                                                                            i->active_exit_timestamp;\n\n        s1 = format_timestamp_relative(since1, sizeof(since1), timestamp);\n        s2 = format_timestamp(since2, sizeof(since2), timestamp);\n\n        if (s1)\n                printf(\" since %s; %s\\n\", s2, s1);\n        else if (s2)\n                printf(\" since %s\\n\", s2);\n        else\n                printf(\"\\n\");\n\n        if (endswith(i->id, \".timer\")) {\n                char tstamp1[FORMAT_TIMESTAMP_RELATIVE_MAX],\n                     tstamp2[FORMAT_TIMESTAMP_MAX];\n                const char *next_rel_time, *next_time;\n                dual_timestamp nw, next = {i->next_elapse_real,\n                                           i->next_elapse_monotonic};\n                usec_t next_elapse;\n\n                printf(\"  Trigger: \");\n\n                dual_timestamp_get(&nw);\n                next_elapse = calc_next_elapse(&nw, &next);\n                next_rel_time = format_timestamp_relative(tstamp1, sizeof tstamp1, next_elapse);\n                next_time = format_timestamp(tstamp2, sizeof tstamp2, next_elapse);\n\n                if (next_time && next_rel_time)\n                        printf(\"%s; %s\\n\", next_time, next_rel_time);\n                else\n                        printf(\"n/a\\n\");\n        }\n\n        if (!i->condition_result && i->condition_timestamp > 0) {\n                UnitCondition *c;\n                int n = 0;\n\n                s1 = format_timestamp_relative(since1, sizeof(since1), i->condition_timestamp);\n                s2 = format_timestamp(since2, sizeof(since2), i->condition_timestamp);\n\n                printf(\"Condition: start %scondition failed%s at %s%s%s\\n\",\n                       ansi_highlight_yellow(), ansi_normal(),\n                       s2, s1 ? \"; \" : \"\", strempty(s1));\n\n                LIST_FOREACH(conditions, c, i->conditions)\n                        if (c->tristate < 0)\n                                n++;\n\n                LIST_FOREACH(conditions, c, i->conditions)\n                        if (c->tristate < 0)\n                                printf(\"           %s %s=%s%s%s was not met\\n\",\n                                       --n ? special_glyph(TREE_BRANCH) : special_glyph(TREE_RIGHT),\n                                       c->name,\n                                       c->trigger ? \"|\" : \"\",\n                                       c->negate ? \"!\" : \"\",\n                                       c->param);\n        }\n\n        if (!i->assert_result && i->assert_timestamp > 0) {\n                s1 = format_timestamp_relative(since1, sizeof(since1), i->assert_timestamp);\n                s2 = format_timestamp(since2, sizeof(since2), i->assert_timestamp);\n\n                printf(\"   Assert: start %sassertion failed%s at %s%s%s\\n\",\n                       ansi_highlight_red(), ansi_normal(),\n                       s2, s1 ? \"; \" : \"\", strempty(s1));\n                if (i->failed_assert_trigger)\n                        printf(\"           none of the trigger assertions were met\\n\");\n                else if (i->failed_assert)\n                        printf(\"           %s=%s%s was not met\\n\",\n                               i->failed_assert,\n                               i->failed_assert_negate ? \"!\" : \"\",\n                               i->failed_assert_parameter);\n        }\n\n        if (i->sysfs_path)\n                printf(\"   Device: %s\\n\", i->sysfs_path);\n        if (i->where)\n                printf(\"    Where: %s\\n\", i->where);\n        if (i->what)\n                printf(\"     What: %s\\n\", i->what);\n\n        STRV_FOREACH(t, i->documentation) {\n                _cleanup_free_ char *formatted = NULL;\n                const char *q;\n\n                if (terminal_urlify(*t, NULL, &formatted) >= 0)\n                        q = formatted;\n                else\n                        q = *t;\n\n                printf(\" %*s %s\\n\", 9, t == i->documentation ? \"Docs:\" : \"\", q);\n        }\n\n        STRV_FOREACH_PAIR(t, t2, i->listen)\n                printf(\" %*s %s (%s)\\n\", 9, t == i->listen ? \"Listen:\" : \"\", *t2, *t);\n\n        if (i->accept) {\n                printf(\" Accepted: %u; Connected: %u;\", i->n_accepted, i->n_connections);\n                if (i->n_refused)\n                        printf(\" Refused: %u\", i->n_refused);\n                printf(\"\\n\");\n        }\n\n        LIST_FOREACH(exec, p, i->exec) {\n                _cleanup_free_ char *argv = NULL;\n                bool good;\n\n                /* Only show exited processes here */\n                if (p->code == 0)\n                        continue;\n\n                argv = strv_join(p->argv, \" \");\n                printf(\"  Process: \"PID_FMT\" %s=%s \", p->pid, p->name, strna(argv));\n\n                good = is_clean_exit(p->code, p->status, EXIT_CLEAN_DAEMON, NULL);\n                if (!good) {\n                        on = ansi_highlight_red();\n                        off = ansi_normal();\n                } else\n                        on = off = \"\";\n\n                printf(\"%s(code=%s, \", on, sigchld_code_to_string(p->code));\n\n                if (p->code == CLD_EXITED) {\n                        const char *c;\n\n                        printf(\"status=%i\", p->status);\n\n                        c = exit_status_to_string(p->status, EXIT_STATUS_SYSTEMD);\n                        if (c)\n                                printf(\"/%s\", c);\n\n                } else\n                        printf(\"signal=%s\", signal_to_string(p->status));\n\n                printf(\")%s\\n\", off);\n\n                if (i->main_pid == p->pid &&\n                    i->start_timestamp == p->start_timestamp &&\n                    i->exit_timestamp == p->start_timestamp)\n                        /* Let's not show this twice */\n                        i->main_pid = 0;\n\n                if (p->pid == i->control_pid)\n                        i->control_pid = 0;\n        }\n\n        if (i->main_pid > 0 || i->control_pid > 0) {\n                if (i->main_pid > 0) {\n                        printf(\" Main PID: \"PID_FMT, i->main_pid);\n\n                        if (i->running) {\n\n                                if (arg_transport == BUS_TRANSPORT_LOCAL) {\n                                        _cleanup_free_ char *comm = NULL;\n\n                                        (void) get_process_comm(i->main_pid, &comm);\n                                        if (comm)\n                                                printf(\" (%s)\", comm);\n                                }\n\n                        } else if (i->exit_code > 0) {\n                                printf(\" (code=%s, \", sigchld_code_to_string(i->exit_code));\n\n                                if (i->exit_code == CLD_EXITED) {\n                                        const char *c;\n\n                                        printf(\"status=%i\", i->exit_status);\n\n                                        c = exit_status_to_string(i->exit_status, EXIT_STATUS_SYSTEMD);\n                                        if (c)\n                                                printf(\"/%s\", c);\n\n                                } else\n                                        printf(\"signal=%s\", signal_to_string(i->exit_status));\n                                printf(\")\");\n                        }\n                }\n\n                if (i->control_pid > 0) {\n                        _cleanup_free_ char *c = NULL;\n\n                        if (i->main_pid > 0)\n                                fputs(\"; Control PID: \", stdout);\n                        else\n                                fputs(\"Cntrl PID: \", stdout); /* if first in column, abbreviated so it fits alignment */\n\n                        printf(PID_FMT, i->control_pid);\n\n                        if (arg_transport == BUS_TRANSPORT_LOCAL) {\n                                (void) get_process_comm(i->control_pid, &c);\n                                if (c)\n                                        printf(\" (%s)\", c);\n                        }\n                }\n\n                printf(\"\\n\");\n        }\n\n        if (i->status_text)\n                printf(\"   Status: \\\"%s\\\"\\n\", i->status_text);\n        if (i->status_errno > 0)\n                printf(\"    Error: %i (%s)\\n\", i->status_errno, strerror(i->status_errno));\n\n        if (i->ip_ingress_bytes != (uint64_t) -1 && i->ip_egress_bytes != (uint64_t) -1) {\n                char buf_in[FORMAT_BYTES_MAX], buf_out[FORMAT_BYTES_MAX];\n\n                printf(\"       IP: %s in, %s out\\n\",\n                        format_bytes(buf_in, sizeof(buf_in), i->ip_ingress_bytes),\n                        format_bytes(buf_out, sizeof(buf_out), i->ip_egress_bytes));\n        }\n\n        if (i->tasks_current != (uint64_t) -1) {\n                printf(\"    Tasks: %\" PRIu64, i->tasks_current);\n\n                if (i->tasks_max != (uint64_t) -1)\n                        printf(\" (limit: %\" PRIu64 \")\\n\", i->tasks_max);\n                else\n                        printf(\"\\n\");\n        }\n\n        if (i->memory_current != (uint64_t) -1) {\n                char buf[FORMAT_BYTES_MAX];\n\n                printf(\"   Memory: %s\", format_bytes(buf, sizeof(buf), i->memory_current));\n\n                if (i->memory_low > 0 || i->memory_high != CGROUP_LIMIT_MAX ||\n                    i->memory_max != CGROUP_LIMIT_MAX || i->memory_swap_max != CGROUP_LIMIT_MAX ||\n                    i->memory_limit != CGROUP_LIMIT_MAX) {\n                        const char *prefix = \"\";\n\n                        printf(\" (\");\n                        if (i->memory_low > 0) {\n                                printf(\"%slow: %s\", prefix, format_bytes(buf, sizeof(buf), i->memory_low));\n                                prefix = \" \";\n                        }\n                        if (i->memory_high != CGROUP_LIMIT_MAX) {\n                                printf(\"%shigh: %s\", prefix, format_bytes(buf, sizeof(buf), i->memory_high));\n                                prefix = \" \";\n                        }\n                        if (i->memory_max != CGROUP_LIMIT_MAX) {\n                                printf(\"%smax: %s\", prefix, format_bytes(buf, sizeof(buf), i->memory_max));\n                                prefix = \" \";\n                        }\n                        if (i->memory_swap_max != CGROUP_LIMIT_MAX) {\n                                printf(\"%sswap max: %s\", prefix, format_bytes(buf, sizeof(buf), i->memory_swap_max));\n                                prefix = \" \";\n                        }\n                        if (i->memory_limit != CGROUP_LIMIT_MAX) {\n                                printf(\"%slimit: %s\", prefix, format_bytes(buf, sizeof(buf), i->memory_limit));\n                                prefix = \" \";\n                        }\n                        printf(\")\");\n                }\n                printf(\"\\n\");\n        }\n\n        if (i->cpu_usage_nsec != (uint64_t) -1) {\n                char buf[FORMAT_TIMESPAN_MAX];\n                printf(\"      CPU: %s\\n\", format_timespan(buf, sizeof(buf), i->cpu_usage_nsec / NSEC_PER_USEC, USEC_PER_MSEC));\n        }\n\n        if (i->control_group) {\n                _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n                static const char prefix[] = \"           \";\n                unsigned c;\n\n                printf(\"   CGroup: %s\\n\", i->control_group);\n\n                c = columns();\n                if (c > sizeof(prefix) - 1)\n                        c -= sizeof(prefix) - 1;\n                else\n                        c = 0;\n\n                r = unit_show_processes(bus, i->id, i->control_group, prefix, c, get_output_flags(), &error);\n                if (r == -EBADR) {\n                        unsigned k = 0;\n                        pid_t extra[2];\n\n                        /* Fallback for older systemd versions where the GetUnitProcesses() call is not yet available */\n\n                        if (i->main_pid > 0)\n                                extra[k++] = i->main_pid;\n\n                        if (i->control_pid > 0)\n                                extra[k++] = i->control_pid;\n\n                        show_cgroup_and_extra(SYSTEMD_CGROUP_CONTROLLER, i->control_group, prefix, c, extra, k, get_output_flags());\n                } else if (r < 0)\n                        log_warning_errno(r, \"Failed to dump process list for '%s', ignoring: %s\", i->id, bus_error_message(&error, r));\n        }\n\n        if (i->id && arg_transport == BUS_TRANSPORT_LOCAL)\n                show_journal_by_unit(\n                                stdout,\n                                i->id,\n                                arg_output,\n                                0,\n                                i->inactive_exit_timestamp_monotonic,\n                                arg_lines,\n                                getuid(),\n                                get_output_flags() | OUTPUT_BEGIN_NEWLINE,\n                                SD_JOURNAL_LOCAL_ONLY,\n                                arg_scope == UNIT_FILE_SYSTEM,\n                                ellipsized);\n\n        if (i->need_daemon_reload)\n                warn_unit_file_changed(i->id);\n}\n\nstatic void show_unit_help(UnitStatusInfo *i) {\n        char **p;\n\n        assert(i);\n\n        if (!i->documentation) {\n                log_info(\"Documentation for %s not known.\", i->id);\n                return;\n        }\n\n        STRV_FOREACH(p, i->documentation)\n                if (startswith(*p, \"man:\"))\n                        show_man_page(*p + 4, false);\n                else\n                        log_info(\"Can't show: %s\", *p);\n}\n\nstatic int map_main_pid(sd_bus *bus, const char *member, sd_bus_message *m, sd_bus_error *error, void *userdata) {\n        UnitStatusInfo *i = userdata;\n        uint32_t u;\n        int r;\n\n        r = sd_bus_message_read(m, \"u\", &u);\n        if (r < 0)\n                return r;\n\n        i->main_pid = (pid_t) u;\n        i->running = u > 0;\n\n        return 0;\n}\n\nstatic int map_load_error(sd_bus *bus, const char *member, sd_bus_message *m, sd_bus_error *error, void *userdata) {\n        const char *message, **p = userdata;\n        int r;\n\n        r = sd_bus_message_read(m, \"(ss)\", NULL, &message);\n        if (r < 0)\n                return r;\n\n        if (!isempty(message))\n                *p = message;\n\n        return 0;\n}\n\nstatic int map_listen(sd_bus *bus, const char *member, sd_bus_message *m, sd_bus_error *error, void *userdata) {\n        const char *type, *path;\n        char ***p = userdata;\n        int r;\n\n        r = sd_bus_message_enter_container(m, SD_BUS_TYPE_ARRAY, \"(ss)\");\n        if (r < 0)\n                return r;\n\n        while ((r = sd_bus_message_read(m, \"(ss)\", &type, &path)) > 0) {\n\n                r = strv_extend(p, type);\n                if (r < 0)\n                        return r;\n\n                r = strv_extend(p, path);\n                if (r < 0)\n                        return r;\n        }\n        if (r < 0)\n                return r;\n\n        r = sd_bus_message_exit_container(m);\n        if (r < 0)\n                return r;\n\n        return 0;\n}\n\nstatic int map_conditions(sd_bus *bus, const char *member, sd_bus_message *m, sd_bus_error *error, void *userdata) {\n        UnitStatusInfo *i = userdata;\n        const char *cond, *param;\n        int trigger, negate;\n        int32_t state;\n        int r;\n\n        r = sd_bus_message_enter_container(m, SD_BUS_TYPE_ARRAY, \"(sbbsi)\");\n        if (r < 0)\n                return r;\n\n        while ((r = sd_bus_message_read(m, \"(sbbsi)\", &cond, &trigger, &negate, &param, &state)) > 0) {\n                _cleanup_(unit_condition_freep) UnitCondition *c = NULL;\n\n                c = new0(UnitCondition, 1);\n                if (!c)\n                        return -ENOMEM;\n\n                c->name = strdup(cond);\n                c->param = strdup(param);\n                if (!c->name || !c->param)\n                        return -ENOMEM;\n\n                c->trigger = trigger;\n                c->negate = negate;\n                c->tristate = state;\n\n                LIST_PREPEND(conditions, i->conditions, c);\n                c = NULL;\n        }\n        if (r < 0)\n                return r;\n\n        r = sd_bus_message_exit_container(m);\n        if (r < 0)\n                return r;\n\n        return 0;\n}\n\nstatic int map_asserts(sd_bus *bus, const char *member, sd_bus_message *m, sd_bus_error *error, void *userdata) {\n        UnitStatusInfo *i = userdata;\n        const char *cond, *param;\n        int trigger, negate;\n        int32_t state;\n        int r;\n\n        r = sd_bus_message_enter_container(m, SD_BUS_TYPE_ARRAY, \"(sbbsi)\");\n        if (r < 0)\n                return r;\n\n        while ((r = sd_bus_message_read(m, \"(sbbsi)\", &cond, &trigger, &negate, &param, &state)) > 0) {\n                if (state < 0 && (!trigger || !i->failed_assert)) {\n                        i->failed_assert = cond;\n                        i->failed_assert_trigger = trigger;\n                        i->failed_assert_negate = negate;\n                        i->failed_assert_parameter = param;\n                }\n        }\n        if (r < 0)\n                return r;\n\n        r = sd_bus_message_exit_container(m);\n        if (r < 0)\n                return r;\n\n        return 0;\n}\n\nstatic int map_exec(sd_bus *bus, const char *member, sd_bus_message *m, sd_bus_error *error, void *userdata) {\n        _cleanup_free_ ExecStatusInfo *info = NULL;\n        UnitStatusInfo *i = userdata;\n        int r;\n\n        r = sd_bus_message_enter_container(m, SD_BUS_TYPE_ARRAY, \"(sasbttttuii)\");\n        if (r < 0)\n                return r;\n\n        info = new0(ExecStatusInfo, 1);\n        if (!info)\n                return -ENOMEM;\n\n        while ((r = exec_status_info_deserialize(m, info)) > 0) {\n\n                info->name = strdup(member);\n                if (!info->name)\n                        return -ENOMEM;\n\n                LIST_PREPEND(exec, i->exec, info);\n\n                info = new0(ExecStatusInfo, 1);\n                if (!info)\n                        return -ENOMEM;\n        }\n        if (r < 0)\n                return r;\n\n        r = sd_bus_message_exit_container(m);\n        if (r < 0)\n                return r;\n\n        return 0;\n}\n\n#define print_prop(name, fmt, ...)                                      \\\n        do {                                                            \\\n                if (arg_value)                                          \\\n                        printf(fmt \"\\n\", __VA_ARGS__);                  \\\n                else                                                    \\\n                        printf(\"%s=\" fmt \"\\n\", name, __VA_ARGS__);      \\\n        } while (0)\n\nstatic int print_property(const char *name, sd_bus_message *m, bool value, bool all) {\n        char bus_type;\n        const char *contents;\n        int r;\n\n        assert(name);\n        assert(m);\n\n        /* This is a low-level property printer, see\n         * print_status_info() for the nicer output */\n\n        r = sd_bus_message_peek_type(m, &bus_type, &contents);\n        if (r < 0)\n                return r;\n\n        switch (bus_type) {\n\n        case SD_BUS_TYPE_STRUCT:\n\n                if (contents[0] == SD_BUS_TYPE_UINT32 && streq(name, \"Job\")) {\n                        uint32_t u;\n\n                        r = sd_bus_message_read(m, \"(uo)\", &u, NULL);\n                        if (r < 0)\n                                return bus_log_parse_error(r);\n\n                        if (u > 0)\n                                print_prop(name, \"%\"PRIu32, u);\n                        else if (all)\n                                print_prop(name, \"%s\", \"\");\n\n                        return 1;\n\n                } else if (contents[0] == SD_BUS_TYPE_STRING && streq(name, \"Unit\")) {\n                        const char *s;\n\n                        r = sd_bus_message_read(m, \"(so)\", &s, NULL);\n                        if (r < 0)\n                                return bus_log_parse_error(r);\n\n                        if (all || !isempty(s))\n                                print_prop(name, \"%s\", s);\n\n                        return 1;\n\n                } else if (contents[0] == SD_BUS_TYPE_STRING && streq(name, \"LoadError\")) {\n                        const char *a = NULL, *b = NULL;\n\n                        r = sd_bus_message_read(m, \"(ss)\", &a, &b);\n                        if (r < 0)\n                                return bus_log_parse_error(r);\n\n                        if (all || !isempty(a) || !isempty(b))\n                                print_prop(name, \"%s \\\"%s\\\"\", strempty(a), strempty(b));\n\n                        return 1;\n                } else if (streq_ptr(name, \"SystemCallFilter\")) {\n                        _cleanup_strv_free_ char **l = NULL;\n                        int whitelist;\n\n                        r = sd_bus_message_enter_container(m, 'r', \"bas\");\n                        if (r < 0)\n                                return bus_log_parse_error(r);\n\n                        r = sd_bus_message_read(m, \"b\", &whitelist);\n                        if (r < 0)\n                                return bus_log_parse_error(r);\n\n                        r = sd_bus_message_read_strv(m, &l);\n                        if (r < 0)\n                                return bus_log_parse_error(r);\n\n                        r = sd_bus_message_exit_container(m);\n                        if (r < 0)\n                                return bus_log_parse_error(r);\n\n                        if (all || whitelist || !strv_isempty(l)) {\n                                bool first = true;\n                                char **i;\n\n                                if (!value) {\n                                        fputs(name, stdout);\n                                        fputc('=', stdout);\n                                }\n\n                                if (!whitelist)\n                                        fputc('~', stdout);\n\n                                STRV_FOREACH(i, l) {\n                                        if (first)\n                                                first = false;\n                                        else\n                                                fputc(' ', stdout);\n\n                                        fputs(*i, stdout);\n                                }\n                                fputc('\\n', stdout);\n                        }\n\n                        return 1;\n                }\n\n                break;\n\n        case SD_BUS_TYPE_ARRAY:\n\n                if (contents[0] == SD_BUS_TYPE_STRUCT_BEGIN && streq(name, \"EnvironmentFiles\")) {\n                        const char *path;\n                        int ignore;\n\n                        r = sd_bus_message_enter_container(m, SD_BUS_TYPE_ARRAY, \"(sb)\");\n                        if (r < 0)\n                                return bus_log_parse_error(r);\n\n                        while ((r = sd_bus_message_read(m, \"(sb)\", &path, &ignore)) > 0)\n                                print_prop(name, \"%s (ignore_errors=%s)\", path, yes_no(ignore));\n\n                        if (r < 0)\n                                return bus_log_parse_error(r);\n\n                        r = sd_bus_message_exit_container(m);\n                        if (r < 0)\n                                return bus_log_parse_error(r);\n\n                        return 1;\n\n                } else if (contents[0] == SD_BUS_TYPE_STRUCT_BEGIN && streq(name, \"Paths\")) {\n                        const char *type, *path;\n\n                        r = sd_bus_message_enter_container(m, SD_BUS_TYPE_ARRAY, \"(ss)\");\n                        if (r < 0)\n                                return bus_log_parse_error(r);\n\n                        while ((r = sd_bus_message_read(m, \"(ss)\", &type, &path)) > 0)\n                                print_prop(name, \"%s (%s)\", path, type);\n                        if (r < 0)\n                                return bus_log_parse_error(r);\n\n                        r = sd_bus_message_exit_container(m);\n                        if (r < 0)\n                                return bus_log_parse_error(r);\n\n                        return 1;\n\n                } else if (contents[0] == SD_BUS_TYPE_STRUCT_BEGIN && streq(name, \"Listen\")) {\n                        const char *type, *path;\n\n                        r = sd_bus_message_enter_container(m, SD_BUS_TYPE_ARRAY, \"(ss)\");\n                        if (r < 0)\n                                return bus_log_parse_error(r);\n\n                        while ((r = sd_bus_message_read(m, \"(ss)\", &type, &path)) > 0)\n                                print_prop(name, \"%s (%s)\", path, type);\n                        if (r < 0)\n                                return bus_log_parse_error(r);\n\n                        r = sd_bus_message_exit_container(m);\n                        if (r < 0)\n                                return bus_log_parse_error(r);\n\n                        return 1;\n\n                } else if (contents[0] == SD_BUS_TYPE_STRUCT_BEGIN && streq(name, \"TimersMonotonic\")) {\n                        const char *base;\n                        uint64_t v, next_elapse;\n\n                        r = sd_bus_message_enter_container(m, SD_BUS_TYPE_ARRAY, \"(stt)\");\n                        if (r < 0)\n                                return bus_log_parse_error(r);\n\n                        while ((r = sd_bus_message_read(m, \"(stt)\", &base, &v, &next_elapse)) > 0) {\n                                char timespan1[FORMAT_TIMESPAN_MAX], timespan2[FORMAT_TIMESPAN_MAX];\n\n                                print_prop(name, \"{ %s=%s ; next_elapse=%s }\", base,\n                                           format_timespan(timespan1, sizeof(timespan1), v, 0),\n                                           format_timespan(timespan2, sizeof(timespan2), next_elapse, 0));\n                        }\n                        if (r < 0)\n                                return bus_log_parse_error(r);\n\n                        r = sd_bus_message_exit_container(m);\n                        if (r < 0)\n                                return bus_log_parse_error(r);\n\n                        return 1;\n\n                } else if (contents[0] == SD_BUS_TYPE_STRUCT_BEGIN && streq(name, \"TimersCalendar\")) {\n                        const char *base, *spec;\n                        uint64_t next_elapse;\n\n                        r = sd_bus_message_enter_container(m, SD_BUS_TYPE_ARRAY, \"(sst)\");\n                        if (r < 0)\n                                return bus_log_parse_error(r);\n\n                        while ((r = sd_bus_message_read(m, \"(sst)\", &base, &spec, &next_elapse)) > 0) {\n                                char timestamp[FORMAT_TIMESTAMP_MAX];\n\n                                print_prop(name, \"{ %s=%s ; next_elapse=%s }\", base, spec,\n                                           format_timestamp(timestamp, sizeof(timestamp), next_elapse));\n                        }\n                        if (r < 0)\n                                return bus_log_parse_error(r);\n\n                        r = sd_bus_message_exit_container(m);\n                        if (r < 0)\n                                return bus_log_parse_error(r);\n\n                        return 1;\n\n                } else if (contents[0] == SD_BUS_TYPE_STRUCT_BEGIN && startswith(name, \"Exec\")) {\n                        ExecStatusInfo info = {};\n\n                        r = sd_bus_message_enter_container(m, SD_BUS_TYPE_ARRAY, \"(sasbttttuii)\");\n                        if (r < 0)\n                                return bus_log_parse_error(r);\n\n                        while ((r = exec_status_info_deserialize(m, &info)) > 0) {\n                                char timestamp1[FORMAT_TIMESTAMP_MAX], timestamp2[FORMAT_TIMESTAMP_MAX];\n                                _cleanup_free_ char *tt;\n\n                                tt = strv_join(info.argv, \" \");\n\n                                print_prop(name,\n                                           \"{ path=%s ; argv[]=%s ; ignore_errors=%s ; start_time=[%s] ; stop_time=[%s] ; pid=\"PID_FMT\" ; code=%s ; status=%i%s%s }\",\n                                           strna(info.path),\n                                           strna(tt),\n                                           yes_no(info.ignore),\n                                           strna(format_timestamp(timestamp1, sizeof(timestamp1), info.start_timestamp)),\n                                           strna(format_timestamp(timestamp2, sizeof(timestamp2), info.exit_timestamp)),\n                                           info.pid,\n                                           sigchld_code_to_string(info.code),\n                                           info.status,\n                                           info.code == CLD_EXITED ? \"\" : \"/\",\n                                           strempty(info.code == CLD_EXITED ? NULL : signal_to_string(info.status)));\n\n                                free(info.path);\n                                strv_free(info.argv);\n                                zero(info);\n                        }\n\n                        r = sd_bus_message_exit_container(m);\n                        if (r < 0)\n                                return bus_log_parse_error(r);\n\n                        return 1;\n\n                } else if (contents[0] == SD_BUS_TYPE_STRUCT_BEGIN && streq(name, \"DeviceAllow\")) {\n                        const char *path, *rwm;\n\n                        r = sd_bus_message_enter_container(m, SD_BUS_TYPE_ARRAY, \"(ss)\");\n                        if (r < 0)\n                                return bus_log_parse_error(r);\n\n                        while ((r = sd_bus_message_read(m, \"(ss)\", &path, &rwm)) > 0)\n                                print_prop(name, \"%s %s\", strna(path), strna(rwm));\n                        if (r < 0)\n                                return bus_log_parse_error(r);\n\n                        r = sd_bus_message_exit_container(m);\n                        if (r < 0)\n                                return bus_log_parse_error(r);\n\n                        return 1;\n\n                } else if (contents[0] == SD_BUS_TYPE_STRUCT_BEGIN &&\n                           STR_IN_SET(name, \"IODeviceWeight\", \"BlockIODeviceWeight\")) {\n                        const char *path;\n                        uint64_t weight;\n\n                        r = sd_bus_message_enter_container(m, SD_BUS_TYPE_ARRAY, \"(st)\");\n                        if (r < 0)\n                                return bus_log_parse_error(r);\n\n                        while ((r = sd_bus_message_read(m, \"(st)\", &path, &weight)) > 0)\n                                print_prop(name, \"%s %\"PRIu64, strna(path), weight);\n                        if (r < 0)\n                                return bus_log_parse_error(r);\n\n                        r = sd_bus_message_exit_container(m);\n                        if (r < 0)\n                                return bus_log_parse_error(r);\n\n                        return 1;\n\n                } else if (contents[0] == SD_BUS_TYPE_STRUCT_BEGIN &&\n                           (cgroup_io_limit_type_from_string(name) >= 0 ||\n                            STR_IN_SET(name, \"BlockIOReadBandwidth\", \"BlockIOWriteBandwidth\"))) {\n                        const char *path;\n                        uint64_t bandwidth;\n\n                        r = sd_bus_message_enter_container(m, SD_BUS_TYPE_ARRAY, \"(st)\");\n                        if (r < 0)\n                                return bus_log_parse_error(r);\n\n                        while ((r = sd_bus_message_read(m, \"(st)\", &path, &bandwidth)) > 0)\n                                print_prop(name, \"%s %\"PRIu64, strna(path), bandwidth);\n                        if (r < 0)\n                                return bus_log_parse_error(r);\n\n                        r = sd_bus_message_exit_container(m);\n                        if (r < 0)\n                                return bus_log_parse_error(r);\n\n                        return 1;\n\n                } else if (contents[0] == SD_BUS_TYPE_BYTE && streq(name, \"StandardInputData\")) {\n                        _cleanup_free_ char *h = NULL;\n                        const void *p;\n                        size_t sz;\n                        ssize_t n;\n\n                        r = sd_bus_message_read_array(m, 'y', &p, &sz);\n                        if (r < 0)\n                                return bus_log_parse_error(r);\n\n                        n = base64mem(p, sz, &h);\n                        if (n < 0)\n                                return log_oom();\n\n                        print_prop(name, \"%s\", h);\n\n                        return 1;\n                }\n\n                break;\n        }\n\n        return 0;\n}\n\ntypedef enum SystemctlShowMode{\n        SYSTEMCTL_SHOW_PROPERTIES,\n        SYSTEMCTL_SHOW_STATUS,\n        SYSTEMCTL_SHOW_HELP,\n        _SYSTEMCTL_SHOW_MODE_MAX,\n        _SYSTEMCTL_SHOW_MODE_INVALID = -1,\n} SystemctlShowMode;\n\nstatic const char* const systemctl_show_mode_table[] = {\n        [SYSTEMCTL_SHOW_PROPERTIES] = \"show\",\n        [SYSTEMCTL_SHOW_STATUS] = \"status\",\n        [SYSTEMCTL_SHOW_HELP] = \"help\",\n};\n\nDEFINE_PRIVATE_STRING_TABLE_LOOKUP_FROM_STRING(systemctl_show_mode, SystemctlShowMode);\n\nstatic int show_one(\n                sd_bus *bus,\n                const char *path,\n                const char *unit,\n                SystemctlShowMode show_mode,\n                bool *new_line,\n                bool *ellipsized) {\n\n        static const struct bus_properties_map property_map[] = {\n                { \"LoadState\",                      \"s\",              NULL,           offsetof(UnitStatusInfo, load_state)                        },\n                { \"ActiveState\",                    \"s\",              NULL,           offsetof(UnitStatusInfo, active_state)                      },\n                { \"Documentation\",                  \"as\",             NULL,           offsetof(UnitStatusInfo, documentation)                     },\n                {}\n        }, status_map[] = {\n                { \"Id\",                             \"s\",              NULL,           offsetof(UnitStatusInfo, id)                                },\n                { \"LoadState\",                      \"s\",              NULL,           offsetof(UnitStatusInfo, load_state)                        },\n                { \"ActiveState\",                    \"s\",              NULL,           offsetof(UnitStatusInfo, active_state)                      },\n                { \"SubState\",                       \"s\",              NULL,           offsetof(UnitStatusInfo, sub_state)                         },\n                { \"UnitFileState\",                  \"s\",              NULL,           offsetof(UnitStatusInfo, unit_file_state)                   },\n                { \"UnitFilePreset\",                 \"s\",              NULL,           offsetof(UnitStatusInfo, unit_file_preset)                  },\n                { \"Description\",                    \"s\",              NULL,           offsetof(UnitStatusInfo, description)                       },\n                { \"Following\",                      \"s\",              NULL,           offsetof(UnitStatusInfo, following)                         },\n                { \"Documentation\",                  \"as\",             NULL,           offsetof(UnitStatusInfo, documentation)                     },\n                { \"FragmentPath\",                   \"s\",              NULL,           offsetof(UnitStatusInfo, fragment_path)                     },\n                { \"SourcePath\",                     \"s\",              NULL,           offsetof(UnitStatusInfo, source_path)                       },\n                { \"ControlGroup\",                   \"s\",              NULL,           offsetof(UnitStatusInfo, control_group)                     },\n                { \"DropInPaths\",                    \"as\",             NULL,           offsetof(UnitStatusInfo, dropin_paths)                      },\n                { \"LoadError\",                      \"(ss)\",           map_load_error, offsetof(UnitStatusInfo, load_error)                        },\n                { \"Result\",                         \"s\",              NULL,           offsetof(UnitStatusInfo, result)                            },\n                { \"InactiveExitTimestamp\",          \"t\",              NULL,           offsetof(UnitStatusInfo, inactive_exit_timestamp)           },\n                { \"InactiveExitTimestampMonotonic\", \"t\",              NULL,           offsetof(UnitStatusInfo, inactive_exit_timestamp_monotonic) },\n                { \"ActiveEnterTimestamp\",           \"t\",              NULL,           offsetof(UnitStatusInfo, active_enter_timestamp)            },\n                { \"ActiveExitTimestamp\",            \"t\",              NULL,           offsetof(UnitStatusInfo, active_exit_timestamp)             },\n                { \"InactiveEnterTimestamp\",         \"t\",              NULL,           offsetof(UnitStatusInfo, inactive_enter_timestamp)          },\n                { \"NeedDaemonReload\",               \"b\",              NULL,           offsetof(UnitStatusInfo, need_daemon_reload)                },\n                { \"Transient\",                      \"b\",              NULL,           offsetof(UnitStatusInfo, transient)                         },\n                { \"ExecMainPID\",                    \"u\",              NULL,           offsetof(UnitStatusInfo, main_pid)                          },\n                { \"MainPID\",                        \"u\",              map_main_pid,   0                                                           },\n                { \"ControlPID\",                     \"u\",              NULL,           offsetof(UnitStatusInfo, control_pid)                       },\n                { \"StatusText\",                     \"s\",              NULL,           offsetof(UnitStatusInfo, status_text)                       },\n                { \"PIDFile\",                        \"s\",              NULL,           offsetof(UnitStatusInfo, pid_file)                          },\n                { \"StatusErrno\",                    \"i\",              NULL,           offsetof(UnitStatusInfo, status_errno)                      },\n                { \"ExecMainStartTimestamp\",         \"t\",              NULL,           offsetof(UnitStatusInfo, start_timestamp)                   },\n                { \"ExecMainExitTimestamp\",          \"t\",              NULL,           offsetof(UnitStatusInfo, exit_timestamp)                    },\n                { \"ExecMainCode\",                   \"i\",              NULL,           offsetof(UnitStatusInfo, exit_code)                         },\n                { \"ExecMainStatus\",                 \"i\",              NULL,           offsetof(UnitStatusInfo, exit_status)                       },\n                { \"ConditionTimestamp\",             \"t\",              NULL,           offsetof(UnitStatusInfo, condition_timestamp)               },\n                { \"ConditionResult\",                \"b\",              NULL,           offsetof(UnitStatusInfo, condition_result)                  },\n                { \"Conditions\",                     \"a(sbbsi)\",       map_conditions, 0                                                           },\n                { \"AssertTimestamp\",                \"t\",              NULL,           offsetof(UnitStatusInfo, assert_timestamp)                  },\n                { \"AssertResult\",                   \"b\",              NULL,           offsetof(UnitStatusInfo, assert_result)                     },\n                { \"Asserts\",                        \"a(sbbsi)\",       map_asserts,    0                                                           },\n                { \"NextElapseUSecRealtime\",         \"t\",              NULL,           offsetof(UnitStatusInfo, next_elapse_real)                  },\n                { \"NextElapseUSecMonotonic\",        \"t\",              NULL,           offsetof(UnitStatusInfo, next_elapse_monotonic)             },\n                { \"NAccepted\",                      \"u\",              NULL,           offsetof(UnitStatusInfo, n_accepted)                        },\n                { \"NConnections\",                   \"u\",              NULL,           offsetof(UnitStatusInfo, n_connections)                     },\n                { \"NRefused\",                       \"u\",              NULL,           offsetof(UnitStatusInfo, n_refused)                         },\n                { \"Accept\",                         \"b\",              NULL,           offsetof(UnitStatusInfo, accept)                            },\n                { \"Listen\",                         \"a(ss)\",          map_listen,     offsetof(UnitStatusInfo, listen)                            },\n                { \"SysFSPath\",                      \"s\",              NULL,           offsetof(UnitStatusInfo, sysfs_path)                        },\n                { \"Where\",                          \"s\",              NULL,           offsetof(UnitStatusInfo, where)                             },\n                { \"What\",                           \"s\",              NULL,           offsetof(UnitStatusInfo, what)                              },\n                { \"MemoryCurrent\",                  \"t\",              NULL,           offsetof(UnitStatusInfo, memory_current)                    },\n                { \"MemoryLow\",                      \"t\",              NULL,           offsetof(UnitStatusInfo, memory_low)                        },\n                { \"MemoryHigh\",                     \"t\",              NULL,           offsetof(UnitStatusInfo, memory_high)                       },\n                { \"MemoryMax\",                      \"t\",              NULL,           offsetof(UnitStatusInfo, memory_max)                        },\n                { \"MemorySwapMax\",                  \"t\",              NULL,           offsetof(UnitStatusInfo, memory_swap_max)                   },\n                { \"MemoryLimit\",                    \"t\",              NULL,           offsetof(UnitStatusInfo, memory_limit)                      },\n                { \"CPUUsageNSec\",                   \"t\",              NULL,           offsetof(UnitStatusInfo, cpu_usage_nsec)                    },\n                { \"TasksCurrent\",                   \"t\",              NULL,           offsetof(UnitStatusInfo, tasks_current)                     },\n                { \"TasksMax\",                       \"t\",              NULL,           offsetof(UnitStatusInfo, tasks_max)                         },\n                { \"IPIngressBytes\",                 \"t\",              NULL,           offsetof(UnitStatusInfo, ip_ingress_bytes)                  },\n                { \"IPEgressBytes\",                  \"t\",              NULL,           offsetof(UnitStatusInfo, ip_egress_bytes)                   },\n                { \"ExecStartPre\",                   \"a(sasbttttuii)\", map_exec,       0                                                           },\n                { \"ExecStart\",                      \"a(sasbttttuii)\", map_exec,       0                                                           },\n                { \"ExecStartPost\",                  \"a(sasbttttuii)\", map_exec,       0                                                           },\n                { \"ExecReload\",                     \"a(sasbttttuii)\", map_exec,       0                                                           },\n                { \"ExecStopPre\",                    \"a(sasbttttuii)\", map_exec,       0                                                           },\n                { \"ExecStop\",                       \"a(sasbttttuii)\", map_exec,       0                                                           },\n                { \"ExecStopPost\",                   \"a(sasbttttuii)\", map_exec,       0                                                           },\n                {}\n        };\n\n        _cleanup_(sd_bus_message_unrefp) sd_bus_message *reply = NULL;\n        _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n        _cleanup_set_free_ Set *found_properties = NULL;\n        _cleanup_(unit_status_info_free) UnitStatusInfo info = {\n                .memory_current = (uint64_t) -1,\n                .memory_high = CGROUP_LIMIT_MAX,\n                .memory_max = CGROUP_LIMIT_MAX,\n                .memory_swap_max = CGROUP_LIMIT_MAX,\n                .memory_limit = (uint64_t) -1,\n                .cpu_usage_nsec = (uint64_t) -1,\n                .tasks_current = (uint64_t) -1,\n                .tasks_max = (uint64_t) -1,\n                .ip_ingress_bytes = (uint64_t) -1,\n                .ip_egress_bytes = (uint64_t) -1,\n        };\n        char **pp;\n        int r;\n\n        assert(path);\n        assert(new_line);\n\n        log_debug(\"Showing one %s\", path);\n\n        r = bus_map_all_properties(\n                        bus,\n                        \"org.freedesktop.systemd1\",\n                        path,\n                        show_mode == SYSTEMCTL_SHOW_STATUS ? status_map : property_map,\n                        BUS_MAP_BOOLEAN_AS_BOOL,\n                        &error,\n                        &reply,\n                        &info);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to get properties: %s\", bus_error_message(&error, r));\n\n        if (unit && streq_ptr(info.load_state, \"not-found\") && streq_ptr(info.active_state, \"inactive\")) {\n                log_full(show_mode == SYSTEMCTL_SHOW_STATUS ? LOG_ERR : LOG_DEBUG,\n                         \"Unit %s could not be found.\", unit);\n\n                if (show_mode == SYSTEMCTL_SHOW_STATUS)\n                        return EXIT_PROGRAM_OR_SERVICES_STATUS_UNKNOWN;\n                else if (show_mode == SYSTEMCTL_SHOW_HELP)\n                        return -ENOENT;\n        }\n\n        if (*new_line)\n                printf(\"\\n\");\n\n        *new_line = true;\n\n        if (show_mode == SYSTEMCTL_SHOW_STATUS) {\n                print_status_info(bus, &info, ellipsized);\n\n                if (info.active_state && !STR_IN_SET(info.active_state, \"active\", \"reloading\"))\n                        return EXIT_PROGRAM_NOT_RUNNING;\n\n                return EXIT_PROGRAM_RUNNING_OR_SERVICE_OK;\n\n        } else if (show_mode == SYSTEMCTL_SHOW_HELP) {\n                show_unit_help(&info);\n                return 0;\n        }\n\n        r = sd_bus_message_rewind(reply, true);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to rewind: %s\", bus_error_message(&error, r));\n\n        r = bus_message_print_all_properties(reply, print_property, arg_properties, arg_value, arg_all, &found_properties);\n        if (r < 0)\n                return bus_log_parse_error(r);\n\n        STRV_FOREACH(pp, arg_properties)\n                if (!set_contains(found_properties, *pp))\n                        log_debug(\"Property %s does not exist.\", *pp);\n\n        return 0;\n}\n\nstatic int get_unit_dbus_path_by_pid(\n                sd_bus *bus,\n                uint32_t pid,\n                char **unit) {\n\n        _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n        _cleanup_(sd_bus_message_unrefp) sd_bus_message *reply = NULL;\n        char *u;\n        int r;\n\n        r = sd_bus_call_method(\n                        bus,\n                        \"org.freedesktop.systemd1\",\n                        \"/org/freedesktop/systemd1\",\n                        \"org.freedesktop.systemd1.Manager\",\n                        \"GetUnitByPID\",\n                        &error,\n                        &reply,\n                        \"u\", pid);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to get unit for PID %\"PRIu32\": %s\", pid, bus_error_message(&error, r));\n\n        r = sd_bus_message_read(reply, \"o\", &u);\n        if (r < 0)\n                return bus_log_parse_error(r);\n\n        u = strdup(u);\n        if (!u)\n                return log_oom();\n\n        *unit = u;\n        return 0;\n}\n\nstatic int show_all(\n                sd_bus *bus,\n                bool *new_line,\n                bool *ellipsized) {\n\n        _cleanup_(sd_bus_message_unrefp) sd_bus_message *reply = NULL;\n        _cleanup_free_ UnitInfo *unit_infos = NULL;\n        const UnitInfo *u;\n        unsigned c;\n        int r, ret = 0;\n\n        r = get_unit_list(bus, NULL, NULL, &unit_infos, 0, &reply);\n        if (r < 0)\n                return r;\n\n        (void) pager_open(arg_no_pager, false);\n\n        c = (unsigned) r;\n\n        qsort_safe(unit_infos, c, sizeof(UnitInfo), compare_unit_info);\n\n        for (u = unit_infos; u < unit_infos + c; u++) {\n                _cleanup_free_ char *p = NULL;\n\n                p = unit_dbus_path_from_name(u->id);\n                if (!p)\n                        return log_oom();\n\n                r = show_one(bus, p, u->id, SYSTEMCTL_SHOW_STATUS, new_line, ellipsized);\n                if (r < 0)\n                        return r;\n                else if (r > 0 && ret == 0)\n                        ret = r;\n        }\n\n        return ret;\n}\n\nstatic int show_system_status(sd_bus *bus) {\n        char since1[FORMAT_TIMESTAMP_RELATIVE_MAX], since2[FORMAT_TIMESTAMP_MAX];\n        _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n        _cleanup_(machine_info_clear) struct machine_info mi = {};\n        _cleanup_free_ char *hn = NULL;\n        const char *on, *off;\n        int r;\n\n        hn = gethostname_malloc();\n        if (!hn)\n                return log_oom();\n\n        r = bus_map_all_properties(\n                        bus,\n                        \"org.freedesktop.systemd1\",\n                        \"/org/freedesktop/systemd1\",\n                        machine_info_property_map,\n                        BUS_MAP_STRDUP,\n                        &error,\n                        NULL,\n                        &mi);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to read server status: %s\", bus_error_message(&error, r));\n\n        if (streq_ptr(mi.state, \"degraded\")) {\n                on = ansi_highlight_red();\n                off = ansi_normal();\n        } else if (streq_ptr(mi.state, \"running\")) {\n                on = ansi_highlight_green();\n                off = ansi_normal();\n        } else {\n                on = ansi_highlight_yellow();\n                off = ansi_normal();\n        }\n\n        printf(\"%s%s%s %s\\n\", on, special_glyph(BLACK_CIRCLE), off, arg_host ? arg_host : hn);\n\n        printf(\"    State: %s%s%s\\n\",\n               on, strna(mi.state), off);\n\n        printf(\"     Jobs: %\" PRIu32 \" queued\\n\", mi.n_jobs);\n        printf(\"   Failed: %\" PRIu32 \" units\\n\", mi.n_failed_units);\n\n        printf(\"    Since: %s; %s\\n\",\n               format_timestamp(since2, sizeof(since2), mi.timestamp),\n               format_timestamp_relative(since1, sizeof(since1), mi.timestamp));\n\n        printf(\"   CGroup: %s\\n\", mi.control_group ?: \"/\");\n        if (IN_SET(arg_transport,\n                   BUS_TRANSPORT_LOCAL,\n                   BUS_TRANSPORT_MACHINE)) {\n                static const char prefix[] = \"           \";\n                unsigned c;\n\n                c = columns();\n                if (c > sizeof(prefix) - 1)\n                        c -= sizeof(prefix) - 1;\n                else\n                        c = 0;\n\n                show_cgroup(SYSTEMD_CGROUP_CONTROLLER, strempty(mi.control_group), prefix, c, get_output_flags());\n        }\n\n        return 0;\n}\n\nstatic int show(int argc, char *argv[], void *userdata) {\n        bool new_line = false, ellipsized = false;\n        SystemctlShowMode show_mode;\n        int r, ret = 0;\n        sd_bus *bus;\n\n        assert(argv);\n\n        show_mode = systemctl_show_mode_from_string(argv[0]);\n        if (show_mode < 0) {\n                log_error(\"Invalid argument.\");\n                return -EINVAL;\n        }\n\n        if (show_mode == SYSTEMCTL_SHOW_HELP && argc <= 1) {\n                log_error(\"This command expects one or more unit names. Did you mean --help?\");\n                return -EINVAL;\n        }\n\n        r = acquire_bus(BUS_MANAGER, &bus);\n        if (r < 0)\n                return r;\n\n        (void) pager_open(arg_no_pager, false);\n\n        if (show_mode == SYSTEMCTL_SHOW_STATUS)\n                /* Increase max number of open files to 16K if we can, we\n                 * might needs this when browsing journal files, which might\n                 * be split up into many files. */\n                setrlimit_closest(RLIMIT_NOFILE, &RLIMIT_MAKE_CONST(16384));\n\n        /* If no argument is specified inspect the manager itself */\n        if (show_mode == SYSTEMCTL_SHOW_PROPERTIES && argc <= 1)\n                return show_one(bus, \"/org/freedesktop/systemd1\", NULL, show_mode, &new_line, &ellipsized);\n\n        if (show_mode == SYSTEMCTL_SHOW_STATUS && argc <= 1) {\n\n                show_system_status(bus);\n                new_line = true;\n\n                if (arg_all)\n                        ret = show_all(bus, &new_line, &ellipsized);\n        } else {\n                _cleanup_free_ char **patterns = NULL;\n                char **name;\n\n                STRV_FOREACH(name, strv_skip(argv, 1)) {\n                        _cleanup_free_ char *path = NULL, *unit = NULL;\n                        uint32_t id;\n\n                        if (safe_atou32(*name, &id) < 0) {\n                                if (strv_push(&patterns, *name) < 0)\n                                        return log_oom();\n\n                                continue;\n                        } else if (show_mode == SYSTEMCTL_SHOW_PROPERTIES) {\n                                /* Interpret as job id */\n                                if (asprintf(&path, \"/org/freedesktop/systemd1/job/%u\", id) < 0)\n                                        return log_oom();\n\n                        } else {\n                                /* Interpret as PID */\n                                r = get_unit_dbus_path_by_pid(bus, id, &path);\n                                if (r < 0) {\n                                        ret = r;\n                                        continue;\n                                }\n\n                                r = unit_name_from_dbus_path(path, &unit);\n                                if (r < 0)\n                                        return log_oom();\n                        }\n\n                        r = show_one(bus, path, unit, show_mode, &new_line, &ellipsized);\n                        if (r < 0)\n                                return r;\n                        else if (r > 0 && ret == 0)\n                                ret = r;\n                }\n\n                if (!strv_isempty(patterns)) {\n                        _cleanup_strv_free_ char **names = NULL;\n\n                        r = expand_names(bus, patterns, NULL, &names);\n                        if (r < 0)\n                                return log_error_errno(r, \"Failed to expand names: %m\");\n\n                        STRV_FOREACH(name, names) {\n                                _cleanup_free_ char *path;\n\n                                path = unit_dbus_path_from_name(*name);\n                                if (!path)\n                                        return log_oom();\n\n                                r = show_one(bus, path, *name, show_mode, &new_line, &ellipsized);\n                                if (r < 0)\n                                        return r;\n                                if (r > 0 && ret == 0)\n                                        ret = r;\n                        }\n                }\n        }\n\n        if (ellipsized && !arg_quiet)\n                printf(\"Hint: Some lines were ellipsized, use -l to show in full.\\n\");\n\n        return ret;\n}\n\nstatic int cat(int argc, char *argv[], void *userdata) {\n        _cleanup_(lookup_paths_free) LookupPaths lp = {};\n        _cleanup_strv_free_ char **names = NULL;\n        char **name;\n        sd_bus *bus;\n        bool first = true;\n        int r;\n\n        if (arg_transport != BUS_TRANSPORT_LOCAL) {\n                log_error(\"Cannot remotely cat units.\");\n                return -EINVAL;\n        }\n\n        r = lookup_paths_init(&lp, arg_scope, 0, arg_root);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to determine unit paths: %m\");\n\n        r = acquire_bus(BUS_MANAGER, &bus);\n        if (r < 0)\n                return r;\n\n        r = expand_names(bus, strv_skip(argv, 1), NULL, &names);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to expand names: %m\");\n\n        (void) pager_open(arg_no_pager, false);\n\n        STRV_FOREACH(name, names) {\n                _cleanup_free_ char *fragment_path = NULL;\n                _cleanup_strv_free_ char **dropin_paths = NULL;\n\n                r = unit_find_paths(bus, *name, &lp, &fragment_path, &dropin_paths);\n                if (r < 0)\n                        return r;\n                else if (r == 0)\n                        return -ENOENT;\n\n                if (first)\n                        first = false;\n                else\n                        puts(\"\");\n\n                if (need_daemon_reload(bus, *name) > 0) /* ignore errors (<0), this is informational output */\n                        fprintf(stderr,\n                                \"%s# Warning: %s changed on disk, the version systemd has loaded is outdated.\\n\"\n                                \"%s# This output shows the current version of the unit's original fragment and drop-in files.\\n\"\n                                \"%s# If fragments or drop-ins were added or removed, they are not properly reflected in this output.\\n\"\n                                \"%s# Run 'systemctl%s daemon-reload' to reload units.%s\\n\",\n                                ansi_highlight_red(),\n                                *name,\n                                ansi_highlight_red(),\n                                ansi_highlight_red(),\n                                ansi_highlight_red(),\n                                arg_scope == UNIT_FILE_SYSTEM ? \"\" : \" --user\",\n                                ansi_normal());\n\n                r = cat_files(fragment_path, dropin_paths, 0);\n                if (r < 0)\n                        return r;\n        }\n\n        return 0;\n}\n\nstatic int set_property(int argc, char *argv[], void *userdata) {\n        _cleanup_(sd_bus_message_unrefp) sd_bus_message *m = NULL;\n        _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n        _cleanup_free_ char *n = NULL;\n        UnitType t;\n        sd_bus *bus;\n        int r;\n\n        r = acquire_bus(BUS_MANAGER, &bus);\n        if (r < 0)\n                return r;\n\n        polkit_agent_open_maybe();\n\n        r = sd_bus_message_new_method_call(\n                        bus,\n                        &m,\n                        \"org.freedesktop.systemd1\",\n                        \"/org/freedesktop/systemd1\",\n                        \"org.freedesktop.systemd1.Manager\",\n                        \"SetUnitProperties\");\n        if (r < 0)\n                return bus_log_create_error(r);\n\n        r = unit_name_mangle(argv[1], arg_quiet ? 0 : UNIT_NAME_MANGLE_WARN, &n);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to mangle unit name: %m\");\n\n        t = unit_name_to_type(n);\n        if (t < 0) {\n                log_error(\"Invalid unit type: %s\", n);\n                return -EINVAL;\n        }\n\n        r = sd_bus_message_append(m, \"sb\", n, arg_runtime);\n        if (r < 0)\n                return bus_log_create_error(r);\n\n        r = sd_bus_message_open_container(m, SD_BUS_TYPE_ARRAY, \"(sv)\");\n        if (r < 0)\n                return bus_log_create_error(r);\n\n        r = bus_append_unit_property_assignment_many(m, t, strv_skip(argv, 2));\n        if (r < 0)\n                return r;\n\n        r = sd_bus_message_close_container(m);\n        if (r < 0)\n                return bus_log_create_error(r);\n\n        r = sd_bus_call(bus, m, 0, &error, NULL);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to set unit properties on %s: %s\", n, bus_error_message(&error, r));\n\n        return 0;\n}\n\nstatic int daemon_reload(int argc, char *argv[], void *userdata) {\n        _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n        _cleanup_(sd_bus_message_unrefp) sd_bus_message *m = NULL;\n        const char *method;\n        sd_bus *bus;\n        int r;\n\n        r = acquire_bus(BUS_MANAGER, &bus);\n        if (r < 0)\n                return r;\n\n        polkit_agent_open_maybe();\n\n        switch (arg_action) {\n\n        case ACTION_RELOAD:\n                method = \"Reload\";\n                break;\n\n        case ACTION_REEXEC:\n                method = \"Reexecute\";\n                break;\n\n        case ACTION_SYSTEMCTL:\n                method = streq(argv[0], \"daemon-reexec\") ? \"Reexecute\" :\n                                     /* \"daemon-reload\" */ \"Reload\";\n                break;\n\n        default:\n                assert_not_reached(\"Unexpected action\");\n        }\n\n        r = sd_bus_message_new_method_call(\n                        bus,\n                        &m,\n                        \"org.freedesktop.systemd1\",\n                        \"/org/freedesktop/systemd1\",\n                        \"org.freedesktop.systemd1.Manager\",\n                        method);\n        if (r < 0)\n                return bus_log_create_error(r);\n\n        /* Note we use an extra-long timeout here. This is because a reload or reexec means generators are rerun which\n         * are timed out after DEFAULT_TIMEOUT_USEC. Let's use twice that time here, so that the generators can have\n         * their timeout, and for everything else there's the same time budget in place. */\n\n        r = sd_bus_call(bus, m, DEFAULT_TIMEOUT_USEC * 2, &error, NULL);\n\n        /* On reexecution, we expect a disconnect, not a reply */\n        if (IN_SET(r, -ETIMEDOUT, -ECONNRESET) && streq(method, \"Reexecute\"))\n                r = 0;\n\n        if (r < 0 && arg_action == ACTION_SYSTEMCTL)\n                return log_error_errno(r, \"Failed to reload daemon: %s\", bus_error_message(&error, r));\n\n        /* Note that for the legacy commands (i.e. those with action != ACTION_SYSTEMCTL) we support fallbacks to the\n         * old ways of doing things, hence don't log any error in that case here. */\n\n        return r < 0 ? r : 0;\n}\n\nstatic int trivial_method(int argc, char *argv[], void *userdata) {\n        _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n        const char *method;\n        sd_bus *bus;\n        int r;\n\n        if (arg_dry_run)\n                return 0;\n\n        r = acquire_bus(BUS_MANAGER, &bus);\n        if (r < 0)\n                return r;\n\n        polkit_agent_open_maybe();\n\n        method =\n                streq(argv[0], \"clear-jobs\")    ||\n                streq(argv[0], \"cancel\")        ? \"ClearJobs\" :\n                streq(argv[0], \"reset-failed\")  ? \"ResetFailed\" :\n                streq(argv[0], \"halt\")          ? \"Halt\" :\n                streq(argv[0], \"reboot\")        ? \"Reboot\" :\n                streq(argv[0], \"kexec\")         ? \"KExec\" :\n                streq(argv[0], \"exit\")          ? \"Exit\" :\n                             /* poweroff */       \"PowerOff\";\n\n        r = sd_bus_call_method(\n                        bus,\n                        \"org.freedesktop.systemd1\",\n                        \"/org/freedesktop/systemd1\",\n                        \"org.freedesktop.systemd1.Manager\",\n                        method,\n                        &error,\n                        NULL,\n                        NULL);\n        if (r < 0 && arg_action == ACTION_SYSTEMCTL)\n                return log_error_errno(r, \"Failed to execute operation: %s\", bus_error_message(&error, r));\n\n        /* Note that for the legacy commands (i.e. those with action != ACTION_SYSTEMCTL) we support fallbacks to the\n         * old ways of doing things, hence don't log any error in that case here. */\n\n        return r < 0 ? r : 0;\n}\n\nstatic int reset_failed(int argc, char *argv[], void *userdata) {\n        _cleanup_strv_free_ char **names = NULL;\n        sd_bus *bus;\n        char **name;\n        int r, q;\n\n        if (argc <= 1)\n                return trivial_method(argc, argv, userdata);\n\n        r = acquire_bus(BUS_MANAGER, &bus);\n        if (r < 0)\n                return r;\n\n        polkit_agent_open_maybe();\n\n        r = expand_names(bus, strv_skip(argv, 1), NULL, &names);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to expand names: %m\");\n\n        STRV_FOREACH(name, names) {\n                _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n\n                q = sd_bus_call_method(\n                                bus,\n                                \"org.freedesktop.systemd1\",\n                                \"/org/freedesktop/systemd1\",\n                                \"org.freedesktop.systemd1.Manager\",\n                                \"ResetFailedUnit\",\n                                &error,\n                                NULL,\n                                \"s\", *name);\n                if (q < 0) {\n                        log_error_errno(q, \"Failed to reset failed state of unit %s: %s\", *name, bus_error_message(&error, q));\n                        if (r == 0)\n                                r = q;\n                }\n        }\n\n        return r;\n}\n\nstatic int print_variable(const char *s) {\n        const char *sep;\n        _cleanup_free_ char *esc = NULL;\n\n        sep = strchr(s, '=');\n        if (!sep) {\n                log_error(\"Invalid environment block\");\n                return -EUCLEAN;\n        }\n\n        esc = shell_maybe_quote(sep + 1, ESCAPE_POSIX);\n        if (!esc)\n                return log_oom();\n\n        printf(\"%.*s=%s\\n\", (int)(sep-s), s, esc);\n        return 0;\n}\n\nstatic int show_environment(int argc, char *argv[], void *userdata) {\n        _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n        _cleanup_(sd_bus_message_unrefp) sd_bus_message *reply = NULL;\n        const char *text;\n        sd_bus *bus;\n        int r;\n\n        r = acquire_bus(BUS_MANAGER, &bus);\n        if (r < 0)\n                return r;\n\n        (void) pager_open(arg_no_pager, false);\n\n        r = sd_bus_get_property(\n                        bus,\n                        \"org.freedesktop.systemd1\",\n                        \"/org/freedesktop/systemd1\",\n                        \"org.freedesktop.systemd1.Manager\",\n                        \"Environment\",\n                        &error,\n                        &reply,\n                        \"as\");\n        if (r < 0)\n                return log_error_errno(r, \"Failed to get environment: %s\", bus_error_message(&error, r));\n\n        r = sd_bus_message_enter_container(reply, SD_BUS_TYPE_ARRAY, \"s\");\n        if (r < 0)\n                return bus_log_parse_error(r);\n\n        while ((r = sd_bus_message_read_basic(reply, SD_BUS_TYPE_STRING, &text)) > 0) {\n                r = print_variable(text);\n                if (r < 0)\n                        return r;\n        }\n        if (r < 0)\n                return bus_log_parse_error(r);\n\n        r = sd_bus_message_exit_container(reply);\n        if (r < 0)\n                return bus_log_parse_error(r);\n\n        return 0;\n}\n\nstatic int switch_root(int argc, char *argv[], void *userdata) {\n        _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n        _cleanup_free_ char *cmdline_init = NULL;\n        const char *root, *init;\n        sd_bus *bus;\n        int r;\n\n        if (arg_transport != BUS_TRANSPORT_LOCAL) {\n                log_error(\"Cannot switch root remotely.\");\n                return -EINVAL;\n        }\n\n        if (argc < 2 || argc > 3) {\n                log_error(\"Wrong number of arguments.\");\n                return -EINVAL;\n        }\n\n        root = argv[1];\n\n        if (argc >= 3)\n                init = argv[2];\n        else {\n                r = parse_env_file(NULL, \"/proc/cmdline\", WHITESPACE,\n                                   \"init\", &cmdline_init,\n                                   NULL);\n                if (r < 0)\n                        log_debug_errno(r, \"Failed to parse /proc/cmdline: %m\");\n\n                init = cmdline_init;\n        }\n\n        init = empty_to_null(init);\n        if (init) {\n                const char *root_systemd_path = NULL, *root_init_path = NULL;\n\n                root_systemd_path = strjoina(root, \"/\" SYSTEMD_BINARY_PATH);\n                root_init_path = strjoina(root, \"/\", init);\n\n                /* If the passed init is actually the same as the\n                 * systemd binary, then let's suppress it. */\n                if (files_same(root_init_path, root_systemd_path, 0) > 0)\n                        init = NULL;\n        }\n\n        /* Instruct PID1 to exclude us from its killing spree applied during\n         * the transition. Otherwise we would exit with a failure status even\n         * though the switch to the new root has succeed. */\n        argv_cmdline[0] = '@';\n\n        r = acquire_bus(BUS_MANAGER, &bus);\n        if (r < 0)\n                return r;\n\n        /* If we are slow to exit after the root switch, the new systemd instance\n         * will send us a signal to terminate. Just ignore it and exit normally.\n         * This way the unit does not end up as failed.\n         */\n        r = ignore_signals(SIGTERM, -1);\n        if (r < 0)\n                log_warning_errno(r, \"Failed to change disposition of SIGTERM to ignore: %m\");\n\n        log_debug(\"Switching root - root: %s; init: %s\", root, strna(init));\n\n        r = sd_bus_call_method(\n                        bus,\n                        \"org.freedesktop.systemd1\",\n                        \"/org/freedesktop/systemd1\",\n                        \"org.freedesktop.systemd1.Manager\",\n                        \"SwitchRoot\",\n                        &error,\n                        NULL,\n                        \"ss\", root, init);\n        if (r < 0) {\n                (void) default_signals(SIGTERM, -1);\n\n                return log_error_errno(r, \"Failed to switch root: %s\", bus_error_message(&error, r));\n        }\n\n        return 0;\n}\n\nstatic int set_environment(int argc, char *argv[], void *userdata) {\n        _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n        _cleanup_(sd_bus_message_unrefp) sd_bus_message *m = NULL;\n        const char *method;\n        sd_bus *bus;\n        int r;\n\n        assert(argc > 1);\n        assert(argv);\n\n        r = acquire_bus(BUS_MANAGER, &bus);\n        if (r < 0)\n                return r;\n\n        polkit_agent_open_maybe();\n\n        method = streq(argv[0], \"set-environment\")\n                ? \"SetEnvironment\"\n                : \"UnsetEnvironment\";\n\n        r = sd_bus_message_new_method_call(\n                        bus,\n                        &m,\n                        \"org.freedesktop.systemd1\",\n                        \"/org/freedesktop/systemd1\",\n                        \"org.freedesktop.systemd1.Manager\",\n                        method);\n        if (r < 0)\n                return bus_log_create_error(r);\n\n        r = sd_bus_message_append_strv(m, strv_skip(argv, 1));\n        if (r < 0)\n                return bus_log_create_error(r);\n\n        r = sd_bus_call(bus, m, 0, &error, NULL);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to set environment: %s\", bus_error_message(&error, r));\n\n        return 0;\n}\n\nstatic int import_environment(int argc, char *argv[], void *userdata) {\n        _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n        _cleanup_(sd_bus_message_unrefp) sd_bus_message *m = NULL;\n        sd_bus *bus;\n        int r;\n\n        r = acquire_bus(BUS_MANAGER, &bus);\n        if (r < 0)\n                return r;\n\n        polkit_agent_open_maybe();\n\n        r = sd_bus_message_new_method_call(\n                        bus,\n                        &m,\n                        \"org.freedesktop.systemd1\",\n                        \"/org/freedesktop/systemd1\",\n                        \"org.freedesktop.systemd1.Manager\",\n                        \"SetEnvironment\");\n        if (r < 0)\n                return bus_log_create_error(r);\n\n        if (argc < 2)\n                r = sd_bus_message_append_strv(m, environ);\n        else {\n                char **a, **b;\n\n                r = sd_bus_message_open_container(m, 'a', \"s\");\n                if (r < 0)\n                        return bus_log_create_error(r);\n\n                STRV_FOREACH(a, strv_skip(argv, 1)) {\n\n                        if (!env_name_is_valid(*a)) {\n                                log_error(\"Not a valid environment variable name: %s\", *a);\n                                return -EINVAL;\n                        }\n\n                        STRV_FOREACH(b, environ) {\n                                const char *eq;\n\n                                eq = startswith(*b, *a);\n                                if (eq && *eq == '=') {\n\n                                        r = sd_bus_message_append(m, \"s\", *b);\n                                        if (r < 0)\n                                                return bus_log_create_error(r);\n\n                                        break;\n                                }\n                        }\n                }\n\n                r = sd_bus_message_close_container(m);\n        }\n        if (r < 0)\n                return bus_log_create_error(r);\n\n        r = sd_bus_call(bus, m, 0, &error, NULL);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to import environment: %s\", bus_error_message(&error, r));\n\n        return 0;\n}\n\nstatic int enable_sysv_units(const char *verb, char **args) {\n        int r = 0;\n\n#if HAVE_SYSV_COMPAT\n        _cleanup_(lookup_paths_free) LookupPaths paths = {};\n        unsigned f = 0;\n\n        /* Processes all SysV units, and reshuffles the array so that afterwards only the native units remain */\n\n        if (arg_scope != UNIT_FILE_SYSTEM)\n                return 0;\n\n        if (getenv_bool(\"SYSTEMCTL_SKIP_SYSV\") > 0)\n                return 0;\n\n        if (!STR_IN_SET(verb,\n                        \"enable\",\n                        \"disable\",\n                        \"is-enabled\"))\n                return 0;\n\n        r = lookup_paths_init(&paths, arg_scope, LOOKUP_PATHS_EXCLUDE_GENERATED, arg_root);\n        if (r < 0)\n                return r;\n\n        r = 0;\n        while (args[f]) {\n\n                const char *argv[] = {\n                        ROOTLIBEXECDIR \"/systemd-sysv-install\",\n                        NULL,\n                        NULL,\n                        NULL,\n                        NULL,\n                };\n\n                _cleanup_free_ char *p = NULL, *q = NULL, *l = NULL;\n                bool found_native = false, found_sysv;\n                const char *name;\n                unsigned c = 1;\n                pid_t pid;\n                int j;\n\n                name = args[f++];\n\n                if (!endswith(name, \".service\"))\n                        continue;\n\n                if (path_is_absolute(name))\n                        continue;\n\n                j = unit_file_exists(arg_scope, &paths, name);\n                if (j < 0 && !IN_SET(j, -ELOOP, -ERFKILL, -EADDRNOTAVAIL))\n                        return log_error_errno(j, \"Failed to lookup unit file state: %m\");\n                found_native = j != 0;\n\n                /* If we have both a native unit and a SysV script, enable/disable them both (below); for is-enabled,\n                 * prefer the native unit */\n                if (found_native && streq(verb, \"is-enabled\"))\n                        continue;\n\n                p = path_join(arg_root, SYSTEM_SYSVINIT_PATH, name);\n                if (!p)\n                        return log_oom();\n\n                p[strlen(p) - STRLEN(\".service\")] = 0;\n                found_sysv = access(p, F_OK) >= 0;\n                if (!found_sysv)\n                        continue;\n\n                if (!arg_quiet) {\n                        if (found_native)\n                                log_info(\"Synchronizing state of %s with SysV service script with %s.\", name, argv[0]);\n                        else\n                                log_info(\"%s is not a native service, redirecting to systemd-sysv-install.\", name);\n                }\n\n                if (!isempty(arg_root))\n                        argv[c++] = q = strappend(\"--root=\", arg_root);\n\n                argv[c++] = verb;\n                argv[c++] = basename(p);\n                argv[c] = NULL;\n\n                l = strv_join((char**)argv, \" \");\n                if (!l)\n                        return log_oom();\n\n                if (!arg_quiet)\n                        log_info(\"Executing: %s\", l);\n\n                j = safe_fork(\"(sysv-install)\", FORK_RESET_SIGNALS|FORK_DEATHSIG|FORK_LOG, &pid);\n                if (j < 0)\n                        return j;\n                if (j == 0) {\n                        /* Child */\n                        execv(argv[0], (char**) argv);\n                        log_error_errno(errno, \"Failed to execute %s: %m\", argv[0]);\n                        _exit(EXIT_FAILURE);\n                }\n\n                j = wait_for_terminate_and_check(\"sysv-install\", pid, WAIT_LOG_ABNORMAL);\n                if (j < 0)\n                        return j;\n                if (streq(verb, \"is-enabled\")) {\n                        if (j == EXIT_SUCCESS) {\n                                if (!arg_quiet)\n                                        puts(\"enabled\");\n                                r = 1;\n                        } else {\n                                if (!arg_quiet)\n                                        puts(\"disabled\");\n                        }\n\n                } else if (j != EXIT_SUCCESS)\n                        return -EBADE; /* We don't warn here, under the assumption the script already showed an explanation */\n\n                if (found_native)\n                        continue;\n\n                /* Remove this entry, so that we don't try enabling it as native unit */\n                assert(f > 0);\n                f--;\n                assert(args[f] == name);\n                strv_remove(args, name);\n        }\n\n#endif\n        return r;\n}\n\nstatic int mangle_names(char **original_names, char ***mangled_names) {\n        char **i, **l, **name;\n        int r;\n\n        l = i = new(char*, strv_length(original_names) + 1);\n        if (!l)\n                return log_oom();\n\n        STRV_FOREACH(name, original_names) {\n\n                /* When enabling units qualified path names are OK,\n                 * too, hence allow them explicitly. */\n\n                if (is_path(*name)) {\n                        *i = strdup(*name);\n                        if (!*i) {\n                                strv_free(l);\n                                return log_oom();\n                        }\n                } else {\n                        r = unit_name_mangle(*name, arg_quiet ? 0 : UNIT_NAME_MANGLE_WARN, i);\n                        if (r < 0) {\n                                *i = NULL;\n                                strv_free(l);\n                                return log_error_errno(r, \"Failed to mangle unit name: %m\");\n                        }\n                }\n\n                i++;\n        }\n\n        *i = NULL;\n        *mangled_names = l;\n\n        return 0;\n}\n\nstatic int normalize_filenames(char **names) {\n        char **u;\n        int r;\n\n        STRV_FOREACH(u, names)\n                if (!path_is_absolute(*u)) {\n                        char* normalized_path;\n\n                        if (!isempty(arg_root)) {\n                                log_error(\"Non-absolute paths are not allowed when --root is used: %s\", *u);\n                                return -EINVAL;\n                        }\n\n                        if (!strchr(*u,'/')) {\n                                log_error(\"Link argument does contain at least one directory separator: %s\", *u);\n                                return -EINVAL;\n                        }\n\n                        r = path_make_absolute_cwd(*u, &normalized_path);\n                        if (r < 0)\n                                return r;\n\n                        free_and_replace(*u, normalized_path);\n                }\n\n        return 0;\n}\n\nstatic int normalize_names(char **names, bool warn_if_path) {\n        char **u;\n        bool was_path = false;\n\n        STRV_FOREACH(u, names) {\n                int r;\n\n                if (!is_path(*u))\n                        continue;\n\n                r = free_and_strdup(u, basename(*u));\n                if (r < 0)\n                        return log_error_errno(r, \"Failed to normalize unit file path: %m\");\n\n                was_path = true;\n        }\n\n        if (warn_if_path && was_path)\n                log_warning(\"Warning: Can't execute disable on the unit file path. Proceeding with the unit name.\");\n\n        return 0;\n}\n\nstatic int unit_exists(LookupPaths *lp, const char *unit) {\n        _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n        _cleanup_(sd_bus_message_unrefp) sd_bus_message *m = NULL;\n        _cleanup_free_ char *path = NULL;\n        static const struct bus_properties_map property_map[] = {\n                { \"LoadState\",   \"s\", NULL, offsetof(UnitStatusInfo, load_state)  },\n                { \"ActiveState\", \"s\", NULL, offsetof(UnitStatusInfo, active_state)},\n                {},\n        };\n        UnitStatusInfo info = {};\n        sd_bus *bus;\n        int r;\n\n        if (unit_name_is_valid(unit, UNIT_NAME_TEMPLATE))\n                return unit_find_template_path(unit, lp, NULL, NULL);\n\n        path = unit_dbus_path_from_name(unit);\n        if (!path)\n                return log_oom();\n\n        r = acquire_bus(BUS_MANAGER, &bus);\n        if (r < 0)\n                return r;\n\n        r = bus_map_all_properties(bus, \"org.freedesktop.systemd1\", path, property_map, 0, &error, &m, &info);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to get properties: %s\", bus_error_message(&error, r));\n\n        return !streq_ptr(info.load_state, \"not-found\") || !streq_ptr(info.active_state, \"inactive\");\n}\n\nstatic int enable_unit(int argc, char *argv[], void *userdata) {\n        _cleanup_strv_free_ char **names = NULL;\n        const char *verb = argv[0];\n        UnitFileChange *changes = NULL;\n        size_t n_changes = 0;\n        int carries_install_info = -1;\n        bool ignore_carries_install_info = arg_quiet;\n        int r;\n\n        if (!argv[1])\n                return 0;\n\n        r = mangle_names(strv_skip(argv, 1), &names);\n        if (r < 0)\n                return r;\n\n        r = enable_sysv_units(verb, names);\n        if (r < 0)\n                return r;\n\n        /* If the operation was fully executed by the SysV compat, let's finish early */\n        if (strv_isempty(names)) {\n                if (arg_no_reload || install_client_side())\n                        return 0;\n                return daemon_reload(argc, argv, userdata);\n        }\n\n        if (streq(verb, \"disable\")) {\n                r = normalize_names(names, true);\n                if (r < 0)\n                        return r;\n        }\n\n        if (streq(verb, \"link\")) {\n                r = normalize_filenames(names);\n                if (r < 0)\n                        return r;\n        }\n\n        if (install_client_side()) {\n                UnitFileFlags flags;\n\n                flags = args_to_flags();\n                if (streq(verb, \"enable\")) {\n                        r = unit_file_enable(arg_scope, flags, arg_root, names, &changes, &n_changes);\n                        carries_install_info = r;\n                } else if (streq(verb, \"disable\"))\n                        r = unit_file_disable(arg_scope, flags, arg_root, names, &changes, &n_changes);\n                else if (streq(verb, \"reenable\")) {\n                        r = unit_file_reenable(arg_scope, flags, arg_root, names, &changes, &n_changes);\n                        carries_install_info = r;\n                } else if (streq(verb, \"link\"))\n                        r = unit_file_link(arg_scope, flags, arg_root, names, &changes, &n_changes);\n                else if (streq(verb, \"preset\")) {\n                        r = unit_file_preset(arg_scope, flags, arg_root, names, arg_preset_mode, &changes, &n_changes);\n                } else if (streq(verb, \"mask\"))\n                        r = unit_file_mask(arg_scope, flags, arg_root, names, &changes, &n_changes);\n                else if (streq(verb, \"unmask\"))\n                        r = unit_file_unmask(arg_scope, flags, arg_root, names, &changes, &n_changes);\n                else if (streq(verb, \"revert\"))\n                        r = unit_file_revert(arg_scope, arg_root, names, &changes, &n_changes);\n                else\n                        assert_not_reached(\"Unknown verb\");\n\n                unit_file_dump_changes(r, verb, changes, n_changes, arg_quiet);\n                if (r < 0)\n                        goto finish;\n                r = 0;\n        } else {\n                _cleanup_(sd_bus_message_unrefp) sd_bus_message *reply = NULL, *m = NULL;\n                _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n                bool expect_carries_install_info = false;\n                bool send_runtime = true, send_force = true, send_preset_mode = false;\n                const char *method;\n                sd_bus *bus;\n\n                if (STR_IN_SET(verb, \"mask\", \"unmask\")) {\n                        char **name;\n                        _cleanup_(lookup_paths_free) LookupPaths lp = {};\n\n                        r = lookup_paths_init(&lp, arg_scope, 0, arg_root);\n                        if (r < 0)\n                                return r;\n\n                        STRV_FOREACH(name, names) {\n                                r = unit_exists(&lp, *name);\n                                if (r < 0)\n                                        return r;\n                                if (r == 0)\n                                        log_notice(\"Unit %s does not exist, proceeding anyway.\", *name);\n                        }\n                }\n\n                r = acquire_bus(BUS_MANAGER, &bus);\n                if (r < 0)\n                        return r;\n\n                polkit_agent_open_maybe();\n\n                if (streq(verb, \"enable\")) {\n                        method = \"EnableUnitFiles\";\n                        expect_carries_install_info = true;\n                } else if (streq(verb, \"disable\")) {\n                        method = \"DisableUnitFiles\";\n                        send_force = false;\n                } else if (streq(verb, \"reenable\")) {\n                        method = \"ReenableUnitFiles\";\n                        expect_carries_install_info = true;\n                } else if (streq(verb, \"link\"))\n                        method = \"LinkUnitFiles\";\n                else if (streq(verb, \"preset\")) {\n\n                        if (arg_preset_mode != UNIT_FILE_PRESET_FULL) {\n                                method = \"PresetUnitFilesWithMode\";\n                                send_preset_mode = true;\n                        } else\n                                method = \"PresetUnitFiles\";\n\n                        expect_carries_install_info = true;\n                        ignore_carries_install_info = true;\n                } else if (streq(verb, \"mask\"))\n                        method = \"MaskUnitFiles\";\n                else if (streq(verb, \"unmask\")) {\n                        method = \"UnmaskUnitFiles\";\n                        send_force = false;\n                } else if (streq(verb, \"revert\")) {\n                        method = \"RevertUnitFiles\";\n                        send_runtime = send_force = false;\n                } else\n                        assert_not_reached(\"Unknown verb\");\n\n                r = sd_bus_message_new_method_call(\n                                bus,\n                                &m,\n                                \"org.freedesktop.systemd1\",\n                                \"/org/freedesktop/systemd1\",\n                                \"org.freedesktop.systemd1.Manager\",\n                                method);\n                if (r < 0)\n                        return bus_log_create_error(r);\n\n                r = sd_bus_message_append_strv(m, names);\n                if (r < 0)\n                        return bus_log_create_error(r);\n\n                if (send_preset_mode) {\n                        r = sd_bus_message_append(m, \"s\", unit_file_preset_mode_to_string(arg_preset_mode));\n                        if (r < 0)\n                                return bus_log_create_error(r);\n                }\n\n                if (send_runtime) {\n                        r = sd_bus_message_append(m, \"b\", arg_runtime);\n                        if (r < 0)\n                                return bus_log_create_error(r);\n                }\n\n                if (send_force) {\n                        r = sd_bus_message_append(m, \"b\", arg_force);\n                        if (r < 0)\n                                return bus_log_create_error(r);\n                }\n\n                r = sd_bus_call(bus, m, 0, &error, &reply);\n                if (r < 0)\n                        return log_error_errno(r, \"Failed to %s unit: %s\", verb, bus_error_message(&error, r));\n\n                if (expect_carries_install_info) {\n                        r = sd_bus_message_read(reply, \"b\", &carries_install_info);\n                        if (r < 0)\n                                return bus_log_parse_error(r);\n                }\n\n                r = bus_deserialize_and_dump_unit_file_changes(reply, arg_quiet, &changes, &n_changes);\n                if (r < 0)\n                        goto finish;\n\n                /* Try to reload if enabled */\n                if (!arg_no_reload)\n                        r = daemon_reload(argc, argv, userdata);\n                else\n                        r = 0;\n        }\n\n        if (carries_install_info == 0 && !ignore_carries_install_info)\n                log_warning(\"The unit files have no installation config (WantedBy, RequiredBy, Also, Alias\\n\"\n                            \"settings in the [Install] section, and DefaultInstance for template units).\\n\"\n                            \"This means they are not meant to be enabled using systemctl.\\n\"\n                            \"Possible reasons for having this kind of units are:\\n\"\n                            \"1) A unit may be statically enabled by being symlinked from another unit's\\n\"\n                            \"   .wants/ or .requires/ directory.\\n\"\n                            \"2) A unit's purpose may be to act as a helper for some other unit which has\\n\"\n                            \"   a requirement dependency on it.\\n\"\n                            \"3) A unit may be started when needed via activation (socket, path, timer,\\n\"\n                            \"   D-Bus, udev, scripted systemctl call, ...).\\n\"\n                            \"4) In case of template units, the unit is meant to be enabled with some\\n\"\n                            \"   instance name specified.\");\n\n        if (arg_now && STR_IN_SET(argv[0], \"enable\", \"disable\", \"mask\")) {\n                sd_bus *bus;\n                size_t len, i;\n\n                r = acquire_bus(BUS_MANAGER, &bus);\n                if (r < 0)\n                        goto finish;\n\n                len = strv_length(names);\n                {\n                        char *new_args[len + 2];\n\n                        new_args[0] = (char*) (streq(argv[0], \"enable\") ? \"start\" : \"stop\");\n                        for (i = 0; i < len; i++)\n                                new_args[i + 1] = basename(names[i]);\n                        new_args[i + 1] = NULL;\n\n                        r = start_unit(len + 1, new_args, userdata);\n                }\n        }\n\nfinish:\n        unit_file_changes_free(changes, n_changes);\n\n        return r;\n}\n\nstatic int add_dependency(int argc, char *argv[], void *userdata) {\n        _cleanup_strv_free_ char **names = NULL;\n        _cleanup_free_ char *target = NULL;\n        const char *verb = argv[0];\n        UnitFileChange *changes = NULL;\n        size_t n_changes = 0;\n        UnitDependency dep;\n        int r = 0;\n\n        if (!argv[1])\n                return 0;\n\n        r = unit_name_mangle_with_suffix(argv[1], arg_quiet ? 0 : UNIT_NAME_MANGLE_WARN, \".target\", &target);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to mangle unit name: %m\");\n\n        r = mangle_names(strv_skip(argv, 2), &names);\n        if (r < 0)\n                return r;\n\n        if (streq(verb, \"add-wants\"))\n                dep = UNIT_WANTS;\n        else if (streq(verb, \"add-requires\"))\n                dep = UNIT_REQUIRES;\n        else\n                assert_not_reached(\"Unknown verb\");\n\n        if (install_client_side()) {\n                r = unit_file_add_dependency(arg_scope, args_to_flags(), arg_root, names, target, dep, &changes, &n_changes);\n                unit_file_dump_changes(r, \"add dependency on\", changes, n_changes, arg_quiet);\n\n                if (r > 0)\n                        r = 0;\n        } else {\n                _cleanup_(sd_bus_message_unrefp) sd_bus_message *reply = NULL, *m = NULL;\n                _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n                sd_bus *bus;\n\n                r = acquire_bus(BUS_MANAGER, &bus);\n                if (r < 0)\n                        return r;\n\n                polkit_agent_open_maybe();\n\n                r = sd_bus_message_new_method_call(\n                                bus,\n                                &m,\n                                \"org.freedesktop.systemd1\",\n                                \"/org/freedesktop/systemd1\",\n                                \"org.freedesktop.systemd1.Manager\",\n                                \"AddDependencyUnitFiles\");\n                if (r < 0)\n                        return bus_log_create_error(r);\n\n                r = sd_bus_message_append_strv(m, names);\n                if (r < 0)\n                        return bus_log_create_error(r);\n\n                r = sd_bus_message_append(m, \"ssbb\", target, unit_dependency_to_string(dep), arg_runtime, arg_force);\n                if (r < 0)\n                        return bus_log_create_error(r);\n\n                r = sd_bus_call(bus, m, 0, &error, &reply);\n                if (r < 0)\n                        return log_error_errno(r, \"Failed to add dependency: %s\", bus_error_message(&error, r));\n\n                r = bus_deserialize_and_dump_unit_file_changes(reply, arg_quiet, &changes, &n_changes);\n                if (r < 0)\n                        goto finish;\n\n                if (arg_no_reload) {\n                        r = 0;\n                        goto finish;\n                }\n\n                r = daemon_reload(argc, argv, userdata);\n        }\n\nfinish:\n        unit_file_changes_free(changes, n_changes);\n\n        return r;\n}\n\nstatic int preset_all(int argc, char *argv[], void *userdata) {\n        UnitFileChange *changes = NULL;\n        size_t n_changes = 0;\n        int r;\n\n        if (install_client_side()) {\n                r = unit_file_preset_all(arg_scope, args_to_flags(), arg_root, arg_preset_mode, &changes, &n_changes);\n                unit_file_dump_changes(r, \"preset\", changes, n_changes, arg_quiet);\n\n                if (r > 0)\n                        r = 0;\n        } else {\n                _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n                _cleanup_(sd_bus_message_unrefp) sd_bus_message *reply = NULL;\n                sd_bus *bus;\n\n                r = acquire_bus(BUS_MANAGER, &bus);\n                if (r < 0)\n                        return r;\n\n                polkit_agent_open_maybe();\n\n                r = sd_bus_call_method(\n                                bus,\n                                \"org.freedesktop.systemd1\",\n                                \"/org/freedesktop/systemd1\",\n                                \"org.freedesktop.systemd1.Manager\",\n                                \"PresetAllUnitFiles\",\n                                &error,\n                                &reply,\n                                \"sbb\",\n                                unit_file_preset_mode_to_string(arg_preset_mode),\n                                arg_runtime,\n                                arg_force);\n                if (r < 0)\n                        return log_error_errno(r, \"Failed to preset all units: %s\", bus_error_message(&error, r));\n\n                r = bus_deserialize_and_dump_unit_file_changes(reply, arg_quiet, &changes, &n_changes);\n                if (r < 0)\n                        goto finish;\n\n                if (arg_no_reload) {\n                        r = 0;\n                        goto finish;\n                }\n\n                r = daemon_reload(argc, argv, userdata);\n        }\n\nfinish:\n        unit_file_changes_free(changes, n_changes);\n\n        return r;\n}\n\nstatic int show_installation_targets_client_side(const char *name) {\n        UnitFileChange *changes = NULL;\n        size_t n_changes = 0, i;\n        UnitFileFlags flags;\n        char **p;\n        int r;\n\n        p = STRV_MAKE(name);\n        flags = UNIT_FILE_DRY_RUN |\n                (arg_runtime ? UNIT_FILE_RUNTIME : 0);\n\n        r = unit_file_disable(UNIT_FILE_SYSTEM, flags, NULL, p, &changes, &n_changes);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to get file links for %s: %m\", name);\n\n        for (i = 0; i < n_changes; i++)\n                if (changes[i].type == UNIT_FILE_UNLINK)\n                        printf(\"  %s\\n\", changes[i].path);\n\n        return 0;\n}\n\nstatic int show_installation_targets(sd_bus *bus, const char *name) {\n        _cleanup_(sd_bus_message_unrefp) sd_bus_message *reply = NULL;\n        _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n        const char *link;\n        int r;\n\n        r = sd_bus_call_method(\n                        bus,\n                        \"org.freedesktop.systemd1\",\n                        \"/org/freedesktop/systemd1\",\n                        \"org.freedesktop.systemd1.Manager\",\n                        \"GetUnitFileLinks\",\n                        &error,\n                        &reply,\n                        \"sb\", name, arg_runtime);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to get unit file links for %s: %s\", name, bus_error_message(&error, r));\n\n        r = sd_bus_message_enter_container(reply, SD_BUS_TYPE_ARRAY, \"s\");\n        if (r < 0)\n                return bus_log_parse_error(r);\n\n        while ((r = sd_bus_message_read(reply, \"s\", &link)) > 0)\n                printf(\"  %s\\n\", link);\n\n        if (r < 0)\n                return bus_log_parse_error(r);\n\n        r = sd_bus_message_exit_container(reply);\n        if (r < 0)\n                return bus_log_parse_error(r);\n\n        return 0;\n}\n\nstatic int unit_is_enabled(int argc, char *argv[], void *userdata) {\n        _cleanup_strv_free_ char **names = NULL;\n        bool enabled;\n        char **name;\n        int r;\n\n        r = mangle_names(strv_skip(argv, 1), &names);\n        if (r < 0)\n                return r;\n\n        r = enable_sysv_units(argv[0], names);\n        if (r < 0)\n                return r;\n\n        enabled = r > 0;\n\n        if (install_client_side()) {\n                STRV_FOREACH(name, names) {\n                        UnitFileState state;\n\n                        r = unit_file_get_state(arg_scope, arg_root, *name, &state);\n                        if (r < 0)\n                                return log_error_errno(r, \"Failed to get unit file state for %s: %m\", *name);\n\n                        if (IN_SET(state,\n                                   UNIT_FILE_ENABLED,\n                                   UNIT_FILE_ENABLED_RUNTIME,\n                                   UNIT_FILE_STATIC,\n                                   UNIT_FILE_INDIRECT,\n                                   UNIT_FILE_GENERATED))\n                                enabled = true;\n\n                        if (!arg_quiet) {\n                                puts(unit_file_state_to_string(state));\n                                if (arg_full) {\n                                        r = show_installation_targets_client_side(*name);\n                                        if (r < 0)\n                                                return r;\n                                }\n                        }\n                }\n\n                r = 0;\n        } else {\n                _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n                sd_bus *bus;\n\n                r = acquire_bus(BUS_MANAGER, &bus);\n                if (r < 0)\n                        return r;\n\n                STRV_FOREACH(name, names) {\n                        _cleanup_(sd_bus_message_unrefp) sd_bus_message *reply = NULL;\n                        const char *s;\n\n                        r = sd_bus_call_method(\n                                        bus,\n                                        \"org.freedesktop.systemd1\",\n                                        \"/org/freedesktop/systemd1\",\n                                        \"org.freedesktop.systemd1.Manager\",\n                                        \"GetUnitFileState\",\n                                        &error,\n                                        &reply,\n                                        \"s\", *name);\n                        if (r < 0)\n                                return log_error_errno(r, \"Failed to get unit file state for %s: %s\", *name, bus_error_message(&error, r));\n\n                        r = sd_bus_message_read(reply, \"s\", &s);\n                        if (r < 0)\n                                return bus_log_parse_error(r);\n\n                        if (STR_IN_SET(s, \"enabled\", \"enabled-runtime\", \"static\", \"indirect\", \"generated\"))\n                                enabled = true;\n\n                        if (!arg_quiet) {\n                                puts(s);\n                                if (arg_full) {\n                                        r = show_installation_targets(bus, *name);\n                                        if (r < 0)\n                                                return r;\n                                }\n                        }\n                }\n        }\n\n        return enabled ? EXIT_SUCCESS : EXIT_FAILURE;\n}\n\nstatic int is_system_running(int argc, char *argv[], void *userdata) {\n        _cleanup_free_ char *state = NULL;\n        sd_bus *bus;\n        int r;\n\n        if (running_in_chroot() > 0 || (arg_transport == BUS_TRANSPORT_LOCAL && !sd_booted())) {\n                if (!arg_quiet)\n                        puts(\"offline\");\n                return EXIT_FAILURE;\n        }\n\n        r = acquire_bus(BUS_MANAGER, &bus);\n        if (r < 0)\n                return r;\n\n        r = sd_bus_get_property_string(\n                        bus,\n                        \"org.freedesktop.systemd1\",\n                        \"/org/freedesktop/systemd1\",\n                        \"org.freedesktop.systemd1.Manager\",\n                        \"SystemState\",\n                        NULL,\n                        &state);\n        if (r < 0) {\n                if (!arg_quiet)\n                        puts(\"unknown\");\n                return 0;\n        }\n\n        if (!arg_quiet)\n                puts(state);\n\n        return streq(state, \"running\") ? EXIT_SUCCESS : EXIT_FAILURE;\n}\n\nstatic int create_edit_temp_file(const char *new_path, const char *original_path, char **ret_tmp_fn) {\n        _cleanup_free_ char *t = NULL;\n        int r;\n\n        assert(new_path);\n        assert(original_path);\n        assert(ret_tmp_fn);\n\n        r = tempfn_random(new_path, NULL, &t);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to determine temporary filename for \\\"%s\\\": %m\", new_path);\n\n        r = mkdir_parents(new_path, 0755);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to create directories for \\\"%s\\\": %m\", new_path);\n\n        r = copy_file(original_path, t, 0, 0644, 0, COPY_REFLINK);\n        if (r == -ENOENT) {\n\n                r = touch(t);\n                if (r < 0)\n                        return log_error_errno(r, \"Failed to create temporary file \\\"%s\\\": %m\", t);\n\n        } else if (r < 0)\n                return log_error_errno(r, \"Failed to create temporary file for \\\"%s\\\": %m\", new_path);\n\n        *ret_tmp_fn = TAKE_PTR(t);\n\n        return 0;\n}\n\nstatic int get_file_to_edit(\n                const LookupPaths *paths,\n                const char *name,\n                char **ret_path) {\n\n        _cleanup_free_ char *path = NULL, *run = NULL;\n\n        assert(name);\n        assert(ret_path);\n\n        path = strjoin(paths->persistent_config, \"/\", name);\n        if (!path)\n                return log_oom();\n\n        if (arg_runtime) {\n                run = strjoin(paths->runtime_config, \"/\", name);\n                if (!run)\n                        return log_oom();\n        }\n\n        if (arg_runtime) {\n                if (access(path, F_OK) >= 0) {\n                        log_error(\"Refusing to create \\\"%s\\\" because it would be overridden by \\\"%s\\\" anyway.\", run, path);\n                        return -EEXIST;\n                }\n\n                *ret_path = TAKE_PTR(run);\n        } else\n                *ret_path = TAKE_PTR(path);\n\n        return 0;\n}\n\nstatic int unit_file_create_new(\n                const LookupPaths *paths,\n                const char *unit_name,\n                const char *suffix,\n                char **ret_new_path,\n                char **ret_tmp_path) {\n\n        char *tmp_new_path, *tmp_tmp_path, *ending;\n        int r;\n\n        assert(unit_name);\n        assert(ret_new_path);\n        assert(ret_tmp_path);\n\n        ending = strjoina(unit_name, suffix);\n        r = get_file_to_edit(paths, ending, &tmp_new_path);\n        if (r < 0)\n                return r;\n\n        r = create_edit_temp_file(tmp_new_path, tmp_new_path, &tmp_tmp_path);\n        if (r < 0) {\n                free(tmp_new_path);\n                return r;\n        }\n\n        *ret_new_path = tmp_new_path;\n        *ret_tmp_path = tmp_tmp_path;\n\n        return 0;\n}\n\nstatic int unit_file_create_copy(\n                const LookupPaths *paths,\n                const char *unit_name,\n                const char *fragment_path,\n                char **ret_new_path,\n                char **ret_tmp_path) {\n\n        char *tmp_new_path, *tmp_tmp_path;\n        int r;\n\n        assert(fragment_path);\n        assert(unit_name);\n        assert(ret_new_path);\n        assert(ret_tmp_path);\n\n        r = get_file_to_edit(paths, unit_name, &tmp_new_path);\n        if (r < 0)\n                return r;\n\n        if (!path_equal(fragment_path, tmp_new_path) && access(tmp_new_path, F_OK) == 0) {\n                char response;\n\n                r = ask_char(&response, \"yn\", \"\\\"%s\\\" already exists. Overwrite with \\\"%s\\\"? [(y)es, (n)o] \", tmp_new_path, fragment_path);\n                if (r < 0) {\n                        free(tmp_new_path);\n                        return r;\n                }\n                if (response != 'y') {\n                        log_warning(\"%s ignored\", unit_name);\n                        free(tmp_new_path);\n                        return -EKEYREJECTED;\n                }\n        }\n\n        r = create_edit_temp_file(tmp_new_path, fragment_path, &tmp_tmp_path);\n        if (r < 0) {\n                free(tmp_new_path);\n                return r;\n        }\n\n        *ret_new_path = tmp_new_path;\n        *ret_tmp_path = tmp_tmp_path;\n\n        return 0;\n}\n\nstatic int run_editor(char **paths) {\n        int r;\n\n        assert(paths);\n\n        r = safe_fork(\"(editor)\", FORK_RESET_SIGNALS|FORK_DEATHSIG|FORK_LOG|FORK_WAIT, NULL);\n        if (r < 0)\n                return r;\n        if (r == 0) {\n                const char **args;\n                char *editor, **editor_args = NULL;\n                char **tmp_path, **original_path, *p;\n                size_t n_editor_args = 0, i = 1;\n                size_t argc;\n\n                argc = strv_length(paths)/2 + 1;\n\n                /* SYSTEMD_EDITOR takes precedence over EDITOR which takes precedence over VISUAL\n                 * If neither SYSTEMD_EDITOR nor EDITOR nor VISUAL are present,\n                 * we try to execute well known editors\n                 */\n                editor = getenv(\"SYSTEMD_EDITOR\");\n                if (!editor)\n                        editor = getenv(\"EDITOR\");\n                if (!editor)\n                        editor = getenv(\"VISUAL\");\n\n                if (!isempty(editor)) {\n                        editor_args = strv_split(editor, WHITESPACE);\n                        if (!editor_args) {\n                                (void) log_oom();\n                                _exit(EXIT_FAILURE);\n                        }\n                        n_editor_args = strv_length(editor_args);\n                        argc += n_editor_args - 1;\n                }\n                args = newa(const char*, argc + 1);\n\n                if (n_editor_args > 0) {\n                        args[0] = editor_args[0];\n                        for (; i < n_editor_args; i++)\n                                args[i] = editor_args[i];\n                }\n\n                STRV_FOREACH_PAIR(original_path, tmp_path, paths) {\n                        args[i] = *tmp_path;\n                        i++;\n                }\n                args[i] = NULL;\n\n                if (n_editor_args > 0)\n                        execvp(args[0], (char* const*) args);\n\n                FOREACH_STRING(p, \"editor\", \"nano\", \"vim\", \"vi\") {\n                        args[0] = p;\n                        execvp(p, (char* const*) args);\n                        /* We do not fail if the editor doesn't exist\n                         * because we want to try each one of them before\n                         * failing.\n                         */\n                        if (errno != ENOENT) {\n                                log_error_errno(errno, \"Failed to execute %s: %m\", editor);\n                                _exit(EXIT_FAILURE);\n                        }\n                }\n\n                log_error(\"Cannot edit unit(s), no editor available. Please set either $SYSTEMD_EDITOR, $EDITOR or $VISUAL.\");\n                _exit(EXIT_FAILURE);\n        }\n\n        return 0;\n}\n\nstatic int find_paths_to_edit(sd_bus *bus, char **names, char ***paths) {\n        _cleanup_(lookup_paths_free) LookupPaths lp = {};\n        char **name;\n        int r;\n\n        assert(names);\n        assert(paths);\n\n        r = lookup_paths_init(&lp, arg_scope, 0, arg_root);\n        if (r < 0)\n                return r;\n\n        STRV_FOREACH(name, names) {\n                _cleanup_free_ char *path = NULL, *new_path = NULL, *tmp_path = NULL, *tmp_name = NULL;\n                const char *unit_name;\n\n                r = unit_find_paths(bus, *name, &lp, &path, NULL);\n                if (r < 0)\n                        return r;\n\n                if (r == 0) {\n                        assert(!path);\n\n                        if (!arg_force) {\n                                log_error(\"Run 'systemctl edit%s --force %s' to create a new unit.\",\n                                          arg_scope == UNIT_FILE_GLOBAL ? \" --global\" :\n                                          arg_scope == UNIT_FILE_USER ? \" --user\" : \"\",\n                                          *name);\n                                return -ENOENT;\n                        }\n\n                        /* Create a new unit from scratch */\n                        unit_name = *name;\n                        r = unit_file_create_new(&lp, unit_name,\n                                                 arg_full ? NULL : \".d/override.conf\",\n                                                 &new_path, &tmp_path);\n                } else {\n                        assert(path);\n\n                        unit_name = basename(path);\n                        /* We follow unit aliases, but we need to propagate the instance */\n                        if (unit_name_is_valid(*name, UNIT_NAME_INSTANCE) &&\n                            unit_name_is_valid(unit_name, UNIT_NAME_TEMPLATE)) {\n                                _cleanup_free_ char *instance = NULL;\n\n                                r = unit_name_to_instance(*name, &instance);\n                                if (r < 0)\n                                        return r;\n\n                                r = unit_name_replace_instance(unit_name, instance, &tmp_name);\n                                if (r < 0)\n                                        return r;\n\n                                unit_name = tmp_name;\n                        }\n\n                        if (arg_full)\n                                r = unit_file_create_copy(&lp, unit_name, path, &new_path, &tmp_path);\n                        else\n                                r = unit_file_create_new(&lp, unit_name, \".d/override.conf\", &new_path, &tmp_path);\n                }\n                if (r < 0)\n                        return r;\n\n                r = strv_push_pair(paths, new_path, tmp_path);\n                if (r < 0)\n                        return log_oom();\n                new_path = tmp_path = NULL;\n        }\n\n        return 0;\n}\n\nstatic int edit(int argc, char *argv[], void *userdata) {\n        _cleanup_strv_free_ char **names = NULL;\n        _cleanup_strv_free_ char **paths = NULL;\n        char **original, **tmp;\n        sd_bus *bus;\n        int r;\n\n        if (!on_tty()) {\n                log_error(\"Cannot edit units if not on a tty.\");\n                return -EINVAL;\n        }\n\n        if (arg_transport != BUS_TRANSPORT_LOCAL) {\n                log_error(\"Cannot edit units remotely.\");\n                return -EINVAL;\n        }\n\n        r = acquire_bus(BUS_MANAGER, &bus);\n        if (r < 0)\n                return r;\n\n        r = expand_names(bus, strv_skip(argv, 1), NULL, &names);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to expand names: %m\");\n\n        STRV_FOREACH(tmp, names) {\n                r = unit_is_masked(bus, *tmp);\n                if (r < 0)\n                        return r;\n\n                if (r > 0) {\n                        log_error(\"Cannot edit %s: unit is masked.\", *tmp);\n                        return -EINVAL;\n                }\n        }\n\n        r = find_paths_to_edit(bus, names, &paths);\n        if (r < 0)\n                return r;\n\n        if (strv_isempty(paths))\n                return -ENOENT;\n\n        r = run_editor(paths);\n        if (r < 0)\n                goto end;\n\n        STRV_FOREACH_PAIR(original, tmp, paths) {\n                /* If the temporary file is empty we ignore it.\n                 * This allows the user to cancel the modification.\n                 */\n                if (null_or_empty_path(*tmp)) {\n                        log_warning(\"Editing \\\"%s\\\" canceled: temporary file is empty.\", *original);\n                        continue;\n                }\n\n                r = rename(*tmp, *original);\n                if (r < 0) {\n                        r = log_error_errno(errno, \"Failed to rename \\\"%s\\\" to \\\"%s\\\": %m\", *tmp, *original);\n                        goto end;\n                }\n        }\n\n        r = 0;\n\n        if (!arg_no_reload && !install_client_side())\n                r = daemon_reload(argc, argv, userdata);\n\nend:\n        STRV_FOREACH_PAIR(original, tmp, paths) {\n                (void) unlink(*tmp);\n\n                /* Removing empty dropin dirs */\n                if (!arg_full) {\n                        _cleanup_free_ char *dir;\n\n                        dir = dirname_malloc(*original);\n                        if (!dir)\n                                return log_oom();\n\n                        /* no need to check if the dir is empty, rmdir\n                         * does nothing if it is not the case.\n                         */\n                        (void) rmdir(dir);\n                }\n        }\n\n        return r;\n}\n\nstatic void systemctl_help(void) {\n        (void) pager_open(arg_no_pager, false);\n\n        printf(\"%s [OPTIONS...] {COMMAND} ...\\n\\n\"\n               \"Query or send control commands to the systemd manager.\\n\\n\"\n               \"  -h --help           Show this help\\n\"\n               \"     --version        Show package version\\n\"\n               \"     --system         Connect to system manager\\n\"\n               \"     --user           Connect to user service manager\\n\"\n               \"  -H --host=[USER@]HOST\\n\"\n               \"                      Operate on remote host\\n\"\n               \"  -M --machine=CONTAINER\\n\"\n               \"                      Operate on local container\\n\"\n               \"  -t --type=TYPE      List units of a particular type\\n\"\n               \"     --state=STATE    List units with particular LOAD or SUB or ACTIVE state\\n\"\n               \"  -p --property=NAME  Show only properties by this name\\n\"\n               \"  -a --all            Show all properties/all units currently in memory,\\n\"\n               \"                      including dead/empty ones. To list all units installed on\\n\"\n               \"                      the system, use the 'list-unit-files' command instead.\\n\"\n               \"     --failed         Same as --state=failed\\n\"\n               \"  -l --full           Don't ellipsize unit names on output\\n\"\n               \"  -r --recursive      Show unit list of host and local containers\\n\"\n               \"     --reverse        Show reverse dependencies with 'list-dependencies'\\n\"\n               \"     --job-mode=MODE  Specify how to deal with already queued jobs, when\\n\"\n               \"                      queueing a new job\\n\"\n               \"     --show-types     When showing sockets, explicitly show their type\\n\"\n               \"     --value          When showing properties, only print the value\\n\"\n               \"  -i --ignore-inhibitors\\n\"\n               \"                      When shutting down or sleeping, ignore inhibitors\\n\"\n               \"     --kill-who=WHO   Who to send signal to\\n\"\n               \"  -s --signal=SIGNAL  Which signal to send\\n\"\n               \"     --now            Start or stop unit in addition to enabling or disabling it\\n\"\n               \"     --dry-run        Only print what would be done\\n\"\n               \"  -q --quiet          Suppress output\\n\"\n               \"     --wait           For (re)start, wait until service stopped again\\n\"\n               \"     --no-block       Do not wait until operation finished\\n\"\n               \"     --no-wall        Don't send wall message before halt/power-off/reboot\\n\"\n               \"     --no-reload      Don't reload daemon after en-/dis-abling unit files\\n\"\n               \"     --no-legend      Do not print a legend (column headers and hints)\\n\"\n               \"     --no-pager       Do not pipe output into a pager\\n\"\n               \"     --no-ask-password\\n\"\n               \"                      Do not ask for system passwords\\n\"\n               \"     --global         Enable/disable/mask unit files globally\\n\"\n               \"     --runtime        Enable/disable/mask unit files temporarily until next\\n\"\n               \"                      reboot\\n\"\n               \"  -f --force          When enabling unit files, override existing symlinks\\n\"\n               \"                      When shutting down, execute action immediately\\n\"\n               \"     --preset-mode=   Apply only enable, only disable, or all presets\\n\"\n               \"     --root=PATH      Enable/disable/mask unit files in the specified root\\n\"\n               \"                      directory\\n\"\n               \"  -n --lines=INTEGER  Number of journal entries to show\\n\"\n               \"  -o --output=STRING  Change journal output mode (short, short-precise,\\n\"\n               \"                             short-iso, short-iso-precise, short-full,\\n\"\n               \"                             short-monotonic, short-unix,\\n\"\n               \"                             verbose, export, json, json-pretty, json-sse, cat)\\n\"\n               \"     --firmware-setup Tell the firmware to show the setup menu on next boot\\n\"\n               \"     --plain          Print unit dependencies as a list instead of a tree\\n\\n\"\n               \"Unit Commands:\\n\"\n               \"  list-units [PATTERN...]             List units currently in memory\\n\"\n               \"  list-sockets [PATTERN...]           List socket units currently in memory,\\n\"\n               \"                                      ordered by address\\n\"\n               \"  list-timers [PATTERN...]            List timer units currently in memory,\\n\"\n               \"                                      ordered by next elapse\\n\"\n               \"  start UNIT...                       Start (activate) one or more units\\n\"\n               \"  stop UNIT...                        Stop (deactivate) one or more units\\n\"\n               \"  reload UNIT...                      Reload one or more units\\n\"\n               \"  restart UNIT...                     Start or restart one or more units\\n\"\n               \"  try-restart UNIT...                 Restart one or more units if active\\n\"\n               \"  reload-or-restart UNIT...           Reload one or more units if possible,\\n\"\n               \"                                      otherwise start or restart\\n\"\n               \"  try-reload-or-restart UNIT...       If active, reload one or more units,\\n\"\n               \"                                      if supported, otherwise restart\\n\"\n               \"  isolate UNIT                        Start one unit and stop all others\\n\"\n               \"  kill UNIT...                        Send signal to processes of a unit\\n\"\n               \"  is-active PATTERN...                Check whether units are active\\n\"\n               \"  is-failed PATTERN...                Check whether units are failed\\n\"\n               \"  status [PATTERN...|PID...]          Show runtime status of one or more units\\n\"\n               \"  show [PATTERN...|JOB...]            Show properties of one or more\\n\"\n               \"                                      units/jobs or the manager\\n\"\n               \"  cat PATTERN...                      Show files and drop-ins of specified units\\n\"\n               \"  set-property UNIT PROPERTY=VALUE... Sets one or more properties of a unit\\n\"\n               \"  help PATTERN...|PID...              Show manual for one or more units\\n\"\n               \"  reset-failed [PATTERN...]           Reset failed state for all, one, or more\\n\"\n               \"                                      units\\n\"\n               \"  list-dependencies [UNIT]            Recursively show units which are required\\n\"\n               \"                                      or wanted by this unit or by which this\\n\"\n               \"                                      unit is required or wanted\\n\\n\"\n               \"Unit File Commands:\\n\"\n               \"  list-unit-files [PATTERN...]        List installed unit files\\n\"\n               \"  enable [UNIT...|PATH...]            Enable one or more unit files\\n\"\n               \"  disable UNIT...                     Disable one or more unit files\\n\"\n               \"  reenable UNIT...                    Reenable one or more unit files\\n\"\n               \"  preset UNIT...                      Enable/disable one or more unit files\\n\"\n               \"                                      based on preset configuration\\n\"\n               \"  preset-all                          Enable/disable all unit files based on\\n\"\n               \"                                      preset configuration\\n\"\n               \"  is-enabled UNIT...                  Check whether unit files are enabled\\n\"\n               \"  mask UNIT...                        Mask one or more units\\n\"\n               \"  unmask UNIT...                      Unmask one or more units\\n\"\n               \"  link PATH...                        Link one or more units files into\\n\"\n               \"                                      the search path\\n\"\n               \"  revert UNIT...                      Revert one or more unit files to vendor\\n\"\n               \"                                      version\\n\"\n               \"  add-wants TARGET UNIT...            Add 'Wants' dependency for the target\\n\"\n               \"                                      on specified one or more units\\n\"\n               \"  add-requires TARGET UNIT...         Add 'Requires' dependency for the target\\n\"\n               \"                                      on specified one or more units\\n\"\n               \"  edit UNIT...                        Edit one or more unit files\\n\"\n               \"  get-default                         Get the name of the default target\\n\"\n               \"  set-default TARGET                  Set the default target\\n\\n\"\n               \"Machine Commands:\\n\"\n               \"  list-machines [PATTERN...]          List local containers and host\\n\\n\"\n               \"Job Commands:\\n\"\n               \"  list-jobs [PATTERN...]              List jobs\\n\"\n               \"  cancel [JOB...]                     Cancel all, one, or more jobs\\n\\n\"\n               \"Environment Commands:\\n\"\n               \"  show-environment                    Dump environment\\n\"\n               \"  set-environment VARIABLE=VALUE...   Set one or more environment variables\\n\"\n               \"  unset-environment VARIABLE...       Unset one or more environment variables\\n\"\n               \"  import-environment [VARIABLE...]    Import all or some environment variables\\n\\n\"\n               \"Manager Lifecycle Commands:\\n\"\n               \"  daemon-reload                       Reload systemd manager configuration\\n\"\n               \"  daemon-reexec                       Reexecute systemd manager\\n\\n\"\n               \"System Commands:\\n\"\n               \"  is-system-running                   Check whether system is fully running\\n\"\n               \"  default                             Enter system default mode\\n\"\n               \"  rescue                              Enter system rescue mode\\n\"\n               \"  emergency                           Enter system emergency mode\\n\"\n               \"  halt                                Shut down and halt the system\\n\"\n               \"  poweroff                            Shut down and power-off the system\\n\"\n               \"  reboot [ARG]                        Shut down and reboot the system\\n\"\n               \"  kexec                               Shut down and reboot the system with kexec\\n\"\n               \"  exit [EXIT_CODE]                    Request user instance or container exit\\n\"\n               \"  switch-root ROOT [INIT]             Change to a different root file system\\n\"\n               \"  suspend                             Suspend the system\\n\"\n               \"  hibernate                           Hibernate the system\\n\"\n               \"  hybrid-sleep                        Hibernate and suspend the system\\n\"\n               \"  suspend-then-hibernate              Suspend the system, wake after a period of\\n\"\n               \"                                      time and put it into hibernate\\n\",\n               program_invocation_short_name);\n}\n\nstatic void halt_help(void) {\n        printf(\"%s [OPTIONS...]%s\\n\\n\"\n               \"%s the system.\\n\\n\"\n               \"     --help      Show this help\\n\"\n               \"     --halt      Halt the machine\\n\"\n               \"  -p --poweroff  Switch off the machine\\n\"\n               \"     --reboot    Reboot the machine\\n\"\n               \"  -f --force     Force immediate halt/power-off/reboot\\n\"\n               \"  -w --wtmp-only Don't halt/power-off/reboot, just write wtmp record\\n\"\n               \"  -d --no-wtmp   Don't write wtmp record\\n\"\n               \"     --no-wall   Don't send wall message before halt/power-off/reboot\\n\",\n               program_invocation_short_name,\n               arg_action == ACTION_REBOOT   ? \" [ARG]\" : \"\",\n               arg_action == ACTION_REBOOT   ? \"Reboot\" :\n               arg_action == ACTION_POWEROFF ? \"Power off\" :\n                                               \"Halt\");\n}\n\nstatic void shutdown_help(void) {\n        printf(\"%s [OPTIONS...] [TIME] [WALL...]\\n\\n\"\n               \"Shut down the system.\\n\\n\"\n               \"     --help      Show this help\\n\"\n               \"  -H --halt      Halt the machine\\n\"\n               \"  -P --poweroff  Power-off the machine\\n\"\n               \"  -r --reboot    Reboot the machine\\n\"\n               \"  -h             Equivalent to --poweroff, overridden by --halt\\n\"\n               \"  -k             Don't halt/power-off/reboot, just send warnings\\n\"\n               \"     --no-wall   Don't send wall message before halt/power-off/reboot\\n\"\n               \"  -c             Cancel a pending shutdown\\n\",\n               program_invocation_short_name);\n}\n\nstatic void telinit_help(void) {\n        printf(\"%s [OPTIONS...] {COMMAND}\\n\\n\"\n               \"Send control commands to the init daemon.\\n\\n\"\n               \"     --help      Show this help\\n\"\n               \"     --no-wall   Don't send wall message before halt/power-off/reboot\\n\\n\"\n               \"Commands:\\n\"\n               \"  0              Power-off the machine\\n\"\n               \"  6              Reboot the machine\\n\"\n               \"  2, 3, 4, 5     Start runlevelX.target unit\\n\"\n               \"  1, s, S        Enter rescue mode\\n\"\n               \"  q, Q           Reload init daemon configuration\\n\"\n               \"  u, U           Reexecute init daemon\\n\",\n               program_invocation_short_name);\n}\n\nstatic void runlevel_help(void) {\n        printf(\"%s [OPTIONS...]\\n\\n\"\n               \"Prints the previous and current runlevel of the init system.\\n\\n\"\n               \"     --help      Show this help\\n\",\n               program_invocation_short_name);\n}\n\nstatic void help_types(void) {\n        if (!arg_no_legend)\n                puts(\"Available unit types:\");\n\n        DUMP_STRING_TABLE(unit_type, UnitType, _UNIT_TYPE_MAX);\n}\n\nstatic void help_states(void) {\n        if (!arg_no_legend)\n                puts(\"Available unit load states:\");\n        DUMP_STRING_TABLE(unit_load_state, UnitLoadState, _UNIT_LOAD_STATE_MAX);\n\n        if (!arg_no_legend)\n                puts(\"\\nAvailable unit active states:\");\n        DUMP_STRING_TABLE(unit_active_state, UnitActiveState, _UNIT_ACTIVE_STATE_MAX);\n\n        if (!arg_no_legend)\n                puts(\"\\nAvailable automount unit substates:\");\n        DUMP_STRING_TABLE(automount_state, AutomountState, _AUTOMOUNT_STATE_MAX);\n\n        if (!arg_no_legend)\n                puts(\"\\nAvailable device unit substates:\");\n        DUMP_STRING_TABLE(device_state, DeviceState, _DEVICE_STATE_MAX);\n\n        if (!arg_no_legend)\n                puts(\"\\nAvailable mount unit substates:\");\n        DUMP_STRING_TABLE(mount_state, MountState, _MOUNT_STATE_MAX);\n\n        if (!arg_no_legend)\n                puts(\"\\nAvailable path unit substates:\");\n        DUMP_STRING_TABLE(path_state, PathState, _PATH_STATE_MAX);\n\n        if (!arg_no_legend)\n                puts(\"\\nAvailable scope unit substates:\");\n        DUMP_STRING_TABLE(scope_state, ScopeState, _SCOPE_STATE_MAX);\n\n        if (!arg_no_legend)\n                puts(\"\\nAvailable service unit substates:\");\n        DUMP_STRING_TABLE(service_state, ServiceState, _SERVICE_STATE_MAX);\n\n        if (!arg_no_legend)\n                puts(\"\\nAvailable slice unit substates:\");\n        DUMP_STRING_TABLE(slice_state, SliceState, _SLICE_STATE_MAX);\n\n        if (!arg_no_legend)\n                puts(\"\\nAvailable socket unit substates:\");\n        DUMP_STRING_TABLE(socket_state, SocketState, _SOCKET_STATE_MAX);\n\n        if (!arg_no_legend)\n                puts(\"\\nAvailable swap unit substates:\");\n        DUMP_STRING_TABLE(swap_state, SwapState, _SWAP_STATE_MAX);\n\n        if (!arg_no_legend)\n                puts(\"\\nAvailable target unit substates:\");\n        DUMP_STRING_TABLE(target_state, TargetState, _TARGET_STATE_MAX);\n\n        if (!arg_no_legend)\n                puts(\"\\nAvailable timer unit substates:\");\n        DUMP_STRING_TABLE(timer_state, TimerState, _TIMER_STATE_MAX);\n}\n\nstatic int systemctl_parse_argv(int argc, char *argv[]) {\n        enum {\n                ARG_FAIL = 0x100,\n                ARG_REVERSE,\n                ARG_AFTER,\n                ARG_BEFORE,\n                ARG_DRY_RUN,\n                ARG_SHOW_TYPES,\n                ARG_IRREVERSIBLE,\n                ARG_IGNORE_DEPENDENCIES,\n                ARG_VALUE,\n                ARG_VERSION,\n                ARG_USER,\n                ARG_SYSTEM,\n                ARG_GLOBAL,\n                ARG_NO_BLOCK,\n                ARG_NO_LEGEND,\n                ARG_NO_PAGER,\n                ARG_NO_WALL,\n                ARG_ROOT,\n                ARG_NO_RELOAD,\n                ARG_KILL_WHO,\n                ARG_NO_ASK_PASSWORD,\n                ARG_FAILED,\n                ARG_RUNTIME,\n                ARG_PLAIN,\n                ARG_STATE,\n                ARG_JOB_MODE,\n                ARG_PRESET_MODE,\n                ARG_FIRMWARE_SETUP,\n                ARG_NOW,\n                ARG_MESSAGE,\n                ARG_WAIT,\n        };\n\n        static const struct option options[] = {\n                { \"help\",                no_argument,       NULL, 'h'                     },\n                { \"version\",             no_argument,       NULL, ARG_VERSION             },\n                { \"type\",                required_argument, NULL, 't'                     },\n                { \"property\",            required_argument, NULL, 'p'                     },\n                { \"all\",                 no_argument,       NULL, 'a'                     },\n                { \"reverse\",             no_argument,       NULL, ARG_REVERSE             },\n                { \"after\",               no_argument,       NULL, ARG_AFTER               },\n                { \"before\",              no_argument,       NULL, ARG_BEFORE              },\n                { \"show-types\",          no_argument,       NULL, ARG_SHOW_TYPES          },\n                { \"failed\",              no_argument,       NULL, ARG_FAILED              }, /* compatibility only */\n                { \"full\",                no_argument,       NULL, 'l'                     },\n                { \"job-mode\",            required_argument, NULL, ARG_JOB_MODE            },\n                { \"fail\",                no_argument,       NULL, ARG_FAIL                }, /* compatibility only */\n                { \"irreversible\",        no_argument,       NULL, ARG_IRREVERSIBLE        }, /* compatibility only */\n                { \"ignore-dependencies\", no_argument,       NULL, ARG_IGNORE_DEPENDENCIES }, /* compatibility only */\n                { \"ignore-inhibitors\",   no_argument,       NULL, 'i'                     },\n                { \"value\",               no_argument,       NULL, ARG_VALUE               },\n                { \"user\",                no_argument,       NULL, ARG_USER                },\n                { \"system\",              no_argument,       NULL, ARG_SYSTEM              },\n                { \"global\",              no_argument,       NULL, ARG_GLOBAL              },\n                { \"wait\",                no_argument,       NULL, ARG_WAIT                },\n                { \"no-block\",            no_argument,       NULL, ARG_NO_BLOCK            },\n                { \"no-legend\",           no_argument,       NULL, ARG_NO_LEGEND           },\n                { \"no-pager\",            no_argument,       NULL, ARG_NO_PAGER            },\n                { \"no-wall\",             no_argument,       NULL, ARG_NO_WALL             },\n                { \"dry-run\",             no_argument,       NULL, ARG_DRY_RUN             },\n                { \"quiet\",               no_argument,       NULL, 'q'                     },\n                { \"root\",                required_argument, NULL, ARG_ROOT                },\n                { \"force\",               no_argument,       NULL, 'f'                     },\n                { \"no-reload\",           no_argument,       NULL, ARG_NO_RELOAD           },\n                { \"kill-who\",            required_argument, NULL, ARG_KILL_WHO            },\n                { \"signal\",              required_argument, NULL, 's'                     },\n                { \"no-ask-password\",     no_argument,       NULL, ARG_NO_ASK_PASSWORD     },\n                { \"host\",                required_argument, NULL, 'H'                     },\n                { \"machine\",             required_argument, NULL, 'M'                     },\n                { \"runtime\",             no_argument,       NULL, ARG_RUNTIME             },\n                { \"lines\",               required_argument, NULL, 'n'                     },\n                { \"output\",              required_argument, NULL, 'o'                     },\n                { \"plain\",               no_argument,       NULL, ARG_PLAIN               },\n                { \"state\",               required_argument, NULL, ARG_STATE               },\n                { \"recursive\",           no_argument,       NULL, 'r'                     },\n                { \"preset-mode\",         required_argument, NULL, ARG_PRESET_MODE         },\n                { \"firmware-setup\",      no_argument,       NULL, ARG_FIRMWARE_SETUP      },\n                { \"now\",                 no_argument,       NULL, ARG_NOW                 },\n                { \"message\",             required_argument, NULL, ARG_MESSAGE             },\n                {}\n        };\n\n        const char *p;\n        int c, r;\n\n        assert(argc >= 0);\n        assert(argv);\n\n        /* we default to allowing interactive authorization only in systemctl (not in the legacy commands) */\n        arg_ask_password = true;\n\n        while ((c = getopt_long(argc, argv, \"ht:p:alqfs:H:M:n:o:ir\", options, NULL)) >= 0)\n\n                switch (c) {\n\n                case 'h':\n                        systemctl_help();\n                        return 0;\n\n                case ARG_VERSION:\n                        return version();\n\n                case 't': {\n                        if (isempty(optarg)) {\n                                log_error(\"--type= requires arguments.\");\n                                return -EINVAL;\n                        }\n\n                        for (p = optarg;;) {\n                                _cleanup_free_ char *type = NULL;\n\n                                r = extract_first_word(&p, &type, \",\", 0);\n                                if (r < 0)\n                                        return log_error_errno(r, \"Failed to parse type: %s\", optarg);\n                                if (r == 0)\n                                        break;\n\n                                if (streq(type, \"help\")) {\n                                        help_types();\n                                        return 0;\n                                }\n\n                                if (unit_type_from_string(type) >= 0) {\n                                        if (strv_push(&arg_types, type) < 0)\n                                                return log_oom();\n                                        type = NULL;\n                                        continue;\n                                }\n\n                                /* It's much nicer to use --state= for\n                                 * load states, but let's support this\n                                 * in --types= too for compatibility\n                                 * with old versions */\n                                if (unit_load_state_from_string(type) >= 0) {\n                                        if (strv_push(&arg_states, type) < 0)\n                                                return log_oom();\n                                        type = NULL;\n                                        continue;\n                                }\n\n                                log_error(\"Unknown unit type or load state '%s'.\", type);\n                                log_info(\"Use -t help to see a list of allowed values.\");\n                                return -EINVAL;\n                        }\n\n                        break;\n                }\n\n                case 'p': {\n                        /* Make sure that if the empty property list\n                           was specified, we won't show any properties. */\n                        if (isempty(optarg) && !arg_properties) {\n                                arg_properties = new0(char*, 1);\n                                if (!arg_properties)\n                                        return log_oom();\n                        } else\n                                for (p = optarg;;) {\n                                        _cleanup_free_ char *prop = NULL;\n\n                                        r = extract_first_word(&p, &prop, \",\", 0);\n                                        if (r < 0)\n                                                return log_error_errno(r, \"Failed to parse property: %s\", optarg);\n                                        if (r == 0)\n                                                break;\n\n                                        if (strv_push(&arg_properties, prop) < 0)\n                                                return log_oom();\n\n                                        prop = NULL;\n                                }\n\n                        /* If the user asked for a particular\n                         * property, show it to him, even if it is\n                         * empty. */\n                        arg_all = true;\n\n                        break;\n                }\n\n                case 'a':\n                        arg_all = true;\n                        break;\n\n                case ARG_REVERSE:\n                        arg_dependency = DEPENDENCY_REVERSE;\n                        break;\n\n                case ARG_AFTER:\n                        arg_dependency = DEPENDENCY_AFTER;\n                        arg_jobs_after = true;\n                        break;\n\n                case ARG_BEFORE:\n                        arg_dependency = DEPENDENCY_BEFORE;\n                        arg_jobs_before = true;\n                        break;\n\n                case ARG_SHOW_TYPES:\n                        arg_show_types = true;\n                        break;\n\n                case ARG_VALUE:\n                        arg_value = true;\n                        break;\n\n                case ARG_JOB_MODE:\n                        arg_job_mode = optarg;\n                        break;\n\n                case ARG_FAIL:\n                        arg_job_mode = \"fail\";\n                        break;\n\n                case ARG_IRREVERSIBLE:\n                        arg_job_mode = \"replace-irreversibly\";\n                        break;\n\n                case ARG_IGNORE_DEPENDENCIES:\n                        arg_job_mode = \"ignore-dependencies\";\n                        break;\n\n                case ARG_USER:\n                        arg_scope = UNIT_FILE_USER;\n                        break;\n\n                case ARG_SYSTEM:\n                        arg_scope = UNIT_FILE_SYSTEM;\n                        break;\n\n                case ARG_GLOBAL:\n                        arg_scope = UNIT_FILE_GLOBAL;\n                        break;\n\n                case ARG_WAIT:\n                        arg_wait = true;\n                        break;\n\n                case ARG_NO_BLOCK:\n                        arg_no_block = true;\n                        break;\n\n                case ARG_NO_LEGEND:\n                        arg_no_legend = true;\n                        break;\n\n                case ARG_NO_PAGER:\n                        arg_no_pager = true;\n                        break;\n\n                case ARG_NO_WALL:\n                        arg_no_wall = true;\n                        break;\n\n                case ARG_ROOT:\n                        r = parse_path_argument_and_warn(optarg, false, &arg_root);\n                        if (r < 0)\n                                return r;\n                        break;\n\n                case 'l':\n                        arg_full = true;\n                        break;\n\n                case ARG_FAILED:\n                        if (strv_extend(&arg_states, \"failed\") < 0)\n                                return log_oom();\n\n                        break;\n\n                case ARG_DRY_RUN:\n                        arg_dry_run = true;\n                        break;\n\n                case 'q':\n                        arg_quiet = true;\n                        break;\n\n                case 'f':\n                        arg_force++;\n                        break;\n\n                case ARG_NO_RELOAD:\n                        arg_no_reload = true;\n                        break;\n\n                case ARG_KILL_WHO:\n                        arg_kill_who = optarg;\n                        break;\n\n                case 's':\n                        if (streq(optarg, \"help\")) {\n                                DUMP_STRING_TABLE(signal, int, _NSIG);\n                                return 0;\n                        }\n\n                        arg_signal = signal_from_string(optarg);\n                        if (arg_signal < 0) {\n                                log_error(\"Failed to parse signal string %s.\", optarg);\n                                return -EINVAL;\n                        }\n                        break;\n\n                case ARG_NO_ASK_PASSWORD:\n                        arg_ask_password = false;\n                        break;\n\n                case 'H':\n                        arg_transport = BUS_TRANSPORT_REMOTE;\n                        arg_host = optarg;\n                        break;\n\n                case 'M':\n                        arg_transport = BUS_TRANSPORT_MACHINE;\n                        arg_host = optarg;\n                        break;\n\n                case ARG_RUNTIME:\n                        arg_runtime = true;\n                        break;\n\n                case 'n':\n                        if (safe_atou(optarg, &arg_lines) < 0) {\n                                log_error(\"Failed to parse lines '%s'\", optarg);\n                                return -EINVAL;\n                        }\n                        break;\n\n                case 'o':\n                        if (streq(optarg, \"help\")) {\n                                DUMP_STRING_TABLE(output_mode, OutputMode, _OUTPUT_MODE_MAX);\n                                return 0;\n                        }\n\n                        arg_output = output_mode_from_string(optarg);\n                        if (arg_output < 0) {\n                                log_error(\"Unknown output '%s'.\", optarg);\n                                return -EINVAL;\n                        }\n                        break;\n\n                case 'i':\n                        arg_ignore_inhibitors = true;\n                        break;\n\n                case ARG_PLAIN:\n                        arg_plain = true;\n                        break;\n\n                case ARG_FIRMWARE_SETUP:\n                        arg_firmware_setup = true;\n                        break;\n\n                case ARG_STATE: {\n                        if (isempty(optarg)) {\n                                log_error(\"--state= requires arguments.\");\n                                return -EINVAL;\n                        }\n\n                        for (p = optarg;;) {\n                                _cleanup_free_ char *s = NULL;\n\n                                r = extract_first_word(&p, &s, \",\", 0);\n                                if (r < 0)\n                                        return log_error_errno(r, \"Failed to parse state: %s\", optarg);\n                                if (r == 0)\n                                        break;\n\n                                if (streq(s, \"help\")) {\n                                        help_states();\n                                        return 0;\n                                }\n\n                                if (strv_push(&arg_states, s) < 0)\n                                        return log_oom();\n\n                                s = NULL;\n                        }\n                        break;\n                }\n\n                case 'r':\n                        if (geteuid() != 0) {\n                                log_error(\"--recursive requires root privileges.\");\n                                return -EPERM;\n                        }\n\n                        arg_recursive = true;\n                        break;\n\n                case ARG_PRESET_MODE:\n                        if (streq(optarg, \"help\")) {\n                                DUMP_STRING_TABLE(unit_file_preset_mode, UnitFilePresetMode, _UNIT_FILE_PRESET_MAX);\n                                return 0;\n                        }\n\n                        arg_preset_mode = unit_file_preset_mode_from_string(optarg);\n                        if (arg_preset_mode < 0) {\n                                log_error(\"Failed to parse preset mode: %s.\", optarg);\n                                return -EINVAL;\n                        }\n\n                        break;\n\n                case ARG_NOW:\n                        arg_now = true;\n                        break;\n\n                case ARG_MESSAGE:\n                        if (strv_extend(&arg_wall, optarg) < 0)\n                                return log_oom();\n                        break;\n\n                case '?':\n                        return -EINVAL;\n\n                default:\n                        assert_not_reached(\"Unhandled option\");\n                }\n\n        if (arg_transport != BUS_TRANSPORT_LOCAL && arg_scope != UNIT_FILE_SYSTEM) {\n                log_error(\"Cannot access user instance remotely.\");\n                return -EINVAL;\n        }\n\n        if (arg_wait && arg_no_block) {\n                log_error(\"--wait may not be combined with --no-block.\");\n                return -EINVAL;\n        }\n\n        if (arg_runtime && STRPTR_IN_SET(argv[optind], \"disable\", \"unmask\", \"preset\", \"preset-all\")) {\n                log_error(\"--runtime cannot be used with %s\", argv[optind]);\n                return -EINVAL;\n        }\n\n        return 1;\n}\n\nstatic int halt_parse_argv(int argc, char *argv[]) {\n        enum {\n                ARG_HELP = 0x100,\n                ARG_HALT,\n                ARG_REBOOT,\n                ARG_NO_WALL\n        };\n\n        static const struct option options[] = {\n                { \"help\",      no_argument,       NULL, ARG_HELP    },\n                { \"halt\",      no_argument,       NULL, ARG_HALT    },\n                { \"poweroff\",  no_argument,       NULL, 'p'         },\n                { \"reboot\",    no_argument,       NULL, ARG_REBOOT  },\n                { \"force\",     no_argument,       NULL, 'f'         },\n                { \"wtmp-only\", no_argument,       NULL, 'w'         },\n                { \"no-wtmp\",   no_argument,       NULL, 'd'         },\n                { \"no-sync\",   no_argument,       NULL, 'n'         },\n                { \"no-wall\",   no_argument,       NULL, ARG_NO_WALL },\n                {}\n        };\n\n        int c, r, runlevel;\n\n        assert(argc >= 0);\n        assert(argv);\n\n        if (utmp_get_runlevel(&runlevel, NULL) >= 0)\n                if (IN_SET(runlevel, '0', '6'))\n                        arg_force = 2;\n\n        while ((c = getopt_long(argc, argv, \"pfwdnih\", options, NULL)) >= 0)\n                switch (c) {\n\n                case ARG_HELP:\n                        halt_help();\n                        return 0;\n\n                case ARG_HALT:\n                        arg_action = ACTION_HALT;\n                        break;\n\n                case 'p':\n                        if (arg_action != ACTION_REBOOT)\n                                arg_action = ACTION_POWEROFF;\n                        break;\n\n                case ARG_REBOOT:\n                        arg_action = ACTION_REBOOT;\n                        break;\n\n                case 'f':\n                        arg_force = 2;\n                        break;\n\n                case 'w':\n                        arg_dry_run = true;\n                        break;\n\n                case 'd':\n                        arg_no_wtmp = true;\n                        break;\n\n                case 'n':\n                        arg_no_sync = true;\n                        break;\n\n                case ARG_NO_WALL:\n                        arg_no_wall = true;\n                        break;\n\n                case 'i':\n                case 'h':\n                        /* Compatibility nops */\n                        break;\n\n                case '?':\n                        return -EINVAL;\n\n                default:\n                        assert_not_reached(\"Unhandled option\");\n                }\n\n        if (arg_action == ACTION_REBOOT && (argc == optind || argc == optind + 1)) {\n                r = update_reboot_parameter_and_warn(argc == optind + 1 ? argv[optind] : NULL);\n                if (r < 0)\n                        return r;\n        } else if (optind < argc) {\n                log_error(\"Too many arguments.\");\n                return -EINVAL;\n        }\n\n        return 1;\n}\n\nstatic int parse_shutdown_time_spec(const char *t, usec_t *_u) {\n        assert(t);\n        assert(_u);\n\n        if (streq(t, \"now\"))\n                *_u = 0;\n        else if (!strchr(t, ':')) {\n                uint64_t u;\n\n                if (safe_atou64(t, &u) < 0)\n                        return -EINVAL;\n\n                *_u = now(CLOCK_REALTIME) + USEC_PER_MINUTE * u;\n        } else {\n                char *e = NULL;\n                long hour, minute;\n                struct tm tm = {};\n                time_t s;\n                usec_t n;\n\n                errno = 0;\n                hour = strtol(t, &e, 10);\n                if (errno > 0 || *e != ':' || hour < 0 || hour > 23)\n                        return -EINVAL;\n\n                minute = strtol(e+1, &e, 10);\n                if (errno > 0 || *e != 0 || minute < 0 || minute > 59)\n                        return -EINVAL;\n\n                n = now(CLOCK_REALTIME);\n                s = (time_t) (n / USEC_PER_SEC);\n\n                assert_se(localtime_r(&s, &tm));\n\n                tm.tm_hour = (int) hour;\n                tm.tm_min = (int) minute;\n                tm.tm_sec = 0;\n\n                assert_se(s = mktime(&tm));\n\n                *_u = (usec_t) s * USEC_PER_SEC;\n\n                while (*_u <= n)\n                        *_u += USEC_PER_DAY;\n        }\n\n        return 0;\n}\n\nstatic int shutdown_parse_argv(int argc, char *argv[]) {\n        enum {\n                ARG_HELP = 0x100,\n                ARG_NO_WALL\n        };\n\n        static const struct option options[] = {\n                { \"help\",      no_argument,       NULL, ARG_HELP    },\n                { \"halt\",      no_argument,       NULL, 'H'         },\n                { \"poweroff\",  no_argument,       NULL, 'P'         },\n                { \"reboot\",    no_argument,       NULL, 'r'         },\n                { \"kexec\",     no_argument,       NULL, 'K'         }, /* not documented extension */\n                { \"no-wall\",   no_argument,       NULL, ARG_NO_WALL },\n                {}\n        };\n\n        char **wall = NULL;\n        int c, r;\n\n        assert(argc >= 0);\n        assert(argv);\n\n        while ((c = getopt_long(argc, argv, \"HPrhkKat:fFc\", options, NULL)) >= 0)\n                switch (c) {\n\n                case ARG_HELP:\n                        shutdown_help();\n                        return 0;\n\n                case 'H':\n                        arg_action = ACTION_HALT;\n                        break;\n\n                case 'P':\n                        arg_action = ACTION_POWEROFF;\n                        break;\n\n                case 'r':\n                        if (kexec_loaded())\n                                arg_action = ACTION_KEXEC;\n                        else\n                                arg_action = ACTION_REBOOT;\n                        break;\n\n                case 'K':\n                        arg_action = ACTION_KEXEC;\n                        break;\n\n                case 'h':\n                        if (arg_action != ACTION_HALT)\n                                arg_action = ACTION_POWEROFF;\n                        break;\n\n                case 'k':\n                        arg_dry_run = true;\n                        break;\n\n                case ARG_NO_WALL:\n                        arg_no_wall = true;\n                        break;\n\n                case 'a':\n                case 't': /* Note that we also ignore any passed argument to -t, not just the -t itself */\n                case 'f':\n                case 'F':\n                        /* Compatibility nops */\n                        break;\n\n                case 'c':\n                        arg_action = ACTION_CANCEL_SHUTDOWN;\n                        break;\n\n                case '?':\n                        return -EINVAL;\n\n                default:\n                        assert_not_reached(\"Unhandled option\");\n                }\n\n        if (argc > optind && arg_action != ACTION_CANCEL_SHUTDOWN) {\n                r = parse_shutdown_time_spec(argv[optind], &arg_when);\n                if (r < 0) {\n                        log_error(\"Failed to parse time specification: %s\", argv[optind]);\n                        return r;\n                }\n        } else\n                arg_when = now(CLOCK_REALTIME) + USEC_PER_MINUTE;\n\n        if (argc > optind && arg_action == ACTION_CANCEL_SHUTDOWN)\n                /* No time argument for shutdown cancel */\n                wall = argv + optind;\n        else if (argc > optind + 1)\n                /* We skip the time argument */\n                wall = argv + optind + 1;\n\n        if (wall) {\n                arg_wall = strv_copy(wall);\n                if (!arg_wall)\n                        return log_oom();\n        }\n\n        optind = argc;\n\n        return 1;\n}\n\nstatic int telinit_parse_argv(int argc, char *argv[]) {\n        enum {\n                ARG_HELP = 0x100,\n                ARG_NO_WALL\n        };\n\n        static const struct option options[] = {\n                { \"help\",      no_argument,       NULL, ARG_HELP    },\n                { \"no-wall\",   no_argument,       NULL, ARG_NO_WALL },\n                {}\n        };\n\n        static const struct {\n                char from;\n                enum action to;\n        } table[] = {\n                { '0', ACTION_POWEROFF },\n                { '6', ACTION_REBOOT },\n                { '1', ACTION_RESCUE },\n                { '2', ACTION_RUNLEVEL2 },\n                { '3', ACTION_RUNLEVEL3 },\n                { '4', ACTION_RUNLEVEL4 },\n                { '5', ACTION_RUNLEVEL5 },\n                { 's', ACTION_RESCUE },\n                { 'S', ACTION_RESCUE },\n                { 'q', ACTION_RELOAD },\n                { 'Q', ACTION_RELOAD },\n                { 'u', ACTION_REEXEC },\n                { 'U', ACTION_REEXEC }\n        };\n\n        unsigned i;\n        int c;\n\n        assert(argc >= 0);\n        assert(argv);\n\n        while ((c = getopt_long(argc, argv, \"\", options, NULL)) >= 0)\n                switch (c) {\n\n                case ARG_HELP:\n                        telinit_help();\n                        return 0;\n\n                case ARG_NO_WALL:\n                        arg_no_wall = true;\n                        break;\n\n                case '?':\n                        return -EINVAL;\n\n                default:\n                        assert_not_reached(\"Unhandled option\");\n                }\n\n        if (optind >= argc) {\n                log_error(\"%s: required argument missing.\", program_invocation_short_name);\n                return -EINVAL;\n        }\n\n        if (optind + 1 < argc) {\n                log_error(\"Too many arguments.\");\n                return -EINVAL;\n        }\n\n        if (strlen(argv[optind]) != 1) {\n                log_error(\"Expected single character argument.\");\n                return -EINVAL;\n        }\n\n        for (i = 0; i < ELEMENTSOF(table); i++)\n                if (table[i].from == argv[optind][0])\n                        break;\n\n        if (i >= ELEMENTSOF(table)) {\n                log_error(\"Unknown command '%s'.\", argv[optind]);\n                return -EINVAL;\n        }\n\n        arg_action = table[i].to;\n\n        optind++;\n\n        return 1;\n}\n\nstatic int runlevel_parse_argv(int argc, char *argv[]) {\n        enum {\n                ARG_HELP = 0x100,\n        };\n\n        static const struct option options[] = {\n                { \"help\",      no_argument,       NULL, ARG_HELP    },\n                {}\n        };\n\n        int c;\n\n        assert(argc >= 0);\n        assert(argv);\n\n        while ((c = getopt_long(argc, argv, \"\", options, NULL)) >= 0)\n                switch (c) {\n\n                case ARG_HELP:\n                        runlevel_help();\n                        return 0;\n\n                case '?':\n                        return -EINVAL;\n\n                default:\n                        assert_not_reached(\"Unhandled option\");\n                }\n\n        if (optind < argc) {\n                log_error(\"Too many arguments.\");\n                return -EINVAL;\n        }\n\n        return 1;\n}\n\nstatic int parse_argv(int argc, char *argv[]) {\n        assert(argc >= 0);\n        assert(argv);\n\n        if (program_invocation_short_name) {\n\n                if (strstr(program_invocation_short_name, \"halt\")) {\n                        arg_action = ACTION_HALT;\n                        return halt_parse_argv(argc, argv);\n\n                } else if (strstr(program_invocation_short_name, \"poweroff\")) {\n                        arg_action = ACTION_POWEROFF;\n                        return halt_parse_argv(argc, argv);\n\n                } else if (strstr(program_invocation_short_name, \"reboot\")) {\n                        if (kexec_loaded())\n                                arg_action = ACTION_KEXEC;\n                        else\n                                arg_action = ACTION_REBOOT;\n                        return halt_parse_argv(argc, argv);\n\n                } else if (strstr(program_invocation_short_name, \"shutdown\")) {\n                        arg_action = ACTION_POWEROFF;\n                        return shutdown_parse_argv(argc, argv);\n\n                } else if (strstr(program_invocation_short_name, \"init\")) {\n\n                        /* Matches invocations as \"init\" as well as \"telinit\", which are synonymous when run as PID !=\n                         * 1 on SysV.\n                         *\n                         * On SysV \"telinit\" was the official command to communicate with PID 1, but \"init\" would\n                         * redirect itself to \"telinit\" if called with PID != 1. We follow the same logic here still,\n                         * though we add one level of indirection, as we implement \"telinit\" in \"systemctl\". Hence, for\n                         * us if you invoke \"init\" you get \"systemd\", but it will execve() \"systemctl\" immediately with\n                         * argv[] unmodified if PID is != 1. If you invoke \"telinit\" you directly get \"systemctl\". In\n                         * both cases we shall do the same thing, which is why we do strstr(p_i_s_n, \"init\") here, as a\n                         * quick way to match both.\n                         *\n                         * Also see redirect_telinit() in src/core/main.c. */\n\n                        if (sd_booted() > 0) {\n                                arg_action = _ACTION_INVALID;\n                                return telinit_parse_argv(argc, argv);\n                        } else {\n                                /* Hmm, so some other init system is running, we need to forward this request to\n                                 * it. For now we simply guess that it is Upstart. */\n\n                                execv(TELINIT, argv);\n\n                                log_error(\"Couldn't find an alternative telinit implementation to spawn.\");\n                                return -EIO;\n                        }\n\n                } else if (strstr(program_invocation_short_name, \"runlevel\")) {\n                        arg_action = ACTION_RUNLEVEL;\n                        return runlevel_parse_argv(argc, argv);\n                }\n        }\n\n        arg_action = ACTION_SYSTEMCTL;\n        return systemctl_parse_argv(argc, argv);\n}\n\n#if HAVE_SYSV_COMPAT\n_pure_ static int action_to_runlevel(void) {\n        static const char table[_ACTION_MAX] = {\n                [ACTION_HALT] =      '0',\n                [ACTION_POWEROFF] =  '0',\n                [ACTION_REBOOT] =    '6',\n                [ACTION_RUNLEVEL2] = '2',\n                [ACTION_RUNLEVEL3] = '3',\n                [ACTION_RUNLEVEL4] = '4',\n                [ACTION_RUNLEVEL5] = '5',\n                [ACTION_RESCUE] =    '1'\n        };\n\n        assert(arg_action >= 0 && arg_action < _ACTION_MAX);\n\n        return table[arg_action];\n}\n#endif\n\nstatic int talk_initctl(void) {\n#if HAVE_SYSV_COMPAT\n        struct init_request request = {\n                .magic = INIT_MAGIC,\n                .sleeptime  = 0,\n                .cmd = INIT_CMD_RUNLVL\n        };\n\n        _cleanup_close_ int fd = -1;\n        char rl;\n        int r;\n        const char *p;\n\n        rl = action_to_runlevel();\n        if (!rl)\n                return 0;\n\n        request.runlevel = rl;\n\n        FOREACH_STRING(p, \"/run/initctl\", \"/dev/initctl\") {\n                fd = open(p, O_WRONLY|O_NONBLOCK|O_CLOEXEC|O_NOCTTY);\n                if (fd >= 0 || errno != ENOENT)\n                        break;\n        }\n        if (fd < 0) {\n                if (errno == ENOENT)\n                        return 0;\n\n                return log_error_errno(errno, \"Failed to open initctl fifo: %m\");\n        }\n\n        r = loop_write(fd, &request, sizeof(request), false);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to write to %s: %m\", p);\n\n        return 1;\n#else\n        return 0;\n#endif\n}\n\nstatic int systemctl_main(int argc, char *argv[]) {\n        static const Verb verbs[] = {\n                { \"list-units\",            VERB_ANY, VERB_ANY, VERB_DEFAULT|VERB_ONLINE_ONLY, list_units },\n                { \"list-unit-files\",       VERB_ANY, VERB_ANY, 0,                list_unit_files      },\n                { \"list-sockets\",          VERB_ANY, VERB_ANY, VERB_ONLINE_ONLY, list_sockets         },\n                { \"list-timers\",           VERB_ANY, VERB_ANY, VERB_ONLINE_ONLY, list_timers          },\n                { \"list-jobs\",             VERB_ANY, VERB_ANY, VERB_ONLINE_ONLY, list_jobs            },\n                { \"list-machines\",         VERB_ANY, VERB_ANY, VERB_ONLINE_ONLY|VERB_MUST_BE_ROOT, list_machines },\n                { \"clear-jobs\",            VERB_ANY, 1,        VERB_ONLINE_ONLY, trivial_method       },\n                { \"cancel\",                VERB_ANY, VERB_ANY, VERB_ONLINE_ONLY, cancel_job           },\n                { \"start\",                 2,        VERB_ANY, VERB_ONLINE_ONLY, start_unit           },\n                { \"stop\",                  2,        VERB_ANY, VERB_ONLINE_ONLY, start_unit           },\n                { \"condstop\",              2,        VERB_ANY, VERB_ONLINE_ONLY, start_unit           }, /* For compatibility with ALTLinux */\n                { \"reload\",                2,        VERB_ANY, VERB_ONLINE_ONLY, start_unit           },\n                { \"restart\",               2,        VERB_ANY, VERB_ONLINE_ONLY, start_unit           },\n                { \"try-restart\",           2,        VERB_ANY, VERB_ONLINE_ONLY, start_unit           },\n                { \"reload-or-restart\",     2,        VERB_ANY, VERB_ONLINE_ONLY, start_unit           },\n                { \"reload-or-try-restart\", 2,        VERB_ANY, VERB_ONLINE_ONLY, start_unit           }, /* For compatbility with old systemctl <= 228 */\n                { \"try-reload-or-restart\", 2,        VERB_ANY, VERB_ONLINE_ONLY, start_unit           },\n                { \"force-reload\",          2,        VERB_ANY, VERB_ONLINE_ONLY, start_unit           }, /* For compatibility with SysV */\n                { \"condreload\",            2,        VERB_ANY, VERB_ONLINE_ONLY, start_unit           }, /* For compatibility with ALTLinux */\n                { \"condrestart\",           2,        VERB_ANY, VERB_ONLINE_ONLY, start_unit           }, /* For compatibility with RH */\n                { \"isolate\",               2,        2,        VERB_ONLINE_ONLY, start_unit           },\n                { \"kill\",                  2,        VERB_ANY, VERB_ONLINE_ONLY, kill_unit            },\n                { \"is-active\",             2,        VERB_ANY, VERB_ONLINE_ONLY, check_unit_active    },\n                { \"check\",                 2,        VERB_ANY, VERB_ONLINE_ONLY, check_unit_active    }, /* deprecated alias of is-active */\n                { \"is-failed\",             2,        VERB_ANY, VERB_ONLINE_ONLY, check_unit_failed    },\n                { \"show\",                  VERB_ANY, VERB_ANY, VERB_ONLINE_ONLY, show                 },\n                { \"cat\",                   2,        VERB_ANY, VERB_ONLINE_ONLY, cat                  },\n                { \"status\",                VERB_ANY, VERB_ANY, VERB_ONLINE_ONLY, show                 },\n                { \"help\",                  VERB_ANY, VERB_ANY, VERB_ONLINE_ONLY, show                 },\n                { \"daemon-reload\",         VERB_ANY, 1,        VERB_ONLINE_ONLY, daemon_reload        },\n                { \"daemon-reexec\",         VERB_ANY, 1,        VERB_ONLINE_ONLY, daemon_reload        },\n                { \"show-environment\",      VERB_ANY, 1,        VERB_ONLINE_ONLY, show_environment     },\n                { \"set-environment\",       2,        VERB_ANY, VERB_ONLINE_ONLY, set_environment      },\n                { \"unset-environment\",     2,        VERB_ANY, VERB_ONLINE_ONLY, set_environment      },\n                { \"import-environment\",    VERB_ANY, VERB_ANY, VERB_ONLINE_ONLY, import_environment   },\n                { \"halt\",                  VERB_ANY, 1,        VERB_ONLINE_ONLY, start_system_special },\n                { \"poweroff\",              VERB_ANY, 1,        VERB_ONLINE_ONLY, start_system_special },\n                { \"reboot\",                VERB_ANY, 2,        VERB_ONLINE_ONLY, start_system_special },\n                { \"kexec\",                 VERB_ANY, 1,        VERB_ONLINE_ONLY, start_system_special },\n                { \"suspend\",               VERB_ANY, 1,        VERB_ONLINE_ONLY, start_system_special },\n                { \"hibernate\",             VERB_ANY, 1,        VERB_ONLINE_ONLY, start_system_special },\n                { \"hybrid-sleep\",          VERB_ANY, 1,        VERB_ONLINE_ONLY, start_system_special },\n                { \"suspend-then-hibernate\",VERB_ANY, 1,        VERB_ONLINE_ONLY, start_system_special },\n                { \"default\",               VERB_ANY, 1,        VERB_ONLINE_ONLY, start_special        },\n                { \"rescue\",                VERB_ANY, 1,        VERB_ONLINE_ONLY, start_system_special },\n                { \"emergency\",             VERB_ANY, 1,        VERB_ONLINE_ONLY, start_system_special },\n                { \"exit\",                  VERB_ANY, 2,        VERB_ONLINE_ONLY, start_special        },\n                { \"reset-failed\",          VERB_ANY, VERB_ANY, VERB_ONLINE_ONLY, reset_failed         },\n                { \"enable\",                2,        VERB_ANY, 0,                enable_unit          },\n                { \"disable\",               2,        VERB_ANY, 0,                enable_unit          },\n                { \"is-enabled\",            2,        VERB_ANY, 0,                unit_is_enabled      },\n                { \"reenable\",              2,        VERB_ANY, 0,                enable_unit          },\n                { \"preset\",                2,        VERB_ANY, 0,                enable_unit          },\n                { \"preset-all\",            VERB_ANY, 1,        0,                preset_all           },\n                { \"mask\",                  2,        VERB_ANY, 0,                enable_unit          },\n                { \"unmask\",                2,        VERB_ANY, 0,                enable_unit          },\n                { \"link\",                  2,        VERB_ANY, 0,                enable_unit          },\n                { \"revert\",                2,        VERB_ANY, 0,                enable_unit          },\n                { \"switch-root\",           2,        VERB_ANY, VERB_ONLINE_ONLY, switch_root          },\n                { \"list-dependencies\",     VERB_ANY, 2,        VERB_ONLINE_ONLY, list_dependencies    },\n                { \"set-default\",           2,        2,        0,                set_default          },\n                { \"get-default\",           VERB_ANY, 1,        0,                get_default          },\n                { \"set-property\",          3,        VERB_ANY, VERB_ONLINE_ONLY, set_property         },\n                { \"is-system-running\",     VERB_ANY, 1,        0,                is_system_running    },\n                { \"add-wants\",             3,        VERB_ANY, 0,                add_dependency       },\n                { \"add-requires\",          3,        VERB_ANY, 0,                add_dependency       },\n                { \"edit\",                  2,        VERB_ANY, VERB_ONLINE_ONLY, edit                 },\n                {}\n        };\n\n        return dispatch_verb(argc, argv, verbs, NULL);\n}\n\nstatic int reload_with_fallback(void) {\n        /* First, try systemd via D-Bus. */\n        if (daemon_reload(0, NULL, NULL) >= 0)\n                return 0;\n\n        /* Nothing else worked, so let's try signals */\n        assert(IN_SET(arg_action, ACTION_RELOAD, ACTION_REEXEC));\n\n        if (kill(1, arg_action == ACTION_RELOAD ? SIGHUP : SIGTERM) < 0)\n                return log_error_errno(errno, \"kill() failed: %m\");\n\n        return 0;\n}\n\nstatic int start_with_fallback(void) {\n        /* First, try systemd via D-Bus. */\n        if (start_unit(0, NULL, NULL) >= 0)\n                return 0;\n\n        /* Nothing else worked, so let's try /dev/initctl */\n        if (talk_initctl() > 0)\n                return 0;\n\n        log_error(\"Failed to talk to init daemon.\");\n        return -EIO;\n}\n\nstatic int halt_now(enum action a) {\n        /* The kernel will automatically flush ATA disks and suchlike on reboot(), but the file systems need to be\n         * synce'd explicitly in advance. */\n        if (!arg_no_sync && !arg_dry_run)\n                (void) sync();\n\n        /* Make sure C-A-D is handled by the kernel from this point on... */\n        if (!arg_dry_run)\n                (void) reboot(RB_ENABLE_CAD);\n\n        switch (a) {\n\n        case ACTION_HALT:\n                if (!arg_quiet)\n                        log_info(\"Halting.\");\n                if (arg_dry_run)\n                        return 0;\n                (void) reboot(RB_HALT_SYSTEM);\n                return -errno;\n\n        case ACTION_POWEROFF:\n                if (!arg_quiet)\n                        log_info(\"Powering off.\");\n                if (arg_dry_run)\n                        return 0;\n                (void) reboot(RB_POWER_OFF);\n                return -errno;\n\n        case ACTION_KEXEC:\n        case ACTION_REBOOT:\n                return reboot_with_parameter(REBOOT_FALLBACK |\n                                             (arg_quiet ? 0 : REBOOT_LOG) |\n                                             (arg_dry_run ? REBOOT_DRY_RUN : 0));\n\n        default:\n                assert_not_reached(\"Unknown action.\");\n        }\n}\n\nstatic int logind_schedule_shutdown(void) {\n\n#if ENABLE_LOGIND\n        _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n        char date[FORMAT_TIMESTAMP_MAX];\n        const char *action;\n        sd_bus *bus;\n        int r;\n\n        r = acquire_bus(BUS_FULL, &bus);\n        if (r < 0)\n                return r;\n\n        switch (arg_action) {\n        case ACTION_HALT:\n                action = \"halt\";\n                break;\n        case ACTION_POWEROFF:\n                action = \"poweroff\";\n                break;\n        case ACTION_KEXEC:\n                action = \"kexec\";\n                break;\n        case ACTION_EXIT:\n                action = \"exit\";\n                break;\n        case ACTION_REBOOT:\n        default:\n                action = \"reboot\";\n                break;\n        }\n\n        if (arg_dry_run)\n                action = strjoina(\"dry-\", action);\n\n        (void) logind_set_wall_message();\n\n        r = sd_bus_call_method(\n                        bus,\n                        \"org.freedesktop.login1\",\n                        \"/org/freedesktop/login1\",\n                        \"org.freedesktop.login1.Manager\",\n                        \"ScheduleShutdown\",\n                        &error,\n                        NULL,\n                        \"st\",\n                        action,\n                        arg_when);\n        if (r < 0)\n                return log_warning_errno(r, \"Failed to call ScheduleShutdown in logind, proceeding with immediate shutdown: %s\", bus_error_message(&error, r));\n\n        if (!arg_quiet)\n                log_info(\"Shutdown scheduled for %s, use 'shutdown -c' to cancel.\", format_timestamp(date, sizeof(date), arg_when));\n        return 0;\n#else\n        log_error(\"Cannot schedule shutdown without logind support, proceeding with immediate shutdown.\");\n        return -ENOSYS;\n#endif\n}\n\nstatic int halt_main(void) {\n        int r;\n\n        r = logind_check_inhibitors(arg_action);\n        if (r < 0)\n                return r;\n\n        if (arg_when > 0)\n                return logind_schedule_shutdown();\n\n        if (geteuid() != 0) {\n                if (arg_dry_run || arg_force > 0) {\n                        (void) must_be_root();\n                        return -EPERM;\n                }\n\n                /* Try logind if we are a normal user and no special\n                 * mode applies. Maybe PolicyKit allows us to shutdown\n                 * the machine. */\n                if (IN_SET(arg_action, ACTION_POWEROFF, ACTION_REBOOT, ACTION_HALT)) {\n                        r = logind_reboot(arg_action);\n                        if (r >= 0)\n                                return r;\n                        if (IN_SET(r, -EOPNOTSUPP, -EINPROGRESS))\n                                /* requested operation is not\n                                 * supported on the local system or\n                                 * already in progress */\n                                return r;\n                        /* on all other errors, try low-level operation */\n                }\n        }\n\n        /* In order to minimize the difference between operation with and\n         * without logind, we explicitly enable non-blocking mode for this,\n         * as logind's shutdown operations are always non-blocking. */\n        arg_no_block = true;\n\n        if (!arg_dry_run && !arg_force)\n                return start_with_fallback();\n\n        assert(geteuid() == 0);\n\n        if (!arg_no_wtmp) {\n                if (sd_booted() > 0)\n                        log_debug(\"Not writing utmp record, assuming that systemd-update-utmp is used.\");\n                else {\n                        r = utmp_put_shutdown();\n                        if (r < 0)\n                                log_warning_errno(r, \"Failed to write utmp record: %m\");\n                }\n        }\n\n        if (arg_dry_run)\n                return 0;\n\n        r = halt_now(arg_action);\n        return log_error_errno(r, \"Failed to reboot: %m\");\n}\n\nstatic int runlevel_main(void) {\n        int r, runlevel, previous;\n\n        r = utmp_get_runlevel(&runlevel, &previous);\n        if (r < 0) {\n                puts(\"unknown\");\n                return r;\n        }\n\n        printf(\"%c %c\\n\",\n               previous <= 0 ? 'N' : previous,\n               runlevel <= 0 ? 'N' : runlevel);\n\n        return 0;\n}\n\nstatic int logind_cancel_shutdown(void) {\n#if ENABLE_LOGIND\n        _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n        sd_bus *bus;\n        int r;\n\n        r = acquire_bus(BUS_FULL, &bus);\n        if (r < 0)\n                return r;\n\n        (void) logind_set_wall_message();\n\n        r = sd_bus_call_method(\n                        bus,\n                        \"org.freedesktop.login1\",\n                        \"/org/freedesktop/login1\",\n                        \"org.freedesktop.login1.Manager\",\n                        \"CancelScheduledShutdown\",\n                        &error,\n                        NULL, NULL);\n        if (r < 0)\n                return log_warning_errno(r, \"Failed to talk to logind, shutdown hasn't been cancelled: %s\", bus_error_message(&error, r));\n\n        return 0;\n#else\n        log_error(\"Not compiled with logind support, cannot cancel scheduled shutdowns.\");\n        return -ENOSYS;\n#endif\n}\n\nint main(int argc, char*argv[]) {\n        int r;\n\n        argv_cmdline = argv[0];\n\n        setlocale(LC_ALL, \"\");\n        log_parse_environment();\n        log_open();\n        sigbus_install();\n\n        /* Explicitly not on_tty() to avoid setting cached value.\n         * This becomes relevant for piping output which might be\n         * ellipsized. */\n        original_stdout_is_tty = isatty(STDOUT_FILENO);\n\n        r = parse_argv(argc, argv);\n        if (r <= 0)\n                goto finish;\n\n        if (arg_action != ACTION_SYSTEMCTL && running_in_chroot() > 0) {\n\n                if (!arg_quiet)\n                        log_info(\"Running in chroot, ignoring request.\");\n                r = 0;\n                goto finish;\n        }\n\n        /* systemctl_main() will print an error message for the bus\n         * connection, but only if it needs to */\n\n        switch (arg_action) {\n\n        case ACTION_SYSTEMCTL:\n                r = systemctl_main(argc, argv);\n                break;\n\n        /* Legacy command aliases set arg_action. They provide some fallbacks,\n         * e.g. to tell sysvinit to reboot after you have installed systemd\n         * binaries. */\n\n        case ACTION_HALT:\n        case ACTION_POWEROFF:\n        case ACTION_REBOOT:\n        case ACTION_KEXEC:\n                r = halt_main();\n                break;\n\n        case ACTION_RUNLEVEL2:\n        case ACTION_RUNLEVEL3:\n        case ACTION_RUNLEVEL4:\n        case ACTION_RUNLEVEL5:\n        case ACTION_RESCUE:\n                r = start_with_fallback();\n                break;\n\n        case ACTION_RELOAD:\n        case ACTION_REEXEC:\n                r = reload_with_fallback();\n                break;\n\n        case ACTION_CANCEL_SHUTDOWN:\n                r = logind_cancel_shutdown();\n                break;\n\n        case ACTION_RUNLEVEL:\n                r = runlevel_main();\n                break;\n\n        case ACTION_EXIT:\n        case ACTION_SUSPEND:\n        case ACTION_HIBERNATE:\n        case ACTION_HYBRID_SLEEP:\n        case ACTION_SUSPEND_THEN_HIBERNATE:\n        case ACTION_EMERGENCY:\n        case ACTION_DEFAULT:\n                /* systemctl verbs with no equivalent in the legacy commands.\n                 * These cannot appear in arg_action.  Fall through. */\n\n        case _ACTION_INVALID:\n        default:\n                assert_not_reached(\"Unknown action\");\n        }\n\nfinish:\n        release_busses();\n\n        pager_close();\n        ask_password_agent_close();\n        polkit_agent_close();\n\n        strv_free(arg_types);\n        strv_free(arg_states);\n        strv_free(arg_properties);\n\n        strv_free(arg_wall);\n        free(arg_root);\n        free(arg_esp_path);\n\n        /* Note that we return r here, not EXIT_SUCCESS, so that we can implement the LSB-like return codes */\n        return r < 0 ? EXIT_FAILURE : r;\n}\n"}, "15": {"id": 15, "path": "/media/lavo07/lavo07/systemd-239/build/config.h", "content": "/*\n * Autogenerated by the Meson build system.\n * Do not edit, your changes will be lost.\n */\n\n#pragma once\n\n#define ABS_BUILD_DIR \"/media/lavo07/lavo07/systemd-239/build\"\n\n#define ABS_SRC_DIR \"/media/lavo07/lavo07/systemd-239\"\n\n#define ANSI_OK_COLOR ANSI_GREEN\n\n#define BOOTLIBDIR \"/usr/lib/systemd/boot/efi\"\n\n#define CATALOG_DATABASE \"/var/lib/systemd/catalog/database\"\n\n#define CERTIFICATE_ROOT \"/etc/ssl\"\n\n#define CONTAINER_UID_BASE_MAX 1878982656\n\n#define CONTAINER_UID_BASE_MIN 524288\n\n#define DEFAULT_DNSSEC_MODE DNSSEC_NO\n\n#define DEFAULT_DNS_OVER_TLS_MODE DNS_OVER_TLS_NO\n\n#define DEFAULT_HIERARCHY CGROUP_UNIFIED_SYSTEMD\n\n/* default cgroup hierarchy as string */\n#define DEFAULT_HIERARCHY_NAME \"hybrid\"\n\n#define DNS_SERVERS \"8.8.8.8 8.8.4.4 2001:4860:4860::8888 2001:4860:4860::8844\"\n\n#define DOCUMENT_ROOT \"/usr/share/systemd/gatewayd\"\n\n#define DYNAMIC_UID_MAX 65519\n\n#define DYNAMIC_UID_MIN 61184\n\n#define EFI_MACHINE_TYPE_NAME \"x64\"\n\n#define ENABLE_ADM_GROUP 1\n\n#define ENABLE_BACKLIGHT 1\n\n#define ENABLE_BINFMT 1\n\n#define ENABLE_COMPAT_GATEWAY_HOSTNAME 0\n\n#define ENABLE_COREDUMP 1\n\n#define ENABLE_DEBUG_HASHMAP 0\n\n#define ENABLE_DEBUG_MMAP_CACHE 0\n\n#define ENABLE_DNS_OVER_TLS 0\n\n#define ENABLE_EFI 1\n\n#define ENABLE_ENVIRONMENT_D 1\n\n#define ENABLE_FIRSTBOOT 1\n\n#define ENABLE_GSHADOW 1\n\n#define ENABLE_HIBERNATE 1\n\n#define ENABLE_HOSTNAMED 1\n\n#define ENABLE_HWDB 1\n\n#define ENABLE_IDN 1\n\n#define ENABLE_IMA 1\n\n#define ENABLE_IMPORTD 0\n\n#define ENABLE_LDCONFIG 1\n\n#define ENABLE_LOCALED 1\n\n#define ENABLE_LOGIND 1\n\n#define ENABLE_MACHINED 1\n\n#define ENABLE_MYHOSTNAME 1\n\n#define ENABLE_NETWORKD 1\n\n#define ENABLE_NSS_SYSTEMD 1\n\n#define ENABLE_POLKIT 1\n\n#define ENABLE_PORTABLED 1\n\n#define ENABLE_QUOTACHECK 1\n\n#define ENABLE_RANDOMSEED 1\n\n#define ENABLE_REMOTE 0\n\n#define ENABLE_RESOLVE 1\n\n#define ENABLE_RFKILL 1\n\n#define ENABLE_SMACK 1\n\n#define ENABLE_SYSUSERS 1\n\n#define ENABLE_TIMEDATECTL 1\n\n#define ENABLE_TIMEDATED 1\n\n#define ENABLE_TIMESYNCD 1\n\n#define ENABLE_TMPFILES 1\n\n#define ENABLE_TPM 1\n\n#define ENABLE_UTMP 1\n\n#define ENABLE_VCONSOLE 1\n\n#define ENABLE_WHEEL_GROUP 1\n\n#define FALLBACK_HOSTNAME \"localhost\"\n\n#define GETTEXT_PACKAGE \"systemd\"\n\n/* The type of gperf \"len\" parameter */\n#define GPERF_LEN_TYPE size_t\n\n#define HAVE_ACL 0\n\n#define HAVE_APPARMOR 0\n\n#define HAVE_AUDIT 0\n\n#define HAVE_BLKID 1\n\n#define HAVE_BPF 0\n\n#define HAVE_BZIP2 0\n\n#define HAVE_CHAR16_T 1\n\n#define HAVE_CHAR32_T 1\n\n#define HAVE_COPY_FILE_RANGE 1\n\n#define HAVE_CRYPT_H 1\n\n#define HAVE_DBUS 1\n\n#define HAVE_ELFUTILS 0\n\n#define HAVE_EXPLICIT_BZERO 1\n\n#define HAVE_FRA_UID_RANGE 1\n\n#define HAVE_GCRYPT 0\n\n#define HAVE_GETRANDOM 1\n\n#define HAVE_GETTID 0\n\n#define HAVE_GLIB 1\n\n#define HAVE_GNUTLS 0\n\n#define HAVE_IFA_FLAGS 1\n\n#define HAVE_IFLA_BOND_AD_INFO 1\n\n#define HAVE_IFLA_BRIDGE_VLAN_INFO 1\n\n#define HAVE_IFLA_BRPORT_LEARNING_SYNC 1\n\n#define HAVE_IFLA_BRPORT_PROXYARP 1\n\n#define HAVE_IFLA_BR_VLAN_DEFAULT_PVID 1\n\n#define HAVE_IFLA_GENEVE_LABEL 1\n\n#define HAVE_IFLA_GRE_ENCAP_DPORT 1\n\n#define HAVE_IFLA_INET6_ADDR_GEN_MODE 1\n\n#define HAVE_IFLA_IPTUN_ENCAP_DPORT 1\n\n#define HAVE_IFLA_IPVLAN_FLAGS 1\n\n#define HAVE_IFLA_MACVLAN_FLAGS 1\n\n#define HAVE_IFLA_PHYS_PORT_ID 1\n\n#define HAVE_IFLA_VLAN_PROTOCOL 1\n\n#define HAVE_IFLA_VRF_TABLE 1\n\n#define HAVE_IFLA_VTI_REMOTE 1\n\n#define HAVE_IFLA_VXLAN_GPE 1\n\n#define HAVE_IFLA_VXLAN_REMCSUM_NOPARTIAL 1\n\n#define HAVE_IN6_ADDR_GEN_MODE_STABLE_PRIVACY 1\n\n#define HAVE_IPVLAN_F_PRIVATE 1\n\n#define HAVE_KCMP 0\n\n#define HAVE_KEYCTL 0\n\n#define HAVE_KEY_SERIAL_T 0\n\n#define HAVE_KMOD 0\n\n#define HAVE_LIBCRYPTSETUP 0\n\n#define HAVE_LIBCURL 0\n\n#define HAVE_LIBIDN 0\n\n#define HAVE_LIBIDN2 0\n\n#define HAVE_LIBIPTC 0\n\n#define HAVE_LINUX_BTRFS_H 1\n\n#define HAVE_LINUX_MEMFD_H 1\n\n#define HAVE_LINUX_VM_SOCKETS_H 1\n\n#define HAVE_LO_FLAGS_PARTSCAN 1\n\n#define HAVE_LZ4 0\n\n#define HAVE_MEMFD_CREATE 1\n\n#define HAVE_MICROHTTPD 0\n\n#define HAVE_NAME_TO_HANDLE_AT 1\n\n#define HAVE_NDA_IFINDEX 1\n\n#define HAVE_PAM 0\n\n#define HAVE_PCRE2 0\n\n#define HAVE_PIVOT_ROOT 0\n\n#define HAVE_QRENCODE 0\n\n#define HAVE_REALLOCARRAY 1\n\n#define HAVE_RENAMEAT2 0\n\n#define HAVE_SECCOMP 0\n\n#define HAVE_SECURE_GETENV 1\n\n#define HAVE_SELINUX 0\n\n#define HAVE_SETNS 1\n\n/* bin and sbin directories are separate */\n#define HAVE_SPLIT_BIN 1\n\n/* /usr/bin and /bin directories are separate */\n#define HAVE_SPLIT_USR 1\n\n#define HAVE_STATX 0\n\n#define HAVE_STRUCT_ETHTOOL_LINK_SETTINGS 1\n\n#define HAVE_STRUCT_FIB_RULE_UID_RANGE 1\n\n#define HAVE_STRUCT_STATX 1\n\n/* SysV init scripts and rcN.d links are supported */\n#define HAVE_SYSV_COMPAT 1\n\n#define HAVE_SYS_AUXV_H 1\n\n#define HAVE_VALGRIND_MEMCHECK_H 0\n\n#define HAVE_VALGRIND_VALGRIND_H 0\n\n#define HAVE_VXCAN_INFO_PEER 1\n\n#define HAVE_XKBCOMMON 1\n\n#define HAVE_XZ 1\n\n#define HAVE_ZLIB 1\n\n#define HAVE___SECURE_GETENV 0\n\n#define KBD_LOADKEYS \"/usr/bin/loadkeys\"\n\n#define KBD_SETFONT \"/bin/setfont\"\n\n#define KEXEC \"/usr/sbin/kexec\"\n\n#define KILL_USER_PROCESSES 1\n\n#define KILL_USER_PROCESSES_YES_NO \"yes\"\n\n#define KMOD \"/bin/kmod\"\n\n#define LIBDIR \"/usr/lib/x86_64-linux-gnu\"\n\n#define MEMORY_ACCOUNTING_DEFAULT true\n\n#define MEMORY_ACCOUNTING_DEFAULT_YES_NO \"yes\"\n\n#define MOUNT_PATH \"/bin/mount\"\n\n#define NOBODY_GROUP_NAME \"nobody\"\n\n#define NOBODY_USER_NAME \"nobody\"\n\n#define NTP_SERVERS \"time1.google.com time2.google.com time3.google.com time4.google.com\"\n\n#define PACKAGE_STRING \"systemd 239\"\n\n#define PACKAGE_VERSION \"239\"\n\n#define PKGSYSCONFDIR \"/etc/systemd\"\n\n#define POLKIT_AGENT_BINARY_PATH \"/usr/bin/pkttyagent\"\n\n#define QUOTACHECK \"/usr/sbin/quotacheck\"\n\n#define QUOTAON \"/usr/sbin/quotaon\"\n\n#define RANDOM_SEED \"/var/lib/systemd/random-seed\"\n\n#define RANDOM_SEED_DIR \"/var/lib/systemd\"\n\n#define RC_LOCAL_SCRIPT_PATH_START \"/etc/rc.local\"\n\n#define RC_LOCAL_SCRIPT_PATH_STOP \"/usr/sbin/halt.local\"\n\n#define ROOTLIBDIR \"/x86_64-linux-gnu\"\n\n#define ROOTLIBEXECDIR \"/lib/systemd\"\n\n#define ROOTPREFIX \"/\"\n\n#define SD_TPM_PCR 8\n\n#define SIZEOF_DEV_T 8\n\n#define SIZEOF_GID_T 4\n\n#define SIZEOF_INO_T 8\n\n#define SIZEOF_PID_T 4\n\n#define SIZEOF_RLIM_T 8\n\n#define SIZEOF_TIME_T 8\n\n#define SIZEOF_UID_T 4\n\n#define SULOGIN \"/sbin/sulogin\"\n\n#define SYSTEMCTL_BINARY_PATH \"/bin/systemctl\"\n\n#define SYSTEMD_BINARY_PATH \"/lib/systemd/systemd\"\n\n#define SYSTEMD_CGROUP_AGENT_PATH \"/lib/systemd/systemd-cgroups-agent\"\n\n#define SYSTEMD_CRYPTSETUP_PATH \"/lib/systemd/systemd-cryptsetup\"\n\n#define SYSTEMD_EXPORT_PATH \"/lib/systemd/systemd-export\"\n\n#define SYSTEMD_FSCK_PATH \"/lib/systemd/systemd-fsck\"\n\n#define SYSTEMD_GROWFS_PATH \"/lib/systemd/systemd-growfs\"\n\n#define SYSTEMD_IMPORT_PATH \"/lib/systemd/systemd-import\"\n\n#define SYSTEMD_KBD_MODEL_MAP \"/usr/share/systemd/kbd-model-map\"\n\n#define SYSTEMD_LANGUAGE_FALLBACK_MAP \"/usr/share/systemd/language-fallback-map\"\n\n#define SYSTEMD_MAKEFS_PATH \"/lib/systemd/systemd-makefs\"\n\n#define SYSTEMD_PULL_PATH \"/lib/systemd/systemd-pull\"\n\n#define SYSTEMD_SHUTDOWN_BINARY_PATH \"/lib/systemd/systemd-shutdown\"\n\n#define SYSTEMD_SLEEP_BINARY_PATH \"/lib/systemd/systemd-sleep\"\n\n#define SYSTEMD_SLOW_TESTS_DEFAULT 0\n\n#define SYSTEMD_STDIO_BRIDGE_BINARY_PATH \"/usr/bin/systemd-stdio-bridge\"\n\n#define SYSTEMD_TTY_ASK_PASSWORD_AGENT_BINARY_PATH \"/bin/systemd-tty-ask-password-agent\"\n\n#define SYSTEM_CONFIG_UNIT_PATH \"/etc/systemd/system\"\n\n#define SYSTEM_DATA_UNIT_PATH \"/lib/systemd/system\"\n\n#define SYSTEM_ENV_GENERATOR_PATH \"/usr/lib/systemd/system-environment-generators\"\n\n#define SYSTEM_GENERATOR_PATH \"/lib/systemd/system-generators\"\n\n#define SYSTEM_GID_MAX 999\n\n#define SYSTEM_SHUTDOWN_PATH \"/lib/systemd/system-shutdown\"\n\n#define SYSTEM_SLEEP_PATH \"/lib/systemd/system-sleep\"\n\n#define SYSTEM_SYSVINIT_PATH \"/etc/init.d\"\n\n#define SYSTEM_SYSVRCND_PATH \"/etc/rc.d\"\n\n#define SYSTEM_UID_MAX 999\n\n#define TELINIT \"/lib/sysvinit/telinit\"\n\n#define TIME_EPOCH 1529665909\n\n#define TTY_GID 5\n\n#define UDEVLIBEXECDIR \"/lib/udev\"\n\n#define UMOUNT_PATH \"/bin/umount\"\n\n#define USER_CONFIG_UNIT_PATH \"/etc/systemd/user\"\n\n#define USER_DATA_UNIT_PATH \"/usr/lib/systemd/user\"\n\n#define USER_ENV_GENERATOR_PATH \"/usr/lib/systemd/user-environment-generators\"\n\n#define USER_GENERATOR_PATH \"/usr/lib/systemd/user-generators\"\n\n#define USER_KEYRING_PATH \"/etc/systemd/import-pubring.gpg\"\n\n#define USE_SYS_RANDOM_H 1\n\n#define VALGRIND 0\n\n#define VENDOR_KEYRING_PATH \"/lib/systemd/import-pubring.gpg\"\n\n#define _GNU_SOURCE\n\n#define __SANE_USERSPACE_TYPES__\n\n"}}, "reports": [{"events": [{"location": {"col": 22, "file": 4, "line": 263}, "message": "expanded from macro 'assert'"}, {"location": {"col": 17, "file": 14, "line": 3111}, "message": "found assert() with side effect"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/systemd-239/src/systemctl/systemctl.c", "reportHash": "e0d5cb6f93e730940452d21ef4f3ed4c", "checkerName": "bugprone-assert-side-effect", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 24, "file": 15, "line": 349}, "message": "expanded from macro 'ROOTLIBEXECDIR'"}, {"location": {"col": 25, "file": 14, "line": 5856}, "message": "suspicious string literal, probably missing a comma"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/systemd-239/src/systemctl/systemctl.c", "reportHash": "87e83b19b529a596bd1223f8d8c5cae8", "checkerName": "misc-suspicious-missing-comma", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 22, "file": 4, "line": 263}, "message": "expanded from macro 'assert'"}, {"location": {"col": 9, "file": 14, "line": 8270}, "message": "found assert() with side effect"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/systemd-239/src/systemctl/systemctl.c", "reportHash": "9fd3b62477dffdff2f978cd386f15321", "checkerName": "bugprone-assert-side-effect", "reviewStatus": null, "severity": "MEDIUM"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
